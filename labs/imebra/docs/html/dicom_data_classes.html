

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>DICOM dataSet &amp; tags classes &mdash; Imebra 4.5.2.1 documentation</title>
  

  
  
  
  

  

  
  
    

  

  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="copyright" title="Copyright" href="copyright.html" />
    <link rel="next" title="Stream classes" href="stream_classes.html" />
    <link rel="prev" title="Objects lifecycle and Object ownership" href="objects_lifecycle.html" /> 

  
  <script src="_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="index.html" class="icon icon-home"> Imebra
          

          
          </a>

          
            
            
              <div class="version">
                4.5.2
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Download Imebra</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="download.html">Downloading Imebra</a></li>
</ul>
<p class="caption"><span class="caption-text">Legal</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="copyright.html">Copyright</a></li>
<li class="toctree-l1"><a class="reference internal" href="gplv2.html">GNU General Public License</a></li>
</ul>
<p class="caption"><span class="caption-text">Introduction</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="introduction.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="changes_log.html">Changes log</a></li>
</ul>
<p class="caption"><span class="caption-text">User documentation</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="compiling_imebra.html">Compiling Imebra</a></li>
<li class="toctree-l1"><a class="reference internal" href="add_to_project.html">Adding Imebra to your project</a></li>
<li class="toctree-l1"><a class="reference internal" href="quick_tour.html">Getting started</a></li>
</ul>
<p class="caption"><span class="caption-text">API</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="objects_lifecycle.html">Objects lifecycle and Object ownership</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">DICOM dataSet &amp; tags classes</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#introduction">Introduction</a></li>
<li class="toctree-l2"><a class="reference internal" href="#data-storage">Data storage</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#dataset">DataSet</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#c">C++</a></li>
<li class="toctree-l4"><a class="reference internal" href="#objective-c-swift">Objective-C/Swift</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#tag">Tag</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id3">C++</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id4">Objective-C/Swift</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#data-access">Data access</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#tagid">TagId</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id6">C++</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id7">Objective-C/Swift</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#readingdatahandler">ReadingDataHandler</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id9">C++</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id10">Objective-C/Swift</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#readingdatahandlernumeric">ReadingDataHandlerNumeric</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id12">C++</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id13">Objective-C/Swift</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#writingdatahandler">WritingDataHandler</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id15">C++</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id16">Objective-C/Swift</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#writingdatahandlernumeric">WritingDataHandlerNumeric</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id18">C++</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id19">Objective-C/Swift</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="stream_classes.html">Stream classes</a></li>
<li class="toctree-l1"><a class="reference internal" href="imaging_classes.html">Imaging classes</a></li>
<li class="toctree-l1"><a class="reference internal" href="transforms_classes.html">Transforms classes</a></li>
<li class="toctree-l1"><a class="reference internal" href="memory_management_classes.html">Memory management classes</a></li>
<li class="toctree-l1"><a class="reference internal" href="acse_classes.html">ACSE classes</a></li>
<li class="toctree-l1"><a class="reference internal" href="dimse_classes.html">DIMSE classes</a></li>
<li class="toctree-l1"><a class="reference internal" href="dicomdir_classes.html">DICOMDIR classes</a></li>
<li class="toctree-l1"><a class="reference internal" href="dicom_dictionary_classes.html">DICOM dictionary</a></li>
<li class="toctree-l1"><a class="reference internal" href="definition_classes.html">Definitions</a></li>
<li class="toctree-l1"><a class="reference internal" href="exception_classes.html">Exceptions</a></li>
</ul>
<p class="caption"><span class="caption-text">Build distributions</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="build_distribution.html">Creating the source distribution from the code in the VCS</a></li>
<li class="toctree-l1"><a class="reference internal" href="build_distribution.html#versioning">Versioning</a></li>
</ul>
<p class="caption"><span class="caption-text">Requirements &amp; Risks</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="risks_requirements.html">Requirements</a></li>
<li class="toctree-l1"><a class="reference internal" href="risks_requirements.html#risks">Risks</a></li>
</ul>
<p class="caption"><span class="caption-text">Standard operating procedures</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="sop.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="sop.html#sops">SOPs</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">Imebra</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html">Docs</a> &raquo;</li>
        
      <li>DICOM dataSet &amp; tags classes</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="_sources/dicom_data_classes.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="dicom-dataset-tags-classes">
<h1>DICOM dataSet &amp; tags classes<a class="headerlink" href="#dicom-dataset-tags-classes" title="Permalink to this headline">¶</a></h1>
<div class="section" id="introduction">
<h2>Introduction<a class="headerlink" href="#introduction" title="Permalink to this headline">¶</a></h2>
<p>This section describes the classes and methods responsible for storing, retrieving and setting the information that composes the
DICOM structure, represented by the class <a class="reference internal" href="#dataset"><span class="std std-ref">DataSet</span></a>.</p>
<p>The following classes are described in this chapter:</p>
<table border="1" class="docutils">
<colgroup>
<col width="38%" />
<col width="37%" />
<col width="25%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">C++ class</th>
<th class="head">Objective-C/Swift class</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><a class="reference internal" href="#_CPPv3N6imebra7DataSetE" title="imebra::DataSet"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">imebra::DataSet</span></code></a></td>
<td><a class="reference internal" href="#_CPPv313ImebraDataSet" title="ImebraDataSet"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">ImebraDataSet</span></code></a></td>
<td>Stored a complete DICOM
structure</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#_CPPv3N6imebra3TagE" title="imebra::Tag"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">imebra::Tag</span></code></a></td>
<td><a class="reference internal" href="#_CPPv39ImebraTag" title="ImebraTag"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">ImebraTag</span></code></a></td>
<td>Stores a single DICOM tag</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#_CPPv3N6imebra5TagIdE" title="imebra::TagId"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">imebra::TagId</span></code></a></td>
<td><a class="reference internal" href="#_CPPv311ImebraTagId" title="ImebraTagId"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">ImebraTagId</span></code></a></td>
<td>Identifies a tag</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#_CPPv3N6imebra18ReadingDataHandlerE" title="imebra::ReadingDataHandler"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">imebra::ReadingDataHandler</span></code></a></td>
<td><a class="reference internal" href="#_CPPv324ImebraReadingDataHandler" title="ImebraReadingDataHandler"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">ImebraReadingDataHandler</span></code></a></td>
<td>Read data from a tag</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#_CPPv3N6imebra25ReadingDataHandlerNumericE" title="imebra::ReadingDataHandlerNumeric"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">imebra::ReadingDataHandlerNumeric</span></code></a></td>
<td><a class="reference internal" href="#_CPPv331ImebraReadingDataHandlerNumeric" title="ImebraReadingDataHandlerNumeric"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">ImebraReadingDataHandlerNumeric</span></code></a></td>
<td>Read data from a numeric tag</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#_CPPv3N6imebra18WritingDataHandlerE" title="imebra::WritingDataHandler"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">imebra::WritingDataHandler</span></code></a></td>
<td><a class="reference internal" href="#_CPPv324ImebraWritingDataHandler" title="ImebraWritingDataHandler"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">ImebraWritingDataHandler</span></code></a></td>
<td>Write into a tag</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#_CPPv3N6imebra25WritingDataHandlerNumericE" title="imebra::WritingDataHandlerNumeric"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">imebra::WritingDataHandlerNumeric</span></code></a></td>
<td><a class="reference internal" href="#_CPPv331ImebraWritingDataHandlerNumeric" title="ImebraWritingDataHandlerNumeric"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">ImebraWritingDataHandlerNumeric</span></code></a></td>
<td>Write into a numeric tag</td>
</tr>
</tbody>
</table>
<div class="figure" id="id20" style="width: 100%">
<a class="reference external image-reference" href="_images/data.jpg"><img alt="Data related classes" src="_images/data.jpg" /></a>
<p class="caption"><span class="caption-text">Class diagram of the data related classes</span></p>
</div>
<p><a class="reference internal" href="#dataset"><span class="std std-ref">DataSet</span></a> is a collection of <a class="reference internal" href="#tag"><span class="std std-ref">Tag</span></a> objects. Each <a class="reference internal" href="#tag"><span class="std std-ref">Tag</span></a> is identified by a <a class="reference internal" href="#tagid"><span class="std std-ref">TagId</span></a>.</p>
<p><a class="reference internal" href="#dataset"><span class="std std-ref">DataSet</span></a> supplies several functions that allow to easily read and write the value of the tags however, when advanced
functionalities are needed (e.g. when writing several items in one tag that accepts more than one value) then the classes
<a class="reference internal" href="#readingdatahandler"><span class="std std-ref">ReadingDataHandler</span></a>, <a class="reference internal" href="#readingdatahandlernumeric"><span class="std std-ref">ReadingDataHandlerNumeric</span></a>, <a class="reference internal" href="#writingdatahandler"><span class="std std-ref">WritingDataHandler</span></a> and <a class="reference internal" href="#writingdatahandlernumeric"><span class="std std-ref">WritingDataHandlerNumeric</span></a> should be used.</p>
<p>The difference between <a class="reference internal" href="#readingdatahandlernumeric"><span class="std std-ref">ReadingDataHandlerNumeric</span></a> and <a class="reference internal" href="#readingdatahandler"><span class="std std-ref">ReadingDataHandler</span></a> (and between <a class="reference internal" href="#writingdatahandlernumeric"><span class="std std-ref">WritingDataHandlerNumeric</span></a> and
<a class="reference internal" href="#writingdatahandler"><span class="std std-ref">WritingDataHandler</span></a>) is that the ‘XXXNumeric’ counterpart supplies functions to access the underlying memory buffer that stores
the data, allowing fast processing when dealing with images and large collections of data.</p>
</div>
<div class="section" id="data-storage">
<h2>Data storage<a class="headerlink" href="#data-storage" title="Permalink to this headline">¶</a></h2>
<div class="section" id="dataset">
<span id="id1"></span><h3>DataSet<a class="headerlink" href="#dataset" title="Permalink to this headline">¶</a></h3>
<div class="section" id="c">
<h4>C++<a class="headerlink" href="#c" title="Permalink to this headline">¶</a></h4>
<dl class="class">
<dt id="_CPPv3N6imebra7DataSetE">
<span id="_CPPv2N6imebra7DataSetE"></span><span id="imebra::DataSet"></span><span class="target" id="classimebra_1_1_data_set"></span><em class="property">class </em><code class="descname">DataSet</code><a class="headerlink" href="#_CPPv3N6imebra7DataSetE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>This class represents a DICOM dataset. </p>
<p>The information it contains is organized into groups and each group may contain several tags.</p>
<p>You can create a <a class="reference internal" href="#classimebra_1_1_data_set"><span class="std std-ref">DataSet</span></a> from a DICOM file by using the <a class="reference internal" href="stream_classes.html#classimebra_1_1_codec_factory_1ae1d2924aa682f5754215c27691791680"><span class="std std-ref">CodecFactory::load()</span></a> function:</p>
<p>In C++: <div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">using</span> <span class="n">namespace</span> <span class="n">imebra</span><span class="p">;</span>
<span class="n">std</span><span class="p">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">DataSet</span><span class="o">&gt;</span> <span class="n">pDataSet</span><span class="p">(</span><span class="n">CodecFactory</span><span class="p">::</span><span class="n">load</span><span class="p">(</span><span class="s2">&quot;/path/to/file));</span>
</pre></div>
</div>
</p>
<p>In Java: <div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">com</span><span class="o">.</span><span class="n">imebra</span><span class="o">.</span><span class="n">DataSet</span> <span class="n">dataSet</span> <span class="o">=</span> <span class="n">com</span><span class="o">.</span><span class="n">imebra</span><span class="o">.</span><span class="n">CodecFactory</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s2">&quot;/path/to/file&quot;</span><span class="p">);</span>
</pre></div>
</div>
</p>
<p>You can also create an empty <a class="reference internal" href="#classimebra_1_1_data_set"><span class="std std-ref">DataSet</span></a> that can be filled with data and images and then saved to a DICOM file via <a class="reference internal" href="stream_classes.html#classimebra_1_1_codec_factory_1ac7b5fa45cb5450133fff02b48f70261f"><span class="std std-ref">CodecFactory::save()</span></a>.</p>
<p>When creating an empty <a class="reference internal" href="#classimebra_1_1_data_set"><span class="std std-ref">DataSet</span></a> you should specify the proper transfer syntax in the <a class="reference internal" href="#classimebra_1_1_data_set"><span class="std std-ref">DataSet</span></a> constructor.</p>
<p>To retrieve the <a class="reference internal" href="#classimebra_1_1_data_set"><span class="std std-ref">DataSet</span></a>’s content, use one of the following methods which give direct access to the tags’ values:<ul class="simple">
<li><a class="reference internal" href="#classimebra_1_1_data_set_1a80bd1c810cb4c4b27683e85bdcfe0f3d"><span class="std std-ref">getImage()</span></a></li>
<li><a class="reference internal" href="#classimebra_1_1_data_set_1a344d5f2383263f60dd9bfd7de99460ec"><span class="std std-ref">getImageApplyModalityTransform()</span></a></li>
<li><a class="reference internal" href="#classimebra_1_1_data_set_1ab1059031a7a494b4792502e63abb5e5f"><span class="std std-ref">getSequenceItem()</span></a></li>
<li><a class="reference internal" href="#classimebra_1_1_data_set_1a05e78490d7e4f082e077216be9edb545"><span class="std std-ref">getSignedLong()</span></a></li>
<li><a class="reference internal" href="#classimebra_1_1_data_set_1a08327af26d511bd6361bac3fd293f4ea"><span class="std std-ref">getUnsignedLong()</span></a></li>
<li><a class="reference internal" href="#classimebra_1_1_data_set_1a41e14df6227fbb29ad71a89e76e08b21"><span class="std std-ref">getDouble()</span></a></li>
<li><a class="reference internal" href="#classimebra_1_1_data_set_1a01f3d3c5e1420e9add546c93ea68c77f"><span class="std std-ref">getString()</span></a></li>
<li><a class="reference internal" href="#classimebra_1_1_data_set_1a47b0d0d7756c198da46b8de03306edcc"><span class="std std-ref">getUnicodeString()</span></a></li>
<li><a class="reference internal" href="#classimebra_1_1_data_set_1a9e9cb6315d22980e06931080cd951b43"><span class="std std-ref">getAge()</span></a></li>
<li><a class="reference internal" href="#classimebra_1_1_data_set_1ad6298de767d653d1634c7fadc70a771c"><span class="std std-ref">getDate()</span></a></li>
</ul>
</p>
<p>In alternative, you can first retrieve a <a class="reference internal" href="#classimebra_1_1_reading_data_handler"><span class="std std-ref">ReadingDataHandler</span></a> with <a class="reference internal" href="#classimebra_1_1_data_set_1a8ceaeb498e958fe4666a45418de018a7"><span class="std std-ref">getReadingDataHandler()</span></a> and then access the tag’s content via the handler.</p>
<p>To set the <a class="reference internal" href="#classimebra_1_1_data_set"><span class="std std-ref">DataSet</span></a>’s content, use one of the following methods:<ul class="simple">
<li><a class="reference internal" href="#classimebra_1_1_data_set_1ad9d0105847df32051b1169023a037043"><span class="std std-ref">setImage()</span></a></li>
<li><a class="reference internal" href="#classimebra_1_1_data_set_1a45f5df7848725cf5f8f2637837dcedba"><span class="std std-ref">setSequenceItem()</span></a></li>
<li><a class="reference internal" href="#classimebra_1_1_data_set_1af16189397f05dad52cd9bb1190d3c46b"><span class="std std-ref">setSignedLong()</span></a></li>
<li><a class="reference internal" href="#classimebra_1_1_data_set_1a1c8f47375e94122d57b909664fc8ea52"><span class="std std-ref">setUnsignedLong()</span></a></li>
<li><a class="reference internal" href="#classimebra_1_1_data_set_1a4abb446871ce42a2d6a70c26d4568f5a"><span class="std std-ref">setDouble()</span></a></li>
<li><a class="reference internal" href="#classimebra_1_1_data_set_1a9f951e32cb53be237c60f0208839b07b"><span class="std std-ref">setString()</span></a></li>
<li><a class="reference internal" href="#classimebra_1_1_data_set_1ad69e5d7c2e787d7f70ed9cafe6d9a155"><span class="std std-ref">setUnicodeString()</span></a></li>
<li><a class="reference internal" href="#classimebra_1_1_data_set_1a6865189c59dd1c51eda6ef9f2f872ed0"><span class="std std-ref">setAge()</span></a></li>
<li><a class="reference internal" href="#classimebra_1_1_data_set_1a46c15ececc48058b2cae043e24c19685"><span class="std std-ref">setDate()</span></a></li>
</ul>
</p>
<p>The previous methods allow to write just the first item in the tag’s content and before writing wipe out the old tag’s content (all the items). If you have to write more than one item in a tag, retrieve a <a class="reference internal" href="#classimebra_1_1_writing_data_handler"><span class="std std-ref">WritingDataHandler</span></a> with <a class="reference internal" href="#classimebra_1_1_data_set_1adb58aee90c373a1703f82d56ad5b1fa7"><span class="std std-ref">getWritingDataHandler()</span></a> and then modify all the tag’s items using the <a class="reference internal" href="#classimebra_1_1_writing_data_handler"><span class="std std-ref">WritingDataHandler</span></a>. </p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Functions</p>
<dl class="function">
<dt id="_CPPv3N6imebra7DataSet7DataSetEv">
<span id="_CPPv2N6imebra7DataSet7DataSetEv"></span><span id="imebra::DataSet::DataSet"></span><span class="target" id="classimebra_1_1_data_set_1a2fa78b96cb4f5c85d7412c90f4e62fc3"></span><code class="descname">DataSet</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N6imebra7DataSet7DataSetEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Construct an empty DICOM dataset with unspecified transfer syntax (which represents the default value “1.2.840.10008.1.2” or “Implicit VR little endian”) and charset “ISO 2022 IR 6”. </p>
<p>Use this method when creating a <a class="reference internal" href="#classimebra_1_1_data_set"><span class="std std-ref">DataSet</span></a> that will be embedded as a sequence item. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N6imebra7DataSet7DataSetERKNSt6stringE">
<span id="_CPPv2N6imebra7DataSet7DataSetERKNSt6stringE"></span><span id="imebra::DataSet::DataSet__ssCR"></span><span class="target" id="classimebra_1_1_data_set_1aed0bba4a8239062e7f242b08625ef6c5"></span><code class="descname">DataSet</code><span class="sig-paren">(</span><em class="property">const</em> std::string &amp;<em>transferSyntax</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N6imebra7DataSet7DataSetERKNSt6stringE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Construct an empty DICOM dataset with charset “ISO 2022 IR 6” and the desidered transfer syntax. </p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">transferSyntax</span></code>: the dataSet’s transfer syntax. The following transfer syntaxes are supported:<ul>
<li>”1.2.840.10008.1.2” (Implicit VR little endian)</li>
<li>”1.2.840.10008.1.2.1” (Explicit VR little endian)</li>
<li>”1.2.840.10008.1.2.2” (Explicit VR big endian)</li>
<li>”1.2.840.10008.1.2.5” (RLE compression)</li>
<li>”1.2.840.10008.1.2.4.50” (Jpeg baseline 8 bit lossy)</li>
<li>”1.2.840.10008.1.2.4.51” (Jpeg extended 12 bit lossy)</li>
<li>”1.2.840.10008.1.2.4.57” (Jpeg lossless NH)</li>
<li>”1.2.840.10008.1.2.4.70” (Jpeg lossless NH first order prediction) </li>
</ul>
</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N6imebra7DataSet7DataSetERKNSt6stringERK14charsetsList_t">
<span id="_CPPv2N6imebra7DataSet7DataSetERKNSt6stringERK14charsetsList_t"></span><span id="imebra::DataSet::DataSet__ssCR.charsetsList_tCR"></span><span class="target" id="classimebra_1_1_data_set_1ad36a91862215bfac1632bb5c0ecdb751"></span><code class="descname">DataSet</code><span class="sig-paren">(</span><em class="property">const</em> std::string &amp;<em>transferSyntax</em>, <em class="property">const</em> charsetsList_t &amp;<em>charsets</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N6imebra7DataSet7DataSetERKNSt6stringERK14charsetsList_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Construct an empty DICOM dataset and specifies the default charsets. </p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">transferSyntax</span></code>: the dataSet’s transfer syntax. The following transfer syntaxes are supported:<ul>
<li>”1.2.840.10008.1.2” (Implicit VR little endian)</li>
<li>”1.2.840.10008.1.2.1” (Explicit VR little endian)</li>
<li>”1.2.840.10008.1.2.2” (Explicit VR big endian)</li>
<li>”1.2.840.10008.1.2.5” (RLE compression)</li>
<li>”1.2.840.10008.1.2.4.50” (Jpeg baseline 8 bit lossy)</li>
<li>”1.2.840.10008.1.2.4.51” (Jpeg extended 12 bit lossy)</li>
<li>”1.2.840.10008.1.2.4.57” (Jpeg lossless NH)</li>
<li>”1.2.840.10008.1.2.4.70” (Jpeg lossless NH first order prediction)</li>
</ul>
</li>
<li><code class="docutils literal notranslate"><span class="pre">charsets</span></code>: a list of charsets supported by the <a class="reference internal" href="#classimebra_1_1_data_set"><span class="std std-ref">DataSet</span></a> </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N6imebra7DataSetD0Ev">
<span id="_CPPv2N6imebra7DataSetD0Ev"></span><span id="imebra::DataSet::~DataSet"></span><span class="target" id="classimebra_1_1_data_set_1af877f61f1949e7214d2c61bad9bc621b"></span><em class="property">virtual</em> <code class="descname">~DataSet</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N6imebra7DataSetD0Ev" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Destructor. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3NK6imebra7DataSet7getTagsEv">
<span id="_CPPv2NK6imebra7DataSet7getTagsEv"></span><span id="imebra::DataSet::getTagsC"></span><span class="target" id="classimebra_1_1_data_set_1a0e7279f51275fc17bbf39fe05d399f81"></span>tagsIds_t <code class="descname">getTags</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv3NK6imebra7DataSet7getTagsEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Returns a list of all the tags stored in the <a class="reference internal" href="#classimebra_1_1_data_set"><span class="std std-ref">DataSet</span></a>, ordered by group and tag ID. </p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>an ordered list of the stored Tags </dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3NK6imebra7DataSet6getTagERK5TagId">
<span id="_CPPv2NK6imebra7DataSet6getTagERK5TagId"></span><span id="imebra::DataSet::getTag__TagIdCRC"></span><span class="target" id="classimebra_1_1_data_set_1af931a855af2218b3d33a6013ea9dd860"></span><a class="reference internal" href="#_CPPv3N6imebra3TagE" title="imebra::Tag">Tag</a> *<code class="descname">getTag</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv3N6imebra5TagIdE" title="imebra::TagId">TagId</a> &amp;<em>tagId</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv3NK6imebra7DataSet6getTagERK5TagId" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Retrieve the <a class="reference internal" href="#classimebra_1_1_tag"><span class="std std-ref">Tag</span></a> with the specified ID. </p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>the <a class="reference internal" href="#classimebra_1_1_tag"><span class="std std-ref">Tag</span></a> with the specified ID </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">tagId</span></code>: the ID of the tag to retrieve </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N6imebra7DataSet12getTagCreateERK5TagId7tagVR_t">
<span id="_CPPv2N6imebra7DataSet12getTagCreateERK5TagId7tagVR_t"></span><span id="imebra::DataSet::getTagCreate__TagIdCR.tagVR_t"></span><span class="target" id="classimebra_1_1_data_set_1a60338e2116e443739c16b2d2f3d87eeb"></span><a class="reference internal" href="#_CPPv3N6imebra3TagE" title="imebra::Tag">Tag</a> *<code class="descname">getTagCreate</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv3N6imebra5TagIdE" title="imebra::TagId">TagId</a> &amp;<em>tagId</em>, <a class="reference internal" href="definition_classes.html#_CPPv3N6imebra7tagVR_tE" title="imebra::tagVR_t">tagVR_t</a> <em>tagVR</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N6imebra7DataSet12getTagCreateERK5TagId7tagVR_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Retrieve the <a class="reference internal" href="#classimebra_1_1_tag"><span class="std std-ref">Tag</span></a> with the specified ID or create it if it doesn’t exist. </p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>the <a class="reference internal" href="#classimebra_1_1_tag"><span class="std std-ref">Tag</span></a> with the specified ID </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">tagId</span></code>: the ID of the tag to retrieve </li>
<li><code class="docutils literal notranslate"><span class="pre">tagVR</span></code>: the VR to use for the new tag if one doesn’t exist already </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N6imebra7DataSet12getTagCreateERK5TagId">
<span id="_CPPv2N6imebra7DataSet12getTagCreateERK5TagId"></span><span id="imebra::DataSet::getTagCreate__TagIdCR"></span><span class="target" id="classimebra_1_1_data_set_1ab97ea8cc426a1f09305352c9a8f38ead"></span><a class="reference internal" href="#_CPPv3N6imebra3TagE" title="imebra::Tag">Tag</a> *<code class="descname">getTagCreate</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv3N6imebra5TagIdE" title="imebra::TagId">TagId</a> &amp;<em>tagId</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N6imebra7DataSet12getTagCreateERK5TagId" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Retrieve the <a class="reference internal" href="#classimebra_1_1_tag"><span class="std std-ref">Tag</span></a> with the specified ID or create it if it doesn’t exist. </p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>the <a class="reference internal" href="#classimebra_1_1_tag"><span class="std std-ref">Tag</span></a> with the specified ID </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">tagId</span></code>: the ID of the tag to retrieve </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N6imebra7DataSet8getImageE6size_t">
<span id="_CPPv2N6imebra7DataSet8getImageE6size_t"></span><span id="imebra::DataSet::getImage__s"></span><span class="target" id="classimebra_1_1_data_set_1a80bd1c810cb4c4b27683e85bdcfe0f3d"></span><a class="reference internal" href="imaging_classes.html#_CPPv3N6imebra5ImageE" title="imebra::Image">Image</a> *<code class="descname">getImage</code><span class="sig-paren">(</span>size_t <em>frameNumber</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N6imebra7DataSet8getImageE6size_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Retrieve an image from the dataset. </p>
<p>Images should be retrieved in order (first frame 0, then frame 1, then frame 2 and so on). Images can be retrieved also in random order but this introduces performance penalties.</p>
<p>Throws <a class="reference internal" href="exception_classes.html#classimebra_1_1_data_set_image_doesnt_exist_error"><span class="std std-ref">DataSetImageDoesntExistError</span></a> if the requested frame does not exist.</p>
<p><dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Images retrieved from the <a class="reference internal" href="#classimebra_1_1_data_set"><span class="std std-ref">DataSet</span></a> should be processed by the <a class="reference internal" href="transforms_classes.html#classimebra_1_1_modality_v_o_i_l_u_t"><span class="std std-ref">ModalityVOILUT</span></a> transform, which converts the modality-specific pixel values to values that the application can understand. Consider using <a class="reference internal" href="#classimebra_1_1_data_set_1a344d5f2383263f60dd9bfd7de99460ec"><span class="std std-ref">getImageApplyModalityTransform()</span></a> to retrieve the image already processed by <a class="reference internal" href="transforms_classes.html#classimebra_1_1_modality_v_o_i_l_u_t"><span class="std std-ref">ModalityVOILUT</span></a>.</dd>
<dt><strong>Return</strong></dt>
<dd>an <a class="reference internal" href="imaging_classes.html#classimebra_1_1_image"><span class="std std-ref">Image</span></a> object containing the decompressed image </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">frameNumber</span></code>: the frame to retrieve (the first frame is 0) </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N6imebra7DataSet30getImageApplyModalityTransformE6size_t">
<span id="_CPPv2N6imebra7DataSet30getImageApplyModalityTransformE6size_t"></span><span id="imebra::DataSet::getImageApplyModalityTransform__s"></span><span class="target" id="classimebra_1_1_data_set_1a344d5f2383263f60dd9bfd7de99460ec"></span><a class="reference internal" href="imaging_classes.html#_CPPv3N6imebra5ImageE" title="imebra::Image">Image</a> *<code class="descname">getImageApplyModalityTransform</code><span class="sig-paren">(</span>size_t <em>frameNumber</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N6imebra7DataSet30getImageApplyModalityTransformE6size_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Retrieve an image from the dataset and if necessary process it with <a class="reference internal" href="transforms_classes.html#classimebra_1_1_modality_v_o_i_l_u_t"><span class="std std-ref">ModalityVOILUT</span></a> before returning it. </p>
<p>Images should be retrieved in order (first frame 0, then frame 1, then frame 2 and so on). Images can be retrieved also in random order but this introduces performance penalties.</p>
<p>Throws <a class="reference internal" href="exception_classes.html#classimebra_1_1_data_set_image_doesnt_exist_error"><span class="std std-ref">DataSetImageDoesntExistError</span></a> if the requested frame does not exist.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>an image object containing the decompressed image processed with <a class="reference internal" href="transforms_classes.html#classimebra_1_1_modality_v_o_i_l_u_t"><span class="std std-ref">ModalityVOILUT</span></a> </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">frameNumber</span></code>: the frame to retrieve (the first frame is 0) </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N6imebra7DataSet8setImageE6size_tRK5Image14imageQuality_t">
<span id="_CPPv2N6imebra7DataSet8setImageE6size_tRK5Image14imageQuality_t"></span><span id="imebra::DataSet::setImage__s.ImageCR.imageQuality_t"></span><span class="target" id="classimebra_1_1_data_set_1ad9d0105847df32051b1169023a037043"></span>void <code class="descname">setImage</code><span class="sig-paren">(</span>size_t <em>frameNumber</em>, <em class="property">const</em> <a class="reference internal" href="imaging_classes.html#_CPPv3N6imebra5ImageE" title="imebra::Image">Image</a> &amp;<em>image</em>, <a class="reference internal" href="definition_classes.html#_CPPv3N6imebra14imageQuality_tE" title="imebra::imageQuality_t">imageQuality_t</a> <em>quality</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N6imebra7DataSet8setImageE6size_tRK5Image14imageQuality_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Insert an image into the dataset. </p>
<p>In multi-frame datasets the images must be inserted in order: first, insert the frame 0, then the frame 1, then the frame 2 and so on.</p>
<p>All the inserted images must have the same transfer syntax and the same properties (size, color space, high bit, bits allocated).</p>
<p>If the images are inserted in the wrong order then the <a class="reference internal" href="exception_classes.html#classimebra_1_1_data_set_wrong_frame_error"><span class="std std-ref">DataSetWrongFrameError</span></a> exception is thrown.</p>
<p>If the image being inserted has different properties than the ones of the images already in the dataset then the exception <a class="reference internal" href="exception_classes.html#classimebra_1_1_data_set_different_format_error"><span class="std std-ref">DataSetDifferentFormatError</span></a> is thrown.</p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">frameNumber</span></code>: the frame number (the first frame is 0) </li>
<li><code class="docutils literal notranslate"><span class="pre">image</span></code>: the image </li>
<li><code class="docutils literal notranslate"><span class="pre">quality</span></code>: the quality to use for lossy compression. Ignored if lossless compression is used </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N6imebra7DataSet7getVOIsEv">
<span id="_CPPv2N6imebra7DataSet7getVOIsEv"></span><span id="imebra::DataSet::getVOIs"></span><span class="target" id="classimebra_1_1_data_set_1a08881970f437016c630f8440abdda90a"></span><a class="reference internal" href="definition_classes.html#_CPPv3N6imebra6vois_tE" title="imebra::vois_t">vois_t</a> <code class="descname">getVOIs</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N6imebra7DataSet7getVOIsEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Return the list of VOI settings stored in the <a class="reference internal" href="#classimebra_1_1_data_set"><span class="std std-ref">DataSet</span></a>. </p>
<p>Each VOI setting includes the center &amp; width values that can be used with the <a class="reference internal" href="transforms_classes.html#classimebra_1_1_v_o_i_l_u_t"><span class="std std-ref">VOILUT</span></a> transform to highlight different parts of an <a class="reference internal" href="imaging_classes.html#classimebra_1_1_image"><span class="std std-ref">Image</span></a>.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>a list of <a class="reference internal" href="definition_classes.html#structimebra_1_1_v_o_i_description"><span class="std std-ref">VOIDescription</span></a> objects defined in the <a class="reference internal" href="#classimebra_1_1_data_set"><span class="std std-ref">DataSet</span></a> </dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N6imebra7DataSet15getSequenceItemERK5TagId6size_t">
<span id="_CPPv2N6imebra7DataSet15getSequenceItemERK5TagId6size_t"></span><span id="imebra::DataSet::getSequenceItem__TagIdCR.s"></span><span class="target" id="classimebra_1_1_data_set_1ab1059031a7a494b4792502e63abb5e5f"></span><a class="reference internal" href="#_CPPv3N6imebra7DataSetE" title="imebra::DataSet">DataSet</a> *<code class="descname">getSequenceItem</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv3N6imebra5TagIdE" title="imebra::TagId">TagId</a> &amp;<em>tagId</em>, size_t <em>itemId</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N6imebra7DataSet15getSequenceItemERK5TagId6size_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Retrieve a sequence item stored in a tag. </p>
<p>If the specified <a class="reference internal" href="#classimebra_1_1_tag"><span class="std std-ref">Tag</span></a> does not exist then throws <a class="reference internal" href="exception_classes.html#classimebra_1_1_missing_tag_error"><span class="std std-ref">MissingTagError</span></a> or <a class="reference internal" href="exception_classes.html#classimebra_1_1_missing_group_error"><span class="std std-ref">MissingGroupError</span></a>.</p>
<p>If the specified <a class="reference internal" href="#classimebra_1_1_tag"><span class="std std-ref">Tag</span></a> does not contain the specified sequence item then throws <a class="reference internal" href="exception_classes.html#classimebra_1_1_missing_item_error"><span class="std std-ref">MissingItemError</span></a>.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>the requested sequence item </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">tagId</span></code>: the tag’s id containing the sequence item </li>
<li><code class="docutils literal notranslate"><span class="pre">itemId</span></code>: the sequence item to retrieve. The first item has an Id = 0 </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N6imebra7DataSet15setSequenceItemERK5TagId6size_tRK7DataSet">
<span id="_CPPv2N6imebra7DataSet15setSequenceItemERK5TagId6size_tRK7DataSet"></span><span id="imebra::DataSet::setSequenceItem__TagIdCR.s.DataSetCR"></span><span class="target" id="classimebra_1_1_data_set_1a45f5df7848725cf5f8f2637837dcedba"></span>void <code class="descname">setSequenceItem</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv3N6imebra5TagIdE" title="imebra::TagId">TagId</a> &amp;<em>tagId</em>, size_t <em>itemId</em>, <em class="property">const</em> <a class="reference internal" href="#_CPPv3N6imebra7DataSetE" title="imebra::DataSet">DataSet</a> &amp;<em>item</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N6imebra7DataSet15setSequenceItemERK5TagId6size_tRK7DataSet" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Set a sequence item. </p>
<p>If the specified <a class="reference internal" href="#classimebra_1_1_tag"><span class="std std-ref">Tag</span></a> does not exist then creates a new one with VR tagVR_t::SQ.</p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">tagId</span></code>: the tag’s id in which the sequence must be stored </li>
<li><code class="docutils literal notranslate"><span class="pre">itemId</span></code>: the sequence item to set. The first item has an Id = 0 </li>
<li><code class="docutils literal notranslate"><span class="pre">item</span></code>: the <a class="reference internal" href="#classimebra_1_1_data_set"><span class="std std-ref">DataSet</span></a> to store as a sequence item </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N6imebra7DataSet6getLUTERK5TagId6size_t">
<span id="_CPPv2N6imebra7DataSet6getLUTERK5TagId6size_t"></span><span id="imebra::DataSet::getLUT__TagIdCR.s"></span><span class="target" id="classimebra_1_1_data_set_1af828670ac04a6cbcec76f084682455af"></span>LUT *<code class="descname">getLUT</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv3N6imebra5TagIdE" title="imebra::TagId">TagId</a> &amp;<em>tagId</em>, size_t <em>itemId</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N6imebra7DataSet6getLUTERK5TagId6size_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Retrieve a LUT stored in a sequence item. </p>
<p>If the specified <a class="reference internal" href="#classimebra_1_1_tag"><span class="std std-ref">Tag</span></a> does not exist then throws <a class="reference internal" href="exception_classes.html#classimebra_1_1_missing_tag_error"><span class="std std-ref">MissingTagError</span></a> or <a class="reference internal" href="exception_classes.html#classimebra_1_1_missing_group_error"><span class="std std-ref">MissingGroupError</span></a>.</p>
<p>If the specified <a class="reference internal" href="#classimebra_1_1_tag"><span class="std std-ref">Tag</span></a> does not contain the specified sequence item then throws <a class="reference internal" href="exception_classes.html#classimebra_1_1_missing_item_error"><span class="std std-ref">MissingItemError</span></a>.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>the LUT stored in the requested sequence item </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">tagId</span></code>: the tag’s id containing the sequence that stores the LUTs </li>
<li><code class="docutils literal notranslate"><span class="pre">itemId</span></code>: the sequence item to retrieve. The first item has an Id = 0 </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3NK6imebra7DataSet21getReadingDataHandlerERK5TagId6size_t">
<span id="_CPPv2NK6imebra7DataSet21getReadingDataHandlerERK5TagId6size_t"></span><span id="imebra::DataSet::getReadingDataHandler__TagIdCR.sC"></span><span class="target" id="classimebra_1_1_data_set_1a8ceaeb498e958fe4666a45418de018a7"></span><a class="reference internal" href="#_CPPv3N6imebra18ReadingDataHandlerE" title="imebra::ReadingDataHandler">ReadingDataHandler</a> *<code class="descname">getReadingDataHandler</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv3N6imebra5TagIdE" title="imebra::TagId">TagId</a> &amp;<em>tagId</em>, size_t <em>bufferId</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv3NK6imebra7DataSet21getReadingDataHandlerERK5TagId6size_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Retrieve a <a class="reference internal" href="#classimebra_1_1_reading_data_handler"><span class="std std-ref">ReadingDataHandler</span></a> object connected to a specific tag’s buffer. </p>
<p>If the specified <a class="reference internal" href="#classimebra_1_1_tag"><span class="std std-ref">Tag</span></a> does not exist then throws <a class="reference internal" href="exception_classes.html#classimebra_1_1_missing_tag_error"><span class="std std-ref">MissingTagError</span></a> or <a class="reference internal" href="exception_classes.html#classimebra_1_1_missing_group_error"><span class="std std-ref">MissingGroupError</span></a>.</p>
<p>If the specified <a class="reference internal" href="#classimebra_1_1_tag"><span class="std std-ref">Tag</span></a> does not contain the specified buffer item then throws <a class="reference internal" href="exception_classes.html#classimebra_1_1_missing_buffer_error"><span class="std std-ref">MissingBufferError</span></a>.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>a <a class="reference internal" href="#classimebra_1_1_reading_data_handler"><span class="std std-ref">ReadingDataHandler</span></a> object connected to the requested <a class="reference internal" href="#classimebra_1_1_tag"><span class="std std-ref">Tag</span></a>’s buffer </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">tagId</span></code>: the tag’s id containing the requested buffer </li>
<li><code class="docutils literal notranslate"><span class="pre">bufferId</span></code>: the buffer to connect to the <a class="reference internal" href="#classimebra_1_1_reading_data_handler"><span class="std std-ref">ReadingDataHandler</span></a> object. The first buffer has an Id = 0 </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N6imebra7DataSet21getWritingDataHandlerERK5TagId6size_t7tagVR_t">
<span id="_CPPv2N6imebra7DataSet21getWritingDataHandlerERK5TagId6size_t7tagVR_t"></span><span id="imebra::DataSet::getWritingDataHandler__TagIdCR.s.tagVR_t"></span><span class="target" id="classimebra_1_1_data_set_1adb58aee90c373a1703f82d56ad5b1fa7"></span><a class="reference internal" href="#_CPPv3N6imebra18WritingDataHandlerE" title="imebra::WritingDataHandler">WritingDataHandler</a> *<code class="descname">getWritingDataHandler</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv3N6imebra5TagIdE" title="imebra::TagId">TagId</a> &amp;<em>tagId</em>, size_t <em>bufferId</em>, <a class="reference internal" href="definition_classes.html#_CPPv3N6imebra7tagVR_tE" title="imebra::tagVR_t">tagVR_t</a> <em>tagVR</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N6imebra7DataSet21getWritingDataHandlerERK5TagId6size_t7tagVR_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Retrieve a <a class="reference internal" href="#classimebra_1_1_writing_data_handler"><span class="std std-ref">WritingDataHandler</span></a> object connected to a specific tag’s buffer. </p>
<p>If the specified <a class="reference internal" href="#classimebra_1_1_tag"><span class="std std-ref">Tag</span></a> does not exist then it creates a new tag with the VR specified in the tagVR parameter</p>
<p>The returned <a class="reference internal" href="#classimebra_1_1_writing_data_handler"><span class="std std-ref">WritingDataHandler</span></a> is connected to a new buffer which is updated and stored into the tag when <a class="reference internal" href="#classimebra_1_1_writing_data_handler"><span class="std std-ref">WritingDataHandler</span></a> is destroyed.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>a <a class="reference internal" href="#classimebra_1_1_writing_data_handler"><span class="std std-ref">WritingDataHandler</span></a> object connected to a new <a class="reference internal" href="#classimebra_1_1_tag"><span class="std std-ref">Tag</span></a>’s buffer </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">tagId</span></code>: the tag’s id containing the requested buffer </li>
<li><code class="docutils literal notranslate"><span class="pre">bufferId</span></code>: the position where the new buffer has to be stored in the tag. The first buffer position is 0 </li>
<li><code class="docutils literal notranslate"><span class="pre">tagVR</span></code>: the tag’s VR </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N6imebra7DataSet21getWritingDataHandlerERK5TagId6size_t">
<span id="_CPPv2N6imebra7DataSet21getWritingDataHandlerERK5TagId6size_t"></span><span id="imebra::DataSet::getWritingDataHandler__TagIdCR.s"></span><span class="target" id="classimebra_1_1_data_set_1a80b09a86210c671f15a020342c572058"></span><a class="reference internal" href="#_CPPv3N6imebra18WritingDataHandlerE" title="imebra::WritingDataHandler">WritingDataHandler</a> *<code class="descname">getWritingDataHandler</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv3N6imebra5TagIdE" title="imebra::TagId">TagId</a> &amp;<em>tagId</em>, size_t <em>bufferId</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N6imebra7DataSet21getWritingDataHandlerERK5TagId6size_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Retrieve a <a class="reference internal" href="#classimebra_1_1_writing_data_handler"><span class="std std-ref">WritingDataHandler</span></a> object connected to a specific tag’s buffer. </p>
<p>If the specified <a class="reference internal" href="#classimebra_1_1_tag"><span class="std std-ref">Tag</span></a> does not exist then it creates a new tag with a default VR retrieved from the <a class="reference internal" href="dicom_dictionary_classes.html#classimebra_1_1_dicom_dictionary"><span class="std std-ref">DicomDictionary</span></a>.</p>
<p>The returned <a class="reference internal" href="#classimebra_1_1_writing_data_handler"><span class="std std-ref">WritingDataHandler</span></a> is connected to a new buffer which is updated and stored into the tag when <a class="reference internal" href="#classimebra_1_1_writing_data_handler"><span class="std std-ref">WritingDataHandler</span></a> is destroyed.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>a <a class="reference internal" href="#classimebra_1_1_writing_data_handler"><span class="std std-ref">WritingDataHandler</span></a> object connected to a new <a class="reference internal" href="#classimebra_1_1_tag"><span class="std std-ref">Tag</span></a>’s buffer </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">tagId</span></code>: the tag’s id containing the requested buffer </li>
<li><code class="docutils literal notranslate"><span class="pre">bufferId</span></code>: the position where the new buffer has to be stored in the tag. The first buffer position is 0 </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3NK6imebra7DataSet28getReadingDataHandlerNumericERK5TagId6size_t">
<span id="_CPPv2NK6imebra7DataSet28getReadingDataHandlerNumericERK5TagId6size_t"></span><span id="imebra::DataSet::getReadingDataHandlerNumeric__TagIdCR.sC"></span><span class="target" id="classimebra_1_1_data_set_1a45ba0295f2468230442f05e446c99910"></span><a class="reference internal" href="#_CPPv3N6imebra25ReadingDataHandlerNumericE" title="imebra::ReadingDataHandlerNumeric">ReadingDataHandlerNumeric</a> *<code class="descname">getReadingDataHandlerNumeric</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv3N6imebra5TagIdE" title="imebra::TagId">TagId</a> &amp;<em>tagId</em>, size_t <em>bufferId</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv3NK6imebra7DataSet28getReadingDataHandlerNumericERK5TagId6size_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Retrieve a getReadingDataHandlerNumeric object connected to a specific tag’s numeric buffer. </p>
<p>If the tag’s VR is not a numeric type then throws std::bad_cast.</p>
<p>If the specified <a class="reference internal" href="#classimebra_1_1_tag"><span class="std std-ref">Tag</span></a> does not exist then throws <a class="reference internal" href="exception_classes.html#classimebra_1_1_missing_tag_error"><span class="std std-ref">MissingTagError</span></a> or <a class="reference internal" href="exception_classes.html#classimebra_1_1_missing_group_error"><span class="std std-ref">MissingGroupError</span></a>.</p>
<p>If the specified <a class="reference internal" href="#classimebra_1_1_tag"><span class="std std-ref">Tag</span></a> does not contain the specified buffer item then throws <a class="reference internal" href="exception_classes.html#classimebra_1_1_missing_item_error"><span class="std std-ref">MissingItemError</span></a>.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>a <a class="reference internal" href="#classimebra_1_1_reading_data_handler_numeric"><span class="std std-ref">ReadingDataHandlerNumeric</span></a> object connected to the requested <a class="reference internal" href="#classimebra_1_1_tag"><span class="std std-ref">Tag</span></a>’s buffer </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">tagId</span></code>: the tag’s id containing the requested buffer </li>
<li><code class="docutils literal notranslate"><span class="pre">bufferId</span></code>: the buffer to connect to the <a class="reference internal" href="#classimebra_1_1_reading_data_handler"><span class="std std-ref">ReadingDataHandler</span></a> object. The first buffer has an Id = 0 </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3NK6imebra7DataSet24getReadingDataHandlerRawERK5TagId6size_t">
<span id="_CPPv2NK6imebra7DataSet24getReadingDataHandlerRawERK5TagId6size_t"></span><span id="imebra::DataSet::getReadingDataHandlerRaw__TagIdCR.sC"></span><span class="target" id="classimebra_1_1_data_set_1a232222b135a57fe3befd8b610c75aecc"></span><a class="reference internal" href="#_CPPv3N6imebra25ReadingDataHandlerNumericE" title="imebra::ReadingDataHandlerNumeric">ReadingDataHandlerNumeric</a> *<code class="descname">getReadingDataHandlerRaw</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv3N6imebra5TagIdE" title="imebra::TagId">TagId</a> &amp;<em>tagId</em>, size_t <em>bufferId</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv3NK6imebra7DataSet24getReadingDataHandlerRawERK5TagId6size_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Retrieve a getReadingDataHandlerNumeric object connected to a specific tag’s buffer, no matter what the tag’s data type. </p>
<p>If the tag’s VR is not a numeric type then throws std::bad_cast.</p>
<p>If the specified <a class="reference internal" href="#classimebra_1_1_tag"><span class="std std-ref">Tag</span></a> does not exist then throws <a class="reference internal" href="exception_classes.html#classimebra_1_1_missing_tag_error"><span class="std std-ref">MissingTagError</span></a> or <a class="reference internal" href="exception_classes.html#classimebra_1_1_missing_group_error"><span class="std std-ref">MissingGroupError</span></a>.</p>
<p>If the specified <a class="reference internal" href="#classimebra_1_1_tag"><span class="std std-ref">Tag</span></a> does not contain the specified buffer item then throws <a class="reference internal" href="exception_classes.html#classimebra_1_1_missing_item_error"><span class="std std-ref">MissingItemError</span></a>.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>a <a class="reference internal" href="#classimebra_1_1_reading_data_handler_numeric"><span class="std std-ref">ReadingDataHandlerNumeric</span></a> object connected to the requested <a class="reference internal" href="#classimebra_1_1_tag"><span class="std std-ref">Tag</span></a>’s buffer </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">tagId</span></code>: the tag’s id containing the requested buffer </li>
<li><code class="docutils literal notranslate"><span class="pre">bufferId</span></code>: the buffer to connect to the <a class="reference internal" href="#classimebra_1_1_reading_data_handler"><span class="std std-ref">ReadingDataHandler</span></a> object. The first buffer has an Id = 0 </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N6imebra7DataSet28getWritingDataHandlerNumericERK5TagId6size_t7tagVR_t">
<span id="_CPPv2N6imebra7DataSet28getWritingDataHandlerNumericERK5TagId6size_t7tagVR_t"></span><span id="imebra::DataSet::getWritingDataHandlerNumeric__TagIdCR.s.tagVR_t"></span><span class="target" id="classimebra_1_1_data_set_1a233dcbcc42fe5e9be402ee0589df7c8b"></span><a class="reference internal" href="#_CPPv3N6imebra25WritingDataHandlerNumericE" title="imebra::WritingDataHandlerNumeric">WritingDataHandlerNumeric</a> *<code class="descname">getWritingDataHandlerNumeric</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv3N6imebra5TagIdE" title="imebra::TagId">TagId</a> &amp;<em>tagId</em>, size_t <em>bufferId</em>, <a class="reference internal" href="definition_classes.html#_CPPv3N6imebra7tagVR_tE" title="imebra::tagVR_t">tagVR_t</a> <em>tagVR</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N6imebra7DataSet28getWritingDataHandlerNumericERK5TagId6size_t7tagVR_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Retrieve a <a class="reference internal" href="#classimebra_1_1_writing_data_handler_numeric"><span class="std std-ref">WritingDataHandlerNumeric</span></a> object connected to a specific tag’s buffer. </p>
<p>If the tag’s VR is not a numeric type then throws std::bad_cast.</p>
<p>If the specified <a class="reference internal" href="#classimebra_1_1_tag"><span class="std std-ref">Tag</span></a> does not exist then it creates a new tag with the VR specified in the tagVR parameter</p>
<p>The returned <a class="reference internal" href="#classimebra_1_1_writing_data_handler_numeric"><span class="std std-ref">WritingDataHandlerNumeric</span></a> is connected to a new buffer which is updated and stored into the tag when <a class="reference internal" href="#classimebra_1_1_writing_data_handler_numeric"><span class="std std-ref">WritingDataHandlerNumeric</span></a> is destroyed.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>a <a class="reference internal" href="#classimebra_1_1_writing_data_handler_numeric"><span class="std std-ref">WritingDataHandlerNumeric</span></a> object connected to a new <a class="reference internal" href="#classimebra_1_1_tag"><span class="std std-ref">Tag</span></a>’s buffer </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">tagId</span></code>: the tag’s id containing the requested buffer </li>
<li><code class="docutils literal notranslate"><span class="pre">bufferId</span></code>: the position where the new buffer has to be stored in the tag. The first buffer position is 0 </li>
<li><code class="docutils literal notranslate"><span class="pre">tagVR</span></code>: the tag’s VR </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N6imebra7DataSet28getWritingDataHandlerNumericERK5TagId6size_t">
<span id="_CPPv2N6imebra7DataSet28getWritingDataHandlerNumericERK5TagId6size_t"></span><span id="imebra::DataSet::getWritingDataHandlerNumeric__TagIdCR.s"></span><span class="target" id="classimebra_1_1_data_set_1a990fef188bcaed35edc25ddd967f319e"></span><a class="reference internal" href="#_CPPv3N6imebra25WritingDataHandlerNumericE" title="imebra::WritingDataHandlerNumeric">WritingDataHandlerNumeric</a> *<code class="descname">getWritingDataHandlerNumeric</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv3N6imebra5TagIdE" title="imebra::TagId">TagId</a> &amp;<em>tagId</em>, size_t <em>bufferId</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N6imebra7DataSet28getWritingDataHandlerNumericERK5TagId6size_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Retrieve a <a class="reference internal" href="#classimebra_1_1_writing_data_handler_numeric"><span class="std std-ref">WritingDataHandlerNumeric</span></a> object connected to a specific tag’s buffer. </p>
<p>If the tag’s VR is not a numeric type then throws std::bad_cast.</p>
<p>If the specified <a class="reference internal" href="#classimebra_1_1_tag"><span class="std std-ref">Tag</span></a> does not exist then it creates a new tag with a default VR retrieved from the <a class="reference internal" href="dicom_dictionary_classes.html#classimebra_1_1_dicom_dictionary"><span class="std std-ref">DicomDictionary</span></a>.</p>
<p>The returned <a class="reference internal" href="#classimebra_1_1_writing_data_handler_numeric"><span class="std std-ref">WritingDataHandlerNumeric</span></a> is connected to a new buffer which is updated and stored into the tag when <a class="reference internal" href="#classimebra_1_1_writing_data_handler_numeric"><span class="std std-ref">WritingDataHandlerNumeric</span></a> is destroyed.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>a <a class="reference internal" href="#classimebra_1_1_writing_data_handler_numeric"><span class="std std-ref">WritingDataHandlerNumeric</span></a> object connected to a new <a class="reference internal" href="#classimebra_1_1_tag"><span class="std std-ref">Tag</span></a>’s buffer </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">tagId</span></code>: the tag’s id containing the requested buffer </li>
<li><code class="docutils literal notranslate"><span class="pre">bufferId</span></code>: the position where the new buffer has to be stored in the tag. The first buffer position is 0 </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N6imebra7DataSet24getWritingDataHandlerRawERK5TagId6size_t7tagVR_t">
<span id="_CPPv2N6imebra7DataSet24getWritingDataHandlerRawERK5TagId6size_t7tagVR_t"></span><span id="imebra::DataSet::getWritingDataHandlerRaw__TagIdCR.s.tagVR_t"></span><span class="target" id="classimebra_1_1_data_set_1a31bac69fb8cfe13ec79d2c3d2048818e"></span><a class="reference internal" href="#_CPPv3N6imebra25WritingDataHandlerNumericE" title="imebra::WritingDataHandlerNumeric">WritingDataHandlerNumeric</a> *<code class="descname">getWritingDataHandlerRaw</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv3N6imebra5TagIdE" title="imebra::TagId">TagId</a> &amp;<em>tagId</em>, size_t <em>bufferId</em>, <a class="reference internal" href="definition_classes.html#_CPPv3N6imebra7tagVR_tE" title="imebra::tagVR_t">tagVR_t</a> <em>tagVR</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N6imebra7DataSet24getWritingDataHandlerRawERK5TagId6size_t7tagVR_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Retrieve a <a class="reference internal" href="#classimebra_1_1_writing_data_handler_numeric"><span class="std std-ref">WritingDataHandlerNumeric</span></a> object connected to a specific tag’s buffer. The handler content is cast to bytes. </p>
<p>If the tag’s VR is not a numeric type then throws std::bad_cast.</p>
<p>If the specified <a class="reference internal" href="#classimebra_1_1_tag"><span class="std std-ref">Tag</span></a> does not exist then it creates a new tag with the VR specified in the tagVR parameter</p>
<p>The returned <a class="reference internal" href="#classimebra_1_1_writing_data_handler_numeric"><span class="std std-ref">WritingDataHandlerNumeric</span></a> is connected to a new buffer which is updated and stored into the tag when <a class="reference internal" href="#classimebra_1_1_writing_data_handler_numeric"><span class="std std-ref">WritingDataHandlerNumeric</span></a> is destroyed.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>a <a class="reference internal" href="#classimebra_1_1_writing_data_handler_numeric"><span class="std std-ref">WritingDataHandlerNumeric</span></a> object connected to a new <a class="reference internal" href="#classimebra_1_1_tag"><span class="std std-ref">Tag</span></a>’s buffer </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">tagId</span></code>: the tag’s id containing the requested buffer </li>
<li><code class="docutils literal notranslate"><span class="pre">bufferId</span></code>: the position where the new buffer has to be stored in the tag. The first buffer position is 0 </li>
<li><code class="docutils literal notranslate"><span class="pre">tagVR</span></code>: the tag’s VR </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N6imebra7DataSet24getWritingDataHandlerRawERK5TagId6size_t">
<span id="_CPPv2N6imebra7DataSet24getWritingDataHandlerRawERK5TagId6size_t"></span><span id="imebra::DataSet::getWritingDataHandlerRaw__TagIdCR.s"></span><span class="target" id="classimebra_1_1_data_set_1ad1beefeeeb2ee908c6e7748c2738ab20"></span><a class="reference internal" href="#_CPPv3N6imebra25WritingDataHandlerNumericE" title="imebra::WritingDataHandlerNumeric">WritingDataHandlerNumeric</a> *<code class="descname">getWritingDataHandlerRaw</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv3N6imebra5TagIdE" title="imebra::TagId">TagId</a> &amp;<em>tagId</em>, size_t <em>bufferId</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N6imebra7DataSet24getWritingDataHandlerRawERK5TagId6size_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Retrieve a <a class="reference internal" href="#classimebra_1_1_writing_data_handler_numeric"><span class="std std-ref">WritingDataHandlerNumeric</span></a> object connected to a specific tag’s buffer. The handler content is cast to bytes. </p>
<p>If the tag’s VR is not a numeric type then throws std::bad_cast.</p>
<p>If the specified <a class="reference internal" href="#classimebra_1_1_tag"><span class="std std-ref">Tag</span></a> does not exist then it creates a new tag with a default VR retrieved from the <a class="reference internal" href="dicom_dictionary_classes.html#classimebra_1_1_dicom_dictionary"><span class="std std-ref">DicomDictionary</span></a>.</p>
<p>The returned <a class="reference internal" href="#classimebra_1_1_writing_data_handler_numeric"><span class="std std-ref">WritingDataHandlerNumeric</span></a> is connected to a new buffer which is updated and stored into the tag when <a class="reference internal" href="#classimebra_1_1_writing_data_handler_numeric"><span class="std std-ref">WritingDataHandlerNumeric</span></a> is destroyed.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>a <a class="reference internal" href="#classimebra_1_1_writing_data_handler_numeric"><span class="std std-ref">WritingDataHandlerNumeric</span></a> object connected to a new <a class="reference internal" href="#classimebra_1_1_tag"><span class="std std-ref">Tag</span></a>’s buffer </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">tagId</span></code>: the tag’s id containing the requested buffer </li>
<li><code class="docutils literal notranslate"><span class="pre">bufferId</span></code>: the position where the new buffer has to be stored in the tag. The first buffer position is 0 </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N6imebra7DataSet12bufferExistsERK5TagId6size_t">
<span id="_CPPv2N6imebra7DataSet12bufferExistsERK5TagId6size_t"></span><span id="imebra::DataSet::bufferExists__TagIdCR.s"></span><span class="target" id="classimebra_1_1_data_set_1a4ea6782c072efd73048b3c9fd8f0a3fc"></span>bool <code class="descname">bufferExists</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv3N6imebra5TagIdE" title="imebra::TagId">TagId</a> &amp;<em>tagId</em>, size_t <em>bufferId</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N6imebra7DataSet12bufferExistsERK5TagId6size_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Check if the specified tag and tag’s buffer exist. </p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>true if the specified tag and tag’s buffer exist, false otherwise </dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3NK6imebra7DataSet13getSignedLongERK5TagId6size_t">
<span id="_CPPv2NK6imebra7DataSet13getSignedLongERK5TagId6size_t"></span><span id="imebra::DataSet::getSignedLong__TagIdCR.sC"></span><span class="target" id="classimebra_1_1_data_set_1a05e78490d7e4f082e077216be9edb545"></span>std::int32_t <code class="descname">getSignedLong</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv3N6imebra5TagIdE" title="imebra::TagId">TagId</a> &amp;<em>tagId</em>, size_t <em>elementNumber</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv3NK6imebra7DataSet13getSignedLongERK5TagId6size_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Retrieve a tag’s value as signed long integer (32 bit). </p>
<p>If the tag’s value cannot be converted to a signed long integer then throws <a class="reference internal" href="exception_classes.html#classimebra_1_1_data_handler_conversion_error"><span class="std std-ref">DataHandlerConversionError</span></a>.</p>
<p>If the specified <a class="reference internal" href="#classimebra_1_1_tag"><span class="std std-ref">Tag</span></a> does not exist then throws <a class="reference internal" href="exception_classes.html#classimebra_1_1_missing_tag_error"><span class="std std-ref">MissingTagError</span></a> or <a class="reference internal" href="exception_classes.html#classimebra_1_1_missing_group_error"><span class="std std-ref">MissingGroupError</span></a>.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>the tag’s value as a signed 32 bit integer </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">tagId</span></code>: the tag’s id </li>
<li><code class="docutils literal notranslate"><span class="pre">elementNumber</span></code>: the element number within the buffer </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3NK6imebra7DataSet13getSignedLongERK5TagId6size_tNSt7int32_tE">
<span id="_CPPv2NK6imebra7DataSet13getSignedLongERK5TagId6size_tNSt7int32_tE"></span><span id="imebra::DataSet::getSignedLong__TagIdCR.s.std::int32_tC"></span><span class="target" id="classimebra_1_1_data_set_1af21071de3e36ab3463279917e3c7157b"></span>std::int32_t <code class="descname">getSignedLong</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv3N6imebra5TagIdE" title="imebra::TagId">TagId</a> &amp;<em>tagId</em>, size_t <em>elementNumber</em>, std::int32_t <em>defaultValue</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv3NK6imebra7DataSet13getSignedLongERK5TagId6size_tNSt7int32_tE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Retrieve a tag’s value as signed long integer (32 bit). </p>
<p>If the tag’s value cannot be converted to a signed long integer then throws <a class="reference internal" href="exception_classes.html#classimebra_1_1_data_handler_conversion_error"><span class="std std-ref">DataHandlerConversionError</span></a>.</p>
<p>If the specified <a class="reference internal" href="#classimebra_1_1_tag"><span class="std std-ref">Tag</span></a> does not exist or it does not contain the specified buffer then returns the default value specified in the parameter.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>the tag’s value as a signed 32 bit integer, or defaultValue if the tag doesn’t exist </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">tagId</span></code>: the tag’s id </li>
<li><code class="docutils literal notranslate"><span class="pre">elementNumber</span></code>: the element number within the buffer </li>
<li><code class="docutils literal notranslate"><span class="pre">defaultValue</span></code>: the value to return if the tag doesn’t exist </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N6imebra7DataSet13setSignedLongERK5TagIdNSt7int32_tE7tagVR_t">
<span id="_CPPv2N6imebra7DataSet13setSignedLongERK5TagIdNSt7int32_tE7tagVR_t"></span><span id="imebra::DataSet::setSignedLong__TagIdCR.std::int32_t.tagVR_t"></span><span class="target" id="classimebra_1_1_data_set_1af16189397f05dad52cd9bb1190d3c46b"></span>void <code class="descname">setSignedLong</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv3N6imebra5TagIdE" title="imebra::TagId">TagId</a> &amp;<em>tagId</em>, std::int32_t <em>newValue</em>, <a class="reference internal" href="definition_classes.html#_CPPv3N6imebra7tagVR_tE" title="imebra::tagVR_t">tagVR_t</a> <em>tagVR</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N6imebra7DataSet13setSignedLongERK5TagIdNSt7int32_tE7tagVR_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Write a new signed 32 bit integer value into the element 0 of the specified <a class="reference internal" href="#classimebra_1_1_tag"><span class="std std-ref">Tag</span></a>’s buffer 0. </p>
<p>If the specified <a class="reference internal" href="#classimebra_1_1_tag"><span class="std std-ref">Tag</span></a> or buffer don’t exist then a new tag is created using the specified data type (VR).</p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">tagId</span></code>: the tag’s id </li>
<li><code class="docutils literal notranslate"><span class="pre">newValue</span></code>: the value to write into the tag </li>
<li><code class="docutils literal notranslate"><span class="pre">tagVR</span></code>: the tag’s type to use when a new tag is created. </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N6imebra7DataSet13setSignedLongERK5TagIdNSt7int32_tE">
<span id="_CPPv2N6imebra7DataSet13setSignedLongERK5TagIdNSt7int32_tE"></span><span id="imebra::DataSet::setSignedLong__TagIdCR.std::int32_t"></span><span class="target" id="classimebra_1_1_data_set_1ab417f8af9cb7f7802456b666f621fdbe"></span>void <code class="descname">setSignedLong</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv3N6imebra5TagIdE" title="imebra::TagId">TagId</a> &amp;<em>tagId</em>, std::int32_t <em>newValue</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N6imebra7DataSet13setSignedLongERK5TagIdNSt7int32_tE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Write a new signed 32 bit integer value into the element 0 of the specified <a class="reference internal" href="#classimebra_1_1_tag"><span class="std std-ref">Tag</span></a>’s buffer 0. </p>
<p>If the specified <a class="reference internal" href="#classimebra_1_1_tag"><span class="std std-ref">Tag</span></a> does not exist then it creates a new tag with a default VR retrieved from the <a class="reference internal" href="dicom_dictionary_classes.html#classimebra_1_1_dicom_dictionary"><span class="std std-ref">DicomDictionary</span></a>.</p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">tagId</span></code>: the tag’s id </li>
<li><code class="docutils literal notranslate"><span class="pre">newValue</span></code>: the value to write into the tag </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3NK6imebra7DataSet15getUnsignedLongERK5TagId6size_t">
<span id="_CPPv2NK6imebra7DataSet15getUnsignedLongERK5TagId6size_t"></span><span id="imebra::DataSet::getUnsignedLong__TagIdCR.sC"></span><span class="target" id="classimebra_1_1_data_set_1a08327af26d511bd6361bac3fd293f4ea"></span>std::uint32_t <code class="descname">getUnsignedLong</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv3N6imebra5TagIdE" title="imebra::TagId">TagId</a> &amp;<em>tagId</em>, size_t <em>elementNumber</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv3NK6imebra7DataSet15getUnsignedLongERK5TagId6size_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Retrieve a tag’s value as unsigned long integer (32 bit). </p>
<p>If the tag’s value cannot be converted to an unsigned long integer then throws <a class="reference internal" href="exception_classes.html#classimebra_1_1_data_handler_conversion_error"><span class="std std-ref">DataHandlerConversionError</span></a>.</p>
<p>If the specified <a class="reference internal" href="#classimebra_1_1_tag"><span class="std std-ref">Tag</span></a> does not exist then throws <a class="reference internal" href="exception_classes.html#classimebra_1_1_missing_tag_error"><span class="std std-ref">MissingTagError</span></a> or <a class="reference internal" href="exception_classes.html#classimebra_1_1_missing_group_error"><span class="std std-ref">MissingGroupError</span></a>.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>the tag’s value as an unsigned 32 bit integer </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">tagId</span></code>: the tag’s id </li>
<li><code class="docutils literal notranslate"><span class="pre">elementNumber</span></code>: the element number within the buffer </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3NK6imebra7DataSet15getUnsignedLongERK5TagId6size_tNSt8uint32_tE">
<span id="_CPPv2NK6imebra7DataSet15getUnsignedLongERK5TagId6size_tNSt8uint32_tE"></span><span id="imebra::DataSet::getUnsignedLong__TagIdCR.s.std::uint32_tC"></span><span class="target" id="classimebra_1_1_data_set_1a8ae06aa2b542d8b885c21bc90cdc5a82"></span>std::uint32_t <code class="descname">getUnsignedLong</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv3N6imebra5TagIdE" title="imebra::TagId">TagId</a> &amp;<em>tagId</em>, size_t <em>elementNumber</em>, std::uint32_t <em>defaultValue</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv3NK6imebra7DataSet15getUnsignedLongERK5TagId6size_tNSt8uint32_tE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Retrieve a tag’s value as unsigned long integer (32 bit). </p>
<p>If the tag’s value cannot be converted to an unsigned long integer then throws <a class="reference internal" href="exception_classes.html#classimebra_1_1_data_handler_conversion_error"><span class="std std-ref">DataHandlerConversionError</span></a>.</p>
<p>If the specified <a class="reference internal" href="#classimebra_1_1_tag"><span class="std std-ref">Tag</span></a> does not exist then returns the default value specified in the parameter.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>the tag’s value as an unsigned 32 bit integer, or defaultValue if the tag doesn’t exist </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">tagId</span></code>: the tag’s id </li>
<li><code class="docutils literal notranslate"><span class="pre">elementNumber</span></code>: the element number within the buffer </li>
<li><code class="docutils literal notranslate"><span class="pre">defaultValue</span></code>: the value to return if the tag doesn’t exist </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N6imebra7DataSet15setUnsignedLongERK5TagIdNSt8uint32_tE7tagVR_t">
<span id="_CPPv2N6imebra7DataSet15setUnsignedLongERK5TagIdNSt8uint32_tE7tagVR_t"></span><span id="imebra::DataSet::setUnsignedLong__TagIdCR.std::uint32_t.tagVR_t"></span><span class="target" id="classimebra_1_1_data_set_1a1c8f47375e94122d57b909664fc8ea52"></span>void <code class="descname">setUnsignedLong</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv3N6imebra5TagIdE" title="imebra::TagId">TagId</a> &amp;<em>tagId</em>, std::uint32_t <em>newValue</em>, <a class="reference internal" href="definition_classes.html#_CPPv3N6imebra7tagVR_tE" title="imebra::tagVR_t">tagVR_t</a> <em>tagVR</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N6imebra7DataSet15setUnsignedLongERK5TagIdNSt8uint32_tE7tagVR_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Write a new unsigned 32 bit integer value into the element 0 of the specified <a class="reference internal" href="#classimebra_1_1_tag"><span class="std std-ref">Tag</span></a>’s buffer 0. </p>
<p>If the specified <a class="reference internal" href="#classimebra_1_1_tag"><span class="std std-ref">Tag</span></a> doesn’t exist then a new tag is created using the specified data type (VR).</p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">tagId</span></code>: the tag’s id </li>
<li><code class="docutils literal notranslate"><span class="pre">newValue</span></code>: the value to write into the tag </li>
<li><code class="docutils literal notranslate"><span class="pre">tagVR</span></code>: the tag’s type to use when a new tag is created. </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N6imebra7DataSet15setUnsignedLongERK5TagIdNSt8uint32_tE">
<span id="_CPPv2N6imebra7DataSet15setUnsignedLongERK5TagIdNSt8uint32_tE"></span><span id="imebra::DataSet::setUnsignedLong__TagIdCR.std::uint32_t"></span><span class="target" id="classimebra_1_1_data_set_1a8c3e2fc0057bcd1bcdf66142a0f9516d"></span>void <code class="descname">setUnsignedLong</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv3N6imebra5TagIdE" title="imebra::TagId">TagId</a> &amp;<em>tagId</em>, std::uint32_t <em>newValue</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N6imebra7DataSet15setUnsignedLongERK5TagIdNSt8uint32_tE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Write a new unsigned 32 bit integer value into the element 0 of the specified <a class="reference internal" href="#classimebra_1_1_tag"><span class="std std-ref">Tag</span></a>’s buffer 0. </p>
<p>If the specified <a class="reference internal" href="#classimebra_1_1_tag"><span class="std std-ref">Tag</span></a> does not exist then it creates a new tag with a default VR retrieved from the <a class="reference internal" href="dicom_dictionary_classes.html#classimebra_1_1_dicom_dictionary"><span class="std std-ref">DicomDictionary</span></a>.</p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">tagId</span></code>: the tag’s id </li>
<li><code class="docutils literal notranslate"><span class="pre">newValue</span></code>: the value to write into the tag </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3NK6imebra7DataSet9getDoubleERK5TagId6size_t">
<span id="_CPPv2NK6imebra7DataSet9getDoubleERK5TagId6size_t"></span><span id="imebra::DataSet::getDouble__TagIdCR.sC"></span><span class="target" id="classimebra_1_1_data_set_1a41e14df6227fbb29ad71a89e76e08b21"></span>double <code class="descname">getDouble</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv3N6imebra5TagIdE" title="imebra::TagId">TagId</a> &amp;<em>tagId</em>, size_t <em>elementNumber</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv3NK6imebra7DataSet9getDoubleERK5TagId6size_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Retrieve a tag’s value as a 64 bit floating point. </p>
<p>If the tag’s value cannot be converted to a floating point value then throws <a class="reference internal" href="exception_classes.html#classimebra_1_1_data_handler_conversion_error"><span class="std std-ref">DataHandlerConversionError</span></a>.</p>
<p>If the specified <a class="reference internal" href="#classimebra_1_1_tag"><span class="std std-ref">Tag</span></a> does not exist then throws <a class="reference internal" href="exception_classes.html#classimebra_1_1_missing_tag_error"><span class="std std-ref">MissingTagError</span></a> or <a class="reference internal" href="exception_classes.html#classimebra_1_1_missing_group_error"><span class="std std-ref">MissingGroupError</span></a>.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>the tag’s value as a 64 bit floating point </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">tagId</span></code>: the tag’s id </li>
<li><code class="docutils literal notranslate"><span class="pre">elementNumber</span></code>: the element number within the buffer </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3NK6imebra7DataSet9getDoubleERK5TagId6size_td">
<span id="_CPPv2NK6imebra7DataSet9getDoubleERK5TagId6size_td"></span><span id="imebra::DataSet::getDouble__TagIdCR.s.doubleC"></span><span class="target" id="classimebra_1_1_data_set_1abf00b0bd859d15e027a80ebaba08528f"></span>double <code class="descname">getDouble</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv3N6imebra5TagIdE" title="imebra::TagId">TagId</a> &amp;<em>tagId</em>, size_t <em>elementNumber</em>, double <em>defaultValue</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv3NK6imebra7DataSet9getDoubleERK5TagId6size_td" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Retrieve a tag’s value as a 64 bit floating point. </p>
<p>If the tag’s value cannot be converted to a floating point value then throws <a class="reference internal" href="exception_classes.html#classimebra_1_1_data_handler_conversion_error"><span class="std std-ref">DataHandlerConversionError</span></a>.</p>
<p>If the specified <a class="reference internal" href="#classimebra_1_1_tag"><span class="std std-ref">Tag</span></a> does not exist then returns the default value specified in the parameter.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>the tag’s value as a 64 bit floating point, or defaultValue if the tag doesn’t exist </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">tagId</span></code>: the tag’s id </li>
<li><code class="docutils literal notranslate"><span class="pre">elementNumber</span></code>: the element number within the buffer </li>
<li><code class="docutils literal notranslate"><span class="pre">defaultValue</span></code>: the value to return if the tag doesn’t exist </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N6imebra7DataSet9setDoubleERK5TagIdd7tagVR_t">
<span id="_CPPv2N6imebra7DataSet9setDoubleERK5TagIdd7tagVR_t"></span><span id="imebra::DataSet::setDouble__TagIdCR.double.tagVR_t"></span><span class="target" id="classimebra_1_1_data_set_1a4abb446871ce42a2d6a70c26d4568f5a"></span>void <code class="descname">setDouble</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv3N6imebra5TagIdE" title="imebra::TagId">TagId</a> &amp;<em>tagId</em>, double <em>newValue</em>, <a class="reference internal" href="definition_classes.html#_CPPv3N6imebra7tagVR_tE" title="imebra::tagVR_t">tagVR_t</a> <em>tagVR</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N6imebra7DataSet9setDoubleERK5TagIdd7tagVR_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Write a 64 bit floating point value into the element 0 of the specified <a class="reference internal" href="#classimebra_1_1_tag"><span class="std std-ref">Tag</span></a>’s buffer 0. </p>
<p>If the specified <a class="reference internal" href="#classimebra_1_1_tag"><span class="std std-ref">Tag</span></a> or buffer don’t exist then a new tag is created using the specified data type (VR).</p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">tagId</span></code>: the tag’s id </li>
<li><code class="docutils literal notranslate"><span class="pre">newValue</span></code>: the value to write into the tag </li>
<li><code class="docutils literal notranslate"><span class="pre">tagVR</span></code>: the tag’s type to use when a new tag is created. </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N6imebra7DataSet9setDoubleERK5TagIdd">
<span id="_CPPv2N6imebra7DataSet9setDoubleERK5TagIdd"></span><span id="imebra::DataSet::setDouble__TagIdCR.double"></span><span class="target" id="classimebra_1_1_data_set_1a5e904c4c2ce83c4366ee1c53b634d0c1"></span>void <code class="descname">setDouble</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv3N6imebra5TagIdE" title="imebra::TagId">TagId</a> &amp;<em>tagId</em>, double <em>newValue</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N6imebra7DataSet9setDoubleERK5TagIdd" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Write a 64 bit floating point value into the element 0 of the specified <a class="reference internal" href="#classimebra_1_1_tag"><span class="std std-ref">Tag</span></a>’s buffer 0. </p>
<p>If the specified <a class="reference internal" href="#classimebra_1_1_tag"><span class="std std-ref">Tag</span></a> does not exist then it creates a new tag with a default VR retrieved from the <a class="reference internal" href="dicom_dictionary_classes.html#classimebra_1_1_dicom_dictionary"><span class="std std-ref">DicomDictionary</span></a>.</p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">tagId</span></code>: the tag’s id </li>
<li><code class="docutils literal notranslate"><span class="pre">newValue</span></code>: the value to write into the tag </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3NK6imebra7DataSet9getStringERK5TagId6size_t">
<span id="_CPPv2NK6imebra7DataSet9getStringERK5TagId6size_t"></span><span id="imebra::DataSet::getString__TagIdCR.sC"></span><span class="target" id="classimebra_1_1_data_set_1a01f3d3c5e1420e9add546c93ea68c77f"></span>std::string <code class="descname">getString</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv3N6imebra5TagIdE" title="imebra::TagId">TagId</a> &amp;<em>tagId</em>, size_t <em>elementNumber</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv3NK6imebra7DataSet9getStringERK5TagId6size_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Retrieve a tag’s value as a string. </p>
<p>If the tag’s value cannot be converted to a string then throws <a class="reference internal" href="exception_classes.html#classimebra_1_1_data_handler_conversion_error"><span class="std std-ref">DataHandlerConversionError</span></a>.</p>
<p>If the specified <a class="reference internal" href="#classimebra_1_1_tag"><span class="std std-ref">Tag</span></a> does not exist then throws <a class="reference internal" href="exception_classes.html#classimebra_1_1_missing_tag_error"><span class="std std-ref">MissingTagError</span></a> or <a class="reference internal" href="exception_classes.html#classimebra_1_1_missing_group_error"><span class="std std-ref">MissingGroupError</span></a>.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>the tag’s value as a string </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">tagId</span></code>: the tag’s id </li>
<li><code class="docutils literal notranslate"><span class="pre">elementNumber</span></code>: the element number within the buffer </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3NK6imebra7DataSet9getStringERK5TagId6size_tRKNSt6stringE">
<span id="_CPPv2NK6imebra7DataSet9getStringERK5TagId6size_tRKNSt6stringE"></span><span id="imebra::DataSet::getString__TagIdCR.s.ssCRC"></span><span class="target" id="classimebra_1_1_data_set_1ae57b791ceb14768b55b89c46fddb61f8"></span>std::string <code class="descname">getString</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv3N6imebra5TagIdE" title="imebra::TagId">TagId</a> &amp;<em>tagId</em>, size_t <em>elementNumber</em>, <em class="property">const</em> std::string &amp;<em>defaultValue</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv3NK6imebra7DataSet9getStringERK5TagId6size_tRKNSt6stringE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Retrieve a tag’s value as a string. </p>
<p>If the tag’s value cannot be converted to a string then throws <a class="reference internal" href="exception_classes.html#classimebra_1_1_data_handler_conversion_error"><span class="std std-ref">DataHandlerConversionError</span></a>.</p>
<p>If the specified <a class="reference internal" href="#classimebra_1_1_tag"><span class="std std-ref">Tag</span></a> does not exist then returns the default value specified in the parameter.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>the tag’s value as a string, or defaultValue if the tag doesn’t exist </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">tagId</span></code>: the tag’s id </li>
<li><code class="docutils literal notranslate"><span class="pre">elementNumber</span></code>: the element number within the buffer </li>
<li><code class="docutils literal notranslate"><span class="pre">defaultValue</span></code>: the value to return if the tag doesn’t exist </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N6imebra7DataSet9setStringERK5TagIdRKNSt6stringE7tagVR_t">
<span id="_CPPv2N6imebra7DataSet9setStringERK5TagIdRKNSt6stringE7tagVR_t"></span><span id="imebra::DataSet::setString__TagIdCR.ssCR.tagVR_t"></span><span class="target" id="classimebra_1_1_data_set_1a9f951e32cb53be237c60f0208839b07b"></span>void <code class="descname">setString</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv3N6imebra5TagIdE" title="imebra::TagId">TagId</a> &amp;<em>tagId</em>, <em class="property">const</em> std::string &amp;<em>newString</em>, <a class="reference internal" href="definition_classes.html#_CPPv3N6imebra7tagVR_tE" title="imebra::tagVR_t">tagVR_t</a> <em>tagVR</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N6imebra7DataSet9setStringERK5TagIdRKNSt6stringE7tagVR_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Write a string value into the element 0 of the specified <a class="reference internal" href="#classimebra_1_1_tag"><span class="std std-ref">Tag</span></a>’s buffer 0. </p>
<p>If the specified <a class="reference internal" href="#classimebra_1_1_tag"><span class="std std-ref">Tag</span></a> does not exist then it creates a new tag with a specific VR.</p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">tagId</span></code>: the tag’s id </li>
<li><code class="docutils literal notranslate"><span class="pre">newString</span></code>: the string to write into the tag </li>
<li><code class="docutils literal notranslate"><span class="pre">tagVR</span></code>: the tag’s type to use when a new tag is created. </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N6imebra7DataSet9setStringERK5TagIdRKNSt6stringE">
<span id="_CPPv2N6imebra7DataSet9setStringERK5TagIdRKNSt6stringE"></span><span id="imebra::DataSet::setString__TagIdCR.ssCR"></span><span class="target" id="classimebra_1_1_data_set_1ac1d2047d907db4dd6efc3953cc4fe7bc"></span>void <code class="descname">setString</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv3N6imebra5TagIdE" title="imebra::TagId">TagId</a> &amp;<em>tagId</em>, <em class="property">const</em> std::string &amp;<em>newString</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N6imebra7DataSet9setStringERK5TagIdRKNSt6stringE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Write a string value into the element 0 of the specified <a class="reference internal" href="#classimebra_1_1_tag"><span class="std std-ref">Tag</span></a>’s buffer 0. </p>
<p>If the specified <a class="reference internal" href="#classimebra_1_1_tag"><span class="std std-ref">Tag</span></a> does not exist then it creates a new tag with a default VR retrieved from the <a class="reference internal" href="dicom_dictionary_classes.html#classimebra_1_1_dicom_dictionary"><span class="std std-ref">DicomDictionary</span></a>.</p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">tagId</span></code>: the tag’s id </li>
<li><code class="docutils literal notranslate"><span class="pre">newString</span></code>: the string to write into the tag </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3NK6imebra7DataSet16getUnicodeStringERK5TagId6size_t">
<span id="_CPPv2NK6imebra7DataSet16getUnicodeStringERK5TagId6size_t"></span><span id="imebra::DataSet::getUnicodeString__TagIdCR.sC"></span><span class="target" id="classimebra_1_1_data_set_1a47b0d0d7756c198da46b8de03306edcc"></span>std::wstring <code class="descname">getUnicodeString</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv3N6imebra5TagIdE" title="imebra::TagId">TagId</a> &amp;<em>tagId</em>, size_t <em>elementNumber</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv3NK6imebra7DataSet16getUnicodeStringERK5TagId6size_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Retrieve a tag’s value as an Unicode string. </p>
<p>If the tag’s value cannot be converted to a Unicode string then throws <a class="reference internal" href="exception_classes.html#classimebra_1_1_data_handler_conversion_error"><span class="std std-ref">DataHandlerConversionError</span></a>.</p>
<p>If the specified <a class="reference internal" href="#classimebra_1_1_tag"><span class="std std-ref">Tag</span></a> does not exist then throws <a class="reference internal" href="exception_classes.html#classimebra_1_1_missing_tag_error"><span class="std std-ref">MissingTagError</span></a> or <a class="reference internal" href="exception_classes.html#classimebra_1_1_missing_group_error"><span class="std std-ref">MissingGroupError</span></a>.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>the tag’s value as an unicode string </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">tagId</span></code>: the tag’s id </li>
<li><code class="docutils literal notranslate"><span class="pre">elementNumber</span></code>: the element number within the buffer </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3NK6imebra7DataSet16getUnicodeStringERK5TagId6size_tRKNSt7wstringE">
<span id="_CPPv2NK6imebra7DataSet16getUnicodeStringERK5TagId6size_tRKNSt7wstringE"></span><span id="imebra::DataSet::getUnicodeString__TagIdCR.s.std::wstringCRC"></span><span class="target" id="classimebra_1_1_data_set_1af0c66d58feb51310a13fafb5476fb5e5"></span>std::wstring <code class="descname">getUnicodeString</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv3N6imebra5TagIdE" title="imebra::TagId">TagId</a> &amp;<em>tagId</em>, size_t <em>elementNumber</em>, <em class="property">const</em> std::wstring &amp;<em>defaultValue</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv3NK6imebra7DataSet16getUnicodeStringERK5TagId6size_tRKNSt7wstringE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Retrieve a tag’s value as an unicode string. </p>
<p>If the tag’s value cannot be converted to a Unicode string then throws <a class="reference internal" href="exception_classes.html#classimebra_1_1_data_handler_conversion_error"><span class="std std-ref">DataHandlerConversionError</span></a>.</p>
<p>If the specified <a class="reference internal" href="#classimebra_1_1_tag"><span class="std std-ref">Tag</span></a> does not exist then returns the default value specified in the parameter.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>the tag’s value as an unicode string, or defaultValue if the tag doesn’t exist </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">tagId</span></code>: the tag’s id </li>
<li><code class="docutils literal notranslate"><span class="pre">elementNumber</span></code>: the element number within the buffer </li>
<li><code class="docutils literal notranslate"><span class="pre">defaultValue</span></code>: the value to return if the tag doesn’t exist </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N6imebra7DataSet16setUnicodeStringERK5TagIdRKNSt7wstringE7tagVR_t">
<span id="_CPPv2N6imebra7DataSet16setUnicodeStringERK5TagIdRKNSt7wstringE7tagVR_t"></span><span id="imebra::DataSet::setUnicodeString__TagIdCR.std::wstringCR.tagVR_t"></span><span class="target" id="classimebra_1_1_data_set_1ad69e5d7c2e787d7f70ed9cafe6d9a155"></span>void <code class="descname">setUnicodeString</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv3N6imebra5TagIdE" title="imebra::TagId">TagId</a> &amp;<em>tagId</em>, <em class="property">const</em> std::wstring &amp;<em>newString</em>, <a class="reference internal" href="definition_classes.html#_CPPv3N6imebra7tagVR_tE" title="imebra::tagVR_t">tagVR_t</a> <em>tagVR</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N6imebra7DataSet16setUnicodeStringERK5TagIdRKNSt7wstringE7tagVR_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Write an unicode string value into the element 0 of the specified <a class="reference internal" href="#classimebra_1_1_tag"><span class="std std-ref">Tag</span></a>’s buffer 0. </p>
<p>If the specified <a class="reference internal" href="#classimebra_1_1_tag"><span class="std std-ref">Tag</span></a> doesn’t exist then a new tag is created using the specified VR.</p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">tagId</span></code>: the tag’s id </li>
<li><code class="docutils literal notranslate"><span class="pre">newString</span></code>: the string to write into the tag </li>
<li><code class="docutils literal notranslate"><span class="pre">tagVR</span></code>: the tag’s type to use when a new tag is created. </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N6imebra7DataSet16setUnicodeStringERK5TagIdRKNSt7wstringE">
<span id="_CPPv2N6imebra7DataSet16setUnicodeStringERK5TagIdRKNSt7wstringE"></span><span id="imebra::DataSet::setUnicodeString__TagIdCR.std::wstringCR"></span><span class="target" id="classimebra_1_1_data_set_1acc9f54e3589f383fff7b6cd4c7db7e86"></span>void <code class="descname">setUnicodeString</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv3N6imebra5TagIdE" title="imebra::TagId">TagId</a> &amp;<em>tagId</em>, <em class="property">const</em> std::wstring &amp;<em>newString</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N6imebra7DataSet16setUnicodeStringERK5TagIdRKNSt7wstringE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Write an unicode string value into the element 0 of the specified <a class="reference internal" href="#classimebra_1_1_tag"><span class="std std-ref">Tag</span></a>’s buffer 0. </p>
<p>If the specified <a class="reference internal" href="#classimebra_1_1_tag"><span class="std std-ref">Tag</span></a> does not exist then it creates a new tag with a default VR retrieved from the <a class="reference internal" href="dicom_dictionary_classes.html#classimebra_1_1_dicom_dictionary"><span class="std std-ref">DicomDictionary</span></a>.</p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">tagId</span></code>: the tag’s id </li>
<li><code class="docutils literal notranslate"><span class="pre">newString</span></code>: the string to write into the tag </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3NK6imebra7DataSet6getAgeERK5TagId6size_t">
<span id="_CPPv2NK6imebra7DataSet6getAgeERK5TagId6size_t"></span><span id="imebra::DataSet::getAge__TagIdCR.sC"></span><span class="target" id="classimebra_1_1_data_set_1a9e9cb6315d22980e06931080cd951b43"></span><a class="reference internal" href="definition_classes.html#_CPPv3N6imebra3AgeE" title="imebra::Age">Age</a> *<code class="descname">getAge</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv3N6imebra5TagIdE" title="imebra::TagId">TagId</a> &amp;<em>tagId</em>, size_t <em>elementNumber</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv3NK6imebra7DataSet6getAgeERK5TagId6size_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Retrieve a tag’s value as <a class="reference internal" href="definition_classes.html#structimebra_1_1_age"><span class="std std-ref">Age</span></a>. </p>
<p>If the tag’s value cannot be converted to <a class="reference internal" href="definition_classes.html#structimebra_1_1_age"><span class="std std-ref">Age</span></a> then throws <a class="reference internal" href="exception_classes.html#classimebra_1_1_data_handler_conversion_error"><span class="std std-ref">DataHandlerConversionError</span></a>.</p>
<p>If the specified <a class="reference internal" href="#classimebra_1_1_tag"><span class="std std-ref">Tag</span></a> does not exist then throws <a class="reference internal" href="exception_classes.html#classimebra_1_1_missing_tag_error"><span class="std std-ref">MissingTagError</span></a> or <a class="reference internal" href="exception_classes.html#classimebra_1_1_missing_group_error"><span class="std std-ref">MissingGroupError</span></a>.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>the tag’s value as <a class="reference internal" href="definition_classes.html#structimebra_1_1_age"><span class="std std-ref">Age</span></a> </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">tagId</span></code>: the tag’s id </li>
<li><code class="docutils literal notranslate"><span class="pre">elementNumber</span></code>: the element number within the buffer </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3NK6imebra7DataSet6getAgeERK5TagId6size_tRK3Age">
<span id="_CPPv2NK6imebra7DataSet6getAgeERK5TagId6size_tRK3Age"></span><span id="imebra::DataSet::getAge__TagIdCR.s.AgeCRC"></span><span class="target" id="classimebra_1_1_data_set_1a6c34dde5e7745b62dc5d3b67ccbfc7b6"></span><a class="reference internal" href="definition_classes.html#_CPPv3N6imebra3AgeE" title="imebra::Age">Age</a> *<code class="descname">getAge</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv3N6imebra5TagIdE" title="imebra::TagId">TagId</a> &amp;<em>tagId</em>, size_t <em>elementNumber</em>, <em class="property">const</em> <a class="reference internal" href="definition_classes.html#_CPPv3N6imebra3AgeE" title="imebra::Age">Age</a> &amp;<em>defaultValue</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv3NK6imebra7DataSet6getAgeERK5TagId6size_tRK3Age" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Retrieve a tag’s value as <a class="reference internal" href="definition_classes.html#structimebra_1_1_age"><span class="std std-ref">Age</span></a>. </p>
<p>If the tag’s value cannot be converted to <a class="reference internal" href="definition_classes.html#structimebra_1_1_age"><span class="std std-ref">Age</span></a> then throws <a class="reference internal" href="exception_classes.html#classimebra_1_1_data_handler_conversion_error"><span class="std std-ref">DataHandlerConversionError</span></a>.</p>
<p>If the specified <a class="reference internal" href="#classimebra_1_1_tag"><span class="std std-ref">Tag</span></a> does not exist then returns the default value specified in the parameter.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>the tag’s value as <a class="reference internal" href="definition_classes.html#structimebra_1_1_age"><span class="std std-ref">Age</span></a>, or defaultValue if the tag doesn’t exist </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">tagId</span></code>: the tag’s id </li>
<li><code class="docutils literal notranslate"><span class="pre">elementNumber</span></code>: the element number within the buffer 0 </li>
<li><code class="docutils literal notranslate"><span class="pre">defaultValue</span></code>: the value to return if the tag doesn’t exist </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N6imebra7DataSet6setAgeERK5TagIdRK3Age">
<span id="_CPPv2N6imebra7DataSet6setAgeERK5TagIdRK3Age"></span><span id="imebra::DataSet::setAge__TagIdCR.AgeCR"></span><span class="target" id="classimebra_1_1_data_set_1a6865189c59dd1c51eda6ef9f2f872ed0"></span>void <code class="descname">setAge</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv3N6imebra5TagIdE" title="imebra::TagId">TagId</a> &amp;<em>tagId</em>, <em class="property">const</em> <a class="reference internal" href="definition_classes.html#_CPPv3N6imebra3AgeE" title="imebra::Age">Age</a> &amp;<em>age</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N6imebra7DataSet6setAgeERK5TagIdRK3Age" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Write an <a class="reference internal" href="definition_classes.html#structimebra_1_1_age"><span class="std std-ref">Age</span></a> string into the element 0 of the specified <a class="reference internal" href="#classimebra_1_1_tag"><span class="std std-ref">Tag</span></a>’s buffer 0. </p>
<p>If the specified <a class="reference internal" href="#classimebra_1_1_tag"><span class="std std-ref">Tag</span></a> doesn’t exist then a new tag and is created using the VR tagVR_t::AS.</p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">tagId</span></code>: the tag’s id </li>
<li><code class="docutils literal notranslate"><span class="pre">age</span></code>: the <a class="reference internal" href="definition_classes.html#structimebra_1_1_age"><span class="std std-ref">Age</span></a> to write into the tag </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3NK6imebra7DataSet7getDateERK5TagId6size_t">
<span id="_CPPv2NK6imebra7DataSet7getDateERK5TagId6size_t"></span><span id="imebra::DataSet::getDate__TagIdCR.sC"></span><span class="target" id="classimebra_1_1_data_set_1ad6298de767d653d1634c7fadc70a771c"></span><a class="reference internal" href="definition_classes.html#_CPPv3N6imebra4DateE" title="imebra::Date">Date</a> *<code class="descname">getDate</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv3N6imebra5TagIdE" title="imebra::TagId">TagId</a> &amp;<em>tagId</em>, size_t <em>elementNumber</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv3NK6imebra7DataSet7getDateERK5TagId6size_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Retrieve a tag’s value as a <a class="reference internal" href="definition_classes.html#structimebra_1_1_date"><span class="std std-ref">Date</span></a>. </p>
<p>If the tag’s value cannot be converted to a <a class="reference internal" href="definition_classes.html#structimebra_1_1_date"><span class="std std-ref">Date</span></a> then throws <a class="reference internal" href="exception_classes.html#classimebra_1_1_data_handler_conversion_error"><span class="std std-ref">DataHandlerConversionError</span></a>.</p>
<p>If the specified <a class="reference internal" href="#classimebra_1_1_tag"><span class="std std-ref">Tag</span></a> does not exist then throws <a class="reference internal" href="exception_classes.html#classimebra_1_1_missing_tag_error"><span class="std std-ref">MissingTagError</span></a> or <a class="reference internal" href="exception_classes.html#classimebra_1_1_missing_group_error"><span class="std std-ref">MissingGroupError</span></a>.</p>
<p>If the specified <a class="reference internal" href="#classimebra_1_1_tag"><span class="std std-ref">Tag</span></a> does not exist then throws <a class="reference internal" href="exception_classes.html#classimebra_1_1_missing_item_error"><span class="std std-ref">MissingItemError</span></a>.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>the tag’s value as a <a class="reference internal" href="definition_classes.html#structimebra_1_1_date"><span class="std std-ref">Date</span></a> </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">tagId</span></code>: the tag’s id </li>
<li><code class="docutils literal notranslate"><span class="pre">elementNumber</span></code>: the element number within the buffer 0 </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3NK6imebra7DataSet7getDateERK5TagId6size_tRK4Date">
<span id="_CPPv2NK6imebra7DataSet7getDateERK5TagId6size_tRK4Date"></span><span id="imebra::DataSet::getDate__TagIdCR.s.DateCRC"></span><span class="target" id="classimebra_1_1_data_set_1a0f2ccd5e223e59f095bf0484759a714f"></span><a class="reference internal" href="definition_classes.html#_CPPv3N6imebra4DateE" title="imebra::Date">Date</a> *<code class="descname">getDate</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv3N6imebra5TagIdE" title="imebra::TagId">TagId</a> &amp;<em>tagId</em>, size_t <em>elementNumber</em>, <em class="property">const</em> <a class="reference internal" href="definition_classes.html#_CPPv3N6imebra4DateE" title="imebra::Date">Date</a> &amp;<em>defaultValue</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv3NK6imebra7DataSet7getDateERK5TagId6size_tRK4Date" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Retrieve a tag’s value as a <a class="reference internal" href="definition_classes.html#structimebra_1_1_date"><span class="std std-ref">Date</span></a>. </p>
<p>If the tag’s value cannot be converted to a date then throws <a class="reference internal" href="exception_classes.html#classimebra_1_1_data_handler_conversion_error"><span class="std std-ref">DataHandlerConversionError</span></a>.</p>
<p>If the specified <a class="reference internal" href="#classimebra_1_1_tag"><span class="std std-ref">Tag</span></a> does not exist then returns the default value specified in the parameter.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>the tag’s value as a <a class="reference internal" href="definition_classes.html#structimebra_1_1_date"><span class="std std-ref">Date</span></a>, or defaultValue if the tag doesn’t exist </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">tagId</span></code>: the tag’s id </li>
<li><code class="docutils literal notranslate"><span class="pre">elementNumber</span></code>: the element number within the buffer </li>
<li><code class="docutils literal notranslate"><span class="pre">defaultValue</span></code>: the value to return if the tag doesn’t exist </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N6imebra7DataSet7setDateERK5TagIdRK4Date7tagVR_t">
<span id="_CPPv2N6imebra7DataSet7setDateERK5TagIdRK4Date7tagVR_t"></span><span id="imebra::DataSet::setDate__TagIdCR.DateCR.tagVR_t"></span><span class="target" id="classimebra_1_1_data_set_1a46c15ececc48058b2cae043e24c19685"></span>void <code class="descname">setDate</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv3N6imebra5TagIdE" title="imebra::TagId">TagId</a> &amp;<em>tagId</em>, <em class="property">const</em> <a class="reference internal" href="definition_classes.html#_CPPv3N6imebra4DateE" title="imebra::Date">Date</a> &amp;<em>date</em>, <a class="reference internal" href="definition_classes.html#_CPPv3N6imebra7tagVR_tE" title="imebra::tagVR_t">tagVR_t</a> <em>tagVR</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N6imebra7DataSet7setDateERK5TagIdRK4Date7tagVR_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Write a <a class="reference internal" href="definition_classes.html#structimebra_1_1_date"><span class="std std-ref">Date</span></a> string into the element 0 of the specified <a class="reference internal" href="#classimebra_1_1_tag"><span class="std std-ref">Tag</span></a>’s buffer 0. </p>
<p>If the specified <a class="reference internal" href="#classimebra_1_1_tag"><span class="std std-ref">Tag</span></a> or buffer don’t exist then a new tag and/or buffer are created using the specified data type (VR).</p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">tagId</span></code>: the tag’s id </li>
<li><code class="docutils literal notranslate"><span class="pre">date</span></code>: the <a class="reference internal" href="definition_classes.html#structimebra_1_1_date"><span class="std std-ref">Date</span></a> to write into the tag </li>
<li><code class="docutils literal notranslate"><span class="pre">tagVR</span></code>: the tag’s type to use when a new tag is created. </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N6imebra7DataSet7setDateERK5TagIdRK4Date">
<span id="_CPPv2N6imebra7DataSet7setDateERK5TagIdRK4Date"></span><span id="imebra::DataSet::setDate__TagIdCR.DateCR"></span><span class="target" id="classimebra_1_1_data_set_1a42da4db86f32abaa81b241702009bd9f"></span>void <code class="descname">setDate</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv3N6imebra5TagIdE" title="imebra::TagId">TagId</a> &amp;<em>tagId</em>, <em class="property">const</em> <a class="reference internal" href="definition_classes.html#_CPPv3N6imebra4DateE" title="imebra::Date">Date</a> &amp;<em>date</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N6imebra7DataSet7setDateERK5TagIdRK4Date" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Write a <a class="reference internal" href="definition_classes.html#structimebra_1_1_date"><span class="std std-ref">Date</span></a> string into the element 0 of the specified <a class="reference internal" href="#classimebra_1_1_tag"><span class="std std-ref">Tag</span></a>’s buffer 0. </p>
<p>If the specified <a class="reference internal" href="#classimebra_1_1_tag"><span class="std std-ref">Tag</span></a> does not exist then it creates a new tag with a default VR retrieved from the <a class="reference internal" href="dicom_dictionary_classes.html#classimebra_1_1_dicom_dictionary"><span class="std std-ref">DicomDictionary</span></a>.</p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">tagId</span></code>: the tag’s id </li>
<li><code class="docutils literal notranslate"><span class="pre">date</span></code>: the <a class="reference internal" href="definition_classes.html#structimebra_1_1_date"><span class="std std-ref">Date</span></a> to write into the tag </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3NK6imebra7DataSet11getDataTypeERK5TagId">
<span id="_CPPv2NK6imebra7DataSet11getDataTypeERK5TagId"></span><span id="imebra::DataSet::getDataType__TagIdCRC"></span><span class="target" id="classimebra_1_1_data_set_1a02fd5b27065d9ae242ac6da50b4d5913"></span><a class="reference internal" href="definition_classes.html#_CPPv3N6imebra7tagVR_tE" title="imebra::tagVR_t">tagVR_t</a> <code class="descname">getDataType</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv3N6imebra5TagIdE" title="imebra::TagId">TagId</a> &amp;<em>tagId</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv3NK6imebra7DataSet11getDataTypeERK5TagId" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Return the 2 chars data type (VR) of the specified tag. </p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>the tag’s data type (VR) </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">tagId</span></code>: the id of the tag </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

</div>
</dd></dl>

</div>
<div class="section" id="objective-c-swift">
<h4>Objective-C/Swift<a class="headerlink" href="#objective-c-swift" title="Permalink to this headline">¶</a></h4>
<dl class="class">
<dt id="_CPPv313ImebraDataSet">
<span id="_CPPv213ImebraDataSet"></span><span id="ImebraDataSet"></span><span class="target" id="interface_imebra_data_set"></span><em class="property">class </em><code class="descname">ImebraDataSet</code> : <em class="property">public</em> NSObject<a class="headerlink" href="#_CPPv313ImebraDataSet" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>This class represents a DICOM dataset. </p>
<p>The information it contains is organized into groups and each group may contain several tags.</p>
<p>You can create a <a class="reference internal" href="#interface_imebra_data_set"><span class="std std-ref">ImebraDataSet</span></a> from a DICOM file by using the ImebraCodecFactory::load() function:</p>
<p><div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">NSError</span><span class="o">*</span> <span class="n">error</span> <span class="o">=</span> <span class="n">nil</span><span class="p">;</span>
<span class="n">ImebraDataSet</span><span class="o">*</span> <span class="n">pDataSet</span> <span class="o">=</span> <span class="p">[</span><span class="n">ImebraCodecFactory</span> <span class="n">load</span><span class="p">:</span><span class="o">@</span><span class="s2">&quot;dicomFile.dcm&quot;</span> <span class="n">error</span><span class="p">:</span><span class="o">&amp;</span><span class="n">error</span><span class="p">];</span>
</pre></div>
</div>
</p>
<p>You can also create an empty <a class="reference internal" href="#interface_imebra_data_set"><span class="std std-ref">ImebraDataSet</span></a> that can be filled with data and images and then saved to a DICOM file via ImebraCodecFactory::save().</p>
<p>When creating an empty <a class="reference internal" href="#interface_imebra_data_set"><span class="std std-ref">ImebraDataSet</span></a> you should specify the proper transfer syntax in the init method.</p>
<p>To retrieve the DataSet’s content, use one of the following methods which give direct access to the tags’ values:<ul class="simple">
<li>getImage()</li>
<li>getImageApplyModalityTransform()</li>
<li>getSequenceItem()</li>
<li>getSignedLong()</li>
<li>getUnsignedLong()</li>
<li>getDouble()</li>
<li>getString()</li>
<li>getUnicodeString()</li>
<li>getAge()</li>
<li>getDate()</li>
</ul>
</p>
<p>In alternative, you can first retrieve a <a class="reference internal" href="#interface_imebra_reading_data_handler"><span class="std std-ref">ImebraReadingDataHandler</span></a> with getReadingDataHandler() and then access the tag’s content via the handler.</p>
<p>To set the <a class="reference internal" href="#interface_imebra_data_set"><span class="std std-ref">ImebraDataSet</span></a>’s content, use one of the following methods:<ul class="simple">
<li>setImage()</li>
<li>setSequenceItem()</li>
<li>setSignedLong()</li>
<li>setUnsignedLong()</li>
<li>setDouble()</li>
<li>setString()</li>
<li>setUnicodeString()</li>
<li>setAge()</li>
<li>setDate()</li>
</ul>
</p>
<p>The previous methods allow to write just the first item in the tag’s content and before writing wipe out the old tag’s content (all the items). If you have to write more than one item in a tag, retrieve a <a class="reference internal" href="#interface_imebra_writing_data_handler"><span class="std std-ref">ImebraWritingDataHandler</span></a> with getWritingDataHandler() and then modify all the tag’s items using the <a class="reference internal" href="#interface_imebra_writing_data_handler"><span class="std std-ref">ImebraWritingDataHandler</span></a>. </p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Functions</p>
<dl class="function">
<dt id="_CPPv3N13ImebraDataSet4initEv">
<span id="_CPPv2N13ImebraDataSet4initEv"></span><span id="ImebraDataSet::init"></span><span class="target" id="interface_imebra_data_set_1a91b53b5cbeb84e87aa221f9495cbd185"></span>id <code class="descname">init</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N13ImebraDataSet4initEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Construct an empty DICOM dataset with unspecified transfer syntax (e.g. to be used in a sequence) charset “ISO 2022 IR 6”. </p>
<p>Use this method when creating a DataSet that will be embedded in a sequence item. </p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="interface_imebra_data_set_1a9b3b4e50c909082f8f06bf3a74805fec"></span><code class="descname">id ImebraDataSet::initWithTransferSyntax:(NSString * transferSyntax)</code></dt>
<dd><p>Construct an empty DICOM dataset with charset “ISO 2022 IR 6” and the desidered transfer syntax. </p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">transferSyntax</span></code>: the dataSet’s transfer syntax. The following transfer syntaxes are supported:<ul>
<li>”1.2.840.10008.1.2” (Implicit VR little endian)</li>
<li>”1.2.840.10008.1.2.1” (Explicit VR little endian)</li>
<li>”1.2.840.10008.1.2.2” (Explicit VR big endian)</li>
<li>”1.2.840.10008.1.2.5” (RLE compression)</li>
<li>”1.2.840.10008.1.2.4.50” (Jpeg baseline 8 bit lossy)</li>
<li>”1.2.840.10008.1.2.4.51” (Jpeg extended 12 bit lossy)</li>
<li>”1.2.840.10008.1.2.4.57” (Jpeg lossless NH)</li>
<li>”1.2.840.10008.1.2.4.70” (Jpeg lossless NH first order prediction) </li>
</ul>
</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="interface_imebra_data_set_1a821cdd2c2c23794e79486ff4d227e408"></span><code class="descname">id ImebraDataSet::initWithTransferSyntax:charsets:(NSString * transferSyntax, NSArray * pCharsets)</code></dt>
<dd><p>Construct an empty DICOM dataset and specifies the default charsets. </p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">transferSyntax</span></code>: the dataSet’s transfer syntax. The following transfer syntaxes are supported:<ul>
<li>”1.2.840.10008.1.2” (Implicit VR little endian)</li>
<li>”1.2.840.10008.1.2.1” (Explicit VR little endian)</li>
<li>”1.2.840.10008.1.2.2” (Explicit VR big endian)</li>
<li>”1.2.840.10008.1.2.5” (RLE compression)</li>
<li>”1.2.840.10008.1.2.4.50” (Jpeg baseline 8 bit lossy)</li>
<li>”1.2.840.10008.1.2.4.51” (Jpeg extended 12 bit lossy)</li>
<li>”1.2.840.10008.1.2.4.57” (Jpeg lossless NH)</li>
<li>”1.2.840.10008.1.2.4.70” (Jpeg lossless NH first order prediction)</li>
</ul>
</li>
<li><code class="docutils literal notranslate"><span class="pre">pCharsets</span></code>: a NSArray of NSString specifying the charsets supported by the DataSet </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N13ImebraDataSet7getTagsEv">
<span id="_CPPv2N13ImebraDataSet7getTagsEv"></span><span id="ImebraDataSet::getTags"></span><span class="target" id="interface_imebra_data_set_1a9a3a21702b61bae5306c6d3abf95b589"></span>NSArray *<code class="descname">getTags</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N13ImebraDataSet7getTagsEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Returns a list of all the tags stored in the DataSet, ordered by group and tag ID. </p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>an NSArray containing an ordered list of <a class="reference internal" href="#interface_imebra_tag_id"><span class="std std-ref">ImebraTagId</span></a> objects </dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="interface_imebra_data_set_1a16f5da5d77919be76aa4e1c7525785ae"></span><code class="descname">ImebraTag* ImebraDataSet::getTag:error:(ImebraTagId  * tagId, NSError ** pError)</code></dt>
<dd><p>Retrieve the Tag with the specified ID. </p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>the Tag with the specified ID </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">tagId</span></code>: the ID of the tag to retrieve </li>
<li><code class="docutils literal notranslate"><span class="pre">pError</span></code>: set if an error occurs </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="interface_imebra_data_set_1a4932493fd2a610b4e6cc6ce67fabd480"></span><code class="descname">ImebraTag* ImebraDataSet::getTagCreate:tagVR:error:(ImebraTagId  * tagId, ImebraTagVR_t tagVR, NSError ** pError)</code></dt>
<dd><p>Retrieve the <a class="reference internal" href="#interface_imebra_tag"><span class="std std-ref">ImebraTag</span></a> with the specified ID or create it if it doesn’t exist. </p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>the Tag with the specified ID </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">tagId</span></code>: the ID of the tag to retrieve </li>
<li><code class="docutils literal notranslate"><span class="pre">tagVR</span></code>: the VR to use for the new tag if one doesn’t exist already </li>
<li><code class="docutils literal notranslate"><span class="pre">pError</span></code>: set if an error occurs </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="interface_imebra_data_set_1a36d603d17211892cb3187439f984871c"></span><code class="descname">ImebraTag* ImebraDataSet::getTagCreate:error:(ImebraTagId  * tagId, NSError ** pError)</code></dt>
<dd><p>Retrieve the <a class="reference internal" href="#interface_imebra_tag"><span class="std std-ref">ImebraTag</span></a> with the specified ID or create it if it doesn’t exist. Set the proper VR according to the tag ID. </p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>the Tag with the specified ID </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">tagId</span></code>: the ID of the tag to retrieve </li>
<li><code class="docutils literal notranslate"><span class="pre">pError</span></code>: set if an error occurs </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="interface_imebra_data_set_1a654c7008d0044408556af9c6858067ad"></span><code class="descname">ImebraImage* ImebraDataSet::getImage:error:(unsigned int frameNumber, NSError ** pError)</code></dt>
<dd><p>Retrieve an image from the dataset. </p>
<p>Images should be retrieved in order (first frame 0, then frame 1, then frame 2 and so on). Images can be retrieved also in random order but this introduces performance penalties.</p>
<p>Set pError and returns nil if the requested image does not exist.</p>
<p><dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Images retrieved from the <a class="reference internal" href="#interface_imebra_data_set"><span class="std std-ref">ImebraDataSet</span></a> should be processed by the <a class="reference internal" href="transforms_classes.html#interface_imebra_modality_v_o_i_l_u_t"><span class="std std-ref">ImebraModalityVOILUT</span></a> transform, which converts the modality-specific pixel values to values that the application can understand. Consider using getImageApplyModalityTransform() to retrieve the image already processed by <a class="reference internal" href="transforms_classes.html#interface_imebra_modality_v_o_i_l_u_t"><span class="std std-ref">ImebraModalityVOILUT</span></a>.</dd>
<dt><strong>Return</strong></dt>
<dd>an <a class="reference internal" href="imaging_classes.html#interface_imebra_image"><span class="std std-ref">ImebraImage</span></a> object containing the decompressed image </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">frameNumber</span></code>: the frame to retrieve (the first frame is 0) </li>
<li><code class="docutils literal notranslate"><span class="pre">pError</span></code>: a pointer to a NSError pointer which is set when an error occurs </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="interface_imebra_data_set_1adf97a82136ed04c62592e21a270fc6ba"></span><code class="descname">ImebraImage* ImebraDataSet::getImageApplyModalityTransform:error:(unsigned int frameNumber, NSError ** pError)</code></dt>
<dd><p>Retrieve an image from the dataset and if necessary process it with <a class="reference internal" href="transforms_classes.html#interface_imebra_modality_v_o_i_l_u_t"><span class="std std-ref">ImebraModalityVOILUT</span></a> before returning it. </p>
<p>Images should be retrieved in order (first frame 0, then frame 1, then frame 2 and so on). Images can be retrieved also in random order but this introduces performance penalties.</p>
<p>Set pError and returns nil if the requested image does not exist.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>an <a class="reference internal" href="imaging_classes.html#interface_imebra_image"><span class="std std-ref">ImebraImage</span></a> object containing the decompressed image processed by <a class="reference internal" href="transforms_classes.html#interface_imebra_modality_v_o_i_l_u_t"><span class="std std-ref">ImebraModalityVOILUT</span></a> (if present) </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">frameNumber</span></code>: the frame to retrieve (the first frame is 0) </li>
<li><code class="docutils literal notranslate"><span class="pre">pError</span></code>: a pointer to a NSError pointer which is set when an error occurs </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="interface_imebra_data_set_1a715d7b3318850d1499c863b02eef22f6"></span><code class="descname">void ImebraDataSet::setImage:image:quality:error:(unsigned int frameNumber, ImebraImage  * image, ImebraImageQuality_t quality, (swift_error(nonnull_error)) __attribute__)</code></dt>
<dd><p>Insert an image into the dataset. </p>
<p>In multi-frame datasets the images must be inserted in order: first insert the frame 0, then the frame 1, then the frame 2 and so on.</p>
<p>All the inserted images must have the same transfer syntax and the same properties (size, color space, high bit, bits allocated).</p>
<p>If the images are inserted in the wrong order then the ImebraDataSetWrongFrameError is set in pError.</p>
<p>If the image being inserted has different properties than the ones of the images already in the dataset then the exception ImebraDataSetDifferentFormatError is set in pError.</p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">frameNumber</span></code>: the frame number (the first frame is 0) </li>
<li><code class="docutils literal notranslate"><span class="pre">image</span></code>: the image </li>
<li><code class="docutils literal notranslate"><span class="pre">quality</span></code>: the quality to use for lossy compression. Ignored if lossless compression is used </li>
<li><code class="docutils literal notranslate"><span class="pre">pError</span></code>: a pointer to a NSError pointer which is set when an error occurs </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="interface_imebra_data_set_1a16eae46106397c872124c48efcebfb91"></span><code class="descname">NSArray* ImebraDataSet::getVOIs:(NSError ** pError)</code></dt>
<dd><p>Return the list of VOI settings stored in the DataSet. </p>
<p>Each VOI setting includes the center &amp; width values that can be used with the VOILUT transform to highlight different parts of an Image.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>an NSArray containing a list of ImebraVOIDescription objects </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">pError</span></code>: a pointer to a NSError pointer which is set when an error occurs </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="interface_imebra_data_set_1ae3514fd259bb657b36cc7fd81d4aa868"></span><code class="descname">ImebraDataSet* ImebraDataSet::getSequenceItem:item:error:(ImebraTagId  * pTagId, unsigned int itemId, NSError ** pError)</code></dt>
<dd><p>Retrieve a sequence item stored in a tag. </p>
<p>If the specified tag does not exist then set pError to ImebraMissingTagError or ImebraMissingGroupError.</p>
<p>If the specified tag does not contain the specified sequence item then set pError to ImebraMissingItemError.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>the requested sequence item </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">pTagId</span></code>: the tag’s id containing the sequence item </li>
<li><code class="docutils literal notranslate"><span class="pre">itemId</span></code>: the sequence item to retrieve. The first item has an Id = 0 </li>
<li><code class="docutils literal notranslate"><span class="pre">pError</span></code>: a pointer to a NSError pointer which is set when an error occurs </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="interface_imebra_data_set_1a2d21beef44153b9301e307fe65d68260"></span><code class="descname">void ImebraDataSet::setSequenceItem:item:dataSet:error:(ImebraTagId  * pTagId, unsigned int itemId, ImebraDataSet  * pDataSet, (swift_error(nonnull_error)) __attribute__)</code></dt>
<dd><p>Set a sequence item. </p>
<p>If the specified tag does not exist then creates a new one with VR ImebraTagVR_t::SQ.</p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">pTagId</span></code>: the tag’s id in which the sequence must be stored </li>
<li><code class="docutils literal notranslate"><span class="pre">itemId</span></code>: the sequence item to set. The first item has an Id = 0 </li>
<li><code class="docutils literal notranslate"><span class="pre">item</span></code>: the DataSet to store as a sequence item </li>
<li><code class="docutils literal notranslate"><span class="pre">pError</span></code>: a pointer to a NSError pointer which is set when an error occurs </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="interface_imebra_data_set_1aed2e34889ae1be296c0da8e33ca12f92"></span><code class="descname">ImebraLUT* ImebraDataSet::getLUT:item:error:(ImebraTagId  * pTagId, unsigned int itemId, NSError ** pError)</code></dt>
<dd><p>Retrieve a ImebraLUT stored in a sequence item. </p>
<p>If the specified tag does not exist then set pError to ImebraMissingTagError or ImebraMissingGroupError.</p>
<p>If the specified tag does not contain the specified sequence item then set pError to ImebraMissingItemError.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>the LUT stored in the requested sequence item </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">pTagId</span></code>: the tag’s id containing the sequence that stores the LUTs </li>
<li><code class="docutils literal notranslate"><span class="pre">itemId</span></code>: the sequence item to retrieve. The first item has an Id = 0 </li>
<li><code class="docutils literal notranslate"><span class="pre">pError</span></code>: a pointer to a NSError pointer which is set when an error occurs </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="interface_imebra_data_set_1adad8d9f3466bca2800ee95d25c16c0a6"></span><code class="descname">ImebraReadingDataHandler* ImebraDataSet::getReadingDataHandler:bufferId:error:(ImebraTagId  * tagId, unsigned int bufferId, NSError ** pError)</code></dt>
<dd><p>Retrieve an <a class="reference internal" href="#interface_imebra_reading_data_handler"><span class="std std-ref">ImebraReadingDataHandler</span></a> object connected to a specific tag’s buffer. </p>
<p>If the specified tag does not exist then sets pError to ImebraMissingTagError or ImebraMissingGroupError.</p>
<p>If the specified tag does not contain the specified buffer item then sets pError to ImebraMissingBufferError.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>an <a class="reference internal" href="#interface_imebra_reading_data_handler"><span class="std std-ref">ImebraReadingDataHandler</span></a> object connected to the requested tag’s buffer </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">tagId</span></code>: the tag’s id containing the requested buffer </li>
<li><code class="docutils literal notranslate"><span class="pre">bufferId</span></code>: the buffer to connect to the ReadingDataHandler object. The first buffer has an Id = 0 </li>
<li><code class="docutils literal notranslate"><span class="pre">pError</span></code>: a pointer to a NSError pointer which is set when an error occurs </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="interface_imebra_data_set_1a96354cadfd5daf7e8042a007ba1fcdf4"></span><code class="descname">ImebraWritingDataHandler* ImebraDataSet::getWritingDataHandler:bufferId:tagVR:error:(ImebraTagId  * tagId, unsigned int bufferId, ImebraTagVR_t tagVR, NSError ** pError)</code></dt>
<dd><p>Retrieve an <a class="reference internal" href="#interface_imebra_writing_data_handler"><span class="std std-ref">ImebraWritingDataHandler</span></a> object connected to a specific tag’s buffer and sets its data type (VR). </p>
<p>If the specified tag does not exist then it creates a new tag with the VR specified in the tagVR parameter</p>
<p>The returned <a class="reference internal" href="#interface_imebra_writing_data_handler"><span class="std std-ref">ImebraWritingDataHandler</span></a> is connected to a new buffer which is updated and stored into the tag when the <a class="reference internal" href="#interface_imebra_writing_data_handler"><span class="std std-ref">ImebraWritingDataHandler</span></a> object is destroyed.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>a <a class="reference internal" href="#interface_imebra_writing_data_handler"><span class="std std-ref">ImebraWritingDataHandler</span></a> object connected to a new tag’s buffer </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">tagId</span></code>: the tag’s id containing the requested buffer </li>
<li><code class="docutils literal notranslate"><span class="pre">bufferId</span></code>: the position where the new buffer has to be stored in the tag. The first buffer position is 0 </li>
<li><code class="docutils literal notranslate"><span class="pre">tagVR</span></code>: the tag’s VR </li>
<li><code class="docutils literal notranslate"><span class="pre">pError</span></code>: a pointer to a NSError pointer which is set when an error occurs </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="interface_imebra_data_set_1a328c3c3dab7702da1a43b340a88ab368"></span><code class="descname">ImebraWritingDataHandler* ImebraDataSet::getWritingDataHandler:bufferId:error:(ImebraTagId  * tagId, unsigned int bufferId, NSError ** pError)</code></dt>
<dd><p>Retrieve a <a class="reference internal" href="#interface_imebra_writing_data_handler"><span class="std std-ref">ImebraWritingDataHandler</span></a> object connected to a specific tag’s buffer. </p>
<p>If the specified tag does not exist then it creates a new tag with a default VR retrieved from the <a class="reference internal" href="dicom_dictionary_classes.html#interface_imebra_dicom_dictionary"><span class="std std-ref">ImebraDicomDictionary</span></a>.</p>
<p>The returned <a class="reference internal" href="#interface_imebra_writing_data_handler"><span class="std std-ref">ImebraWritingDataHandler</span></a> is connected to a new buffer which is updated and stored into the tag when the <a class="reference internal" href="#interface_imebra_writing_data_handler"><span class="std std-ref">ImebraWritingDataHandler</span></a> object is destroyed.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>a <a class="reference internal" href="#interface_imebra_writing_data_handler"><span class="std std-ref">ImebraWritingDataHandler</span></a> object connected to a new tag’s buffer </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">tagId</span></code>: the tag’s id containing the requested buffer </li>
<li><code class="docutils literal notranslate"><span class="pre">bufferId</span></code>: the position where the new buffer has to be stored in the tag. The first buffer position is 0 </li>
<li><code class="docutils literal notranslate"><span class="pre">pError</span></code>: a pointer to a NSError pointer which is set when an error occurs </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="interface_imebra_data_set_1aa664e341b0362ef2794a4daa5e36ae02"></span><code class="descname">ImebraReadingDataHandlerNumeric* ImebraDataSet::getReadingDataHandlerNumeric:bufferId:error:(ImebraTagId  * tagId, unsigned int bufferId, NSError ** pError)</code></dt>
<dd><p>Retrieve a <a class="reference internal" href="#interface_imebra_reading_data_handler_numeric"><span class="std std-ref">ImebraReadingDataHandlerNumeric</span></a> object connected to a specific tag’s numeric buffer. </p>
<p>If the tag’s VR is not a numeric type then throws std::bad_cast.</p>
<p>If the specified tag does not exist then set pError to ImebraMissingTagError or ImebraMissingGroupError.</p>
<p>If the specified tag does not contain the specified buffer item then set pError to ImebraMissingItemError.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>a <a class="reference internal" href="#interface_imebra_reading_data_handler_numeric"><span class="std std-ref">ImebraReadingDataHandlerNumeric</span></a> object connected to the requested tag’s buffer </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">tagId</span></code>: the tag’s id containing the requested buffer </li>
<li><code class="docutils literal notranslate"><span class="pre">bufferId</span></code>: the buffer to connect to the ReadingDataHandler object. The first buffer has an Id = 0 </li>
<li><code class="docutils literal notranslate"><span class="pre">pError</span></code>: a pointer to a NSError pointer which is set when an error occurs </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="interface_imebra_data_set_1adf2512d1865aa9e654fc07573d4325bf"></span><code class="descname">ImebraReadingDataHandlerNumeric* ImebraDataSet::getReadingDataHandlerRaw:bufferId:error:(ImebraTagId  * tagId, unsigned int bufferId, NSError ** pError)</code></dt>
<dd><p>Retrieve a <a class="reference internal" href="#interface_imebra_reading_data_handler_numeric"><span class="std std-ref">ImebraReadingDataHandlerNumeric</span></a> object connected to a specific tag’s buffer, no matter what the tag’s data type. </p>
<p>If the specified tag does not exist then set pError to ImebraMissingTagError or ImebraMissingGroupError.</p>
<p>If the specified tag does not contain the specified buffer item then set pError to ImebraMissingItemError.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>a <a class="reference internal" href="#interface_imebra_reading_data_handler_numeric"><span class="std std-ref">ImebraReadingDataHandlerNumeric</span></a> object connected to the requested tag’s buffer </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">tagId</span></code>: the tag’s id containing the requested buffer </li>
<li><code class="docutils literal notranslate"><span class="pre">bufferId</span></code>: the buffer to connect to the ReadingDataHandler object. The first buffer has an Id = 0 </li>
<li><code class="docutils literal notranslate"><span class="pre">pError</span></code>: a pointer to a NSError pointer which is set when an error occurs </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="interface_imebra_data_set_1acc5015389cedd35b6ad269eef2116dbc"></span><code class="descname">ImebraWritingDataHandlerNumeric* ImebraDataSet::getWritingDataHandlerNumeric:bufferId:tagVR:error:(ImebraTagId  * tagId, unsigned long bufferId, ImebraTagVR_t tagVR, NSError ** pError)</code></dt>
<dd><p>Retrieve a <a class="reference internal" href="#interface_imebra_writing_data_handler_numeric"><span class="std std-ref">ImebraWritingDataHandlerNumeric</span></a> object connected to a specific tag’s buffer. </p>
<p>If the tag’s VR is not a numeric type then throws std::bad_cast.</p>
<p>If the specified tag does not exist then it creates a new tag with the VR specified in the tagVR parameter</p>
<p>The returned <a class="reference internal" href="#interface_imebra_writing_data_handler_numeric"><span class="std std-ref">ImebraWritingDataHandlerNumeric</span></a> is connected to a new buffer which is updated and stored into the tag when <a class="reference internal" href="#interface_imebra_writing_data_handler_numeric"><span class="std std-ref">ImebraWritingDataHandlerNumeric</span></a> is destroyed.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>a <a class="reference internal" href="#interface_imebra_writing_data_handler_numeric"><span class="std std-ref">ImebraWritingDataHandlerNumeric</span></a> object connected to a new tag’s buffer </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">tagId</span></code>: the tag’s id containing the requested buffer </li>
<li><code class="docutils literal notranslate"><span class="pre">bufferId</span></code>: the position where the new buffer has to be stored in the tag. The first buffer position is 0 </li>
<li><code class="docutils literal notranslate"><span class="pre">tagVR</span></code>: the tag’s VR </li>
<li><code class="docutils literal notranslate"><span class="pre">pError</span></code>: a pointer to a NSError pointer which is set when an error occurs </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="interface_imebra_data_set_1a0582b8b8cbb1bba0d3fd62f1fecbe5f5"></span><code class="descname">ImebraWritingDataHandlerNumeric* ImebraDataSet::getWritingDataHandlerNumeric:bufferId:error:(ImebraTagId  * tagId, unsigned long bufferId, NSError ** pError)</code></dt>
<dd><p>Retrieve a <a class="reference internal" href="#interface_imebra_writing_data_handler_numeric"><span class="std std-ref">ImebraWritingDataHandlerNumeric</span></a> object connected to a specific tag’s buffer. </p>
<p>If the tag’s VR is not a numeric type then throws std::bad_cast.</p>
<p>If the specified tag does not exist then it creates a new tag with a default VR retrieved from the <a class="reference internal" href="dicom_dictionary_classes.html#interface_imebra_dicom_dictionary"><span class="std std-ref">ImebraDicomDictionary</span></a>.</p>
<p>The returned <a class="reference internal" href="#interface_imebra_writing_data_handler_numeric"><span class="std std-ref">ImebraWritingDataHandlerNumeric</span></a> is connected to a new buffer which is updated and stored into the tag when <a class="reference internal" href="#interface_imebra_writing_data_handler_numeric"><span class="std std-ref">ImebraWritingDataHandlerNumeric</span></a> is destroyed.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>a <a class="reference internal" href="#interface_imebra_writing_data_handler_numeric"><span class="std std-ref">ImebraWritingDataHandlerNumeric</span></a> object connected to a new tag’s buffer </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">tagId</span></code>: the tag’s id containing the requested buffer </li>
<li><code class="docutils literal notranslate"><span class="pre">bufferId</span></code>: the position where the new buffer has to be stored in the tag. The first buffer position is 0 </li>
<li><code class="docutils literal notranslate"><span class="pre">pError</span></code>: a pointer to a NSError pointer which is set when an error occurs </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="interface_imebra_data_set_1a0fbc66687aa639666845721ecd23ffbd"></span><code class="descname">signed int ImebraDataSet::getSignedLong:elementNumber:error:(ImebraTagId  * tagId, unsigned int elementNumber, (swift_error(nonnull_error)) __attribute__)</code></dt>
<dd><p>Retrieve a tag’s value as signed long integer (32 bit). </p>
<p>If the tag’s value cannot be converted to a signed long integer then sets pError to ImebraDataHandlerConversionError.</p>
<p>If the specified tag does not exist then set pError to ImebraMissingTagError or ImebraMissingGroupError.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>the tag’s value as a signed 32 bit integer </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">tagId</span></code>: the tag’s id </li>
<li><code class="docutils literal notranslate"><span class="pre">elementNumber</span></code>: the element number within the buffer </li>
<li><code class="docutils literal notranslate"><span class="pre">pError</span></code>: a pointer to a NSError pointer which is set when an error occurs </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="interface_imebra_data_set_1afae02f35e37b63a184317279f9887731"></span><code class="descname">signed int ImebraDataSet::getSignedLong:elementNumber:defaultValue:error:(ImebraTagId  * tagId, unsigned int elementNumber, signed int defaultValue, (swift_error(nonnull_error)) __attribute__)</code></dt>
<dd><p>Retrieve a tag’s value as signed long integer (32 bit). </p>
<p>If the tag’s value cannot be converted to a signed long integer then sets pError to ImebraDataHandlerConversionError.</p>
<p>If the specified tag does not exist then returns the default value set in the defaultValue parameter.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>the tag’s value as a signed 32 bit integer </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">tagId</span></code>: the tag’s id </li>
<li><code class="docutils literal notranslate"><span class="pre">elementNumber</span></code>: the element number within the buffer </li>
<li><code class="docutils literal notranslate"><span class="pre">defaultValue</span></code>: the value to return if the tag doesn’t exist </li>
<li><code class="docutils literal notranslate"><span class="pre">pError</span></code>: a pointer to a NSError pointer which is set when an error occurs </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="interface_imebra_data_set_1a3d6da97e915a516953481774c74c2d0f"></span><code class="descname">void ImebraDataSet::setSignedLong:newValue:tagVR:error:(ImebraTagId  * tagId, signed int newValue, ImebraTagVR_t tagVR, (swift_error(nonnull_error)) __attribute__)</code></dt>
<dd><p>Write a new signed 32 bit integer value into the element 0 of the specified tag’s buffer 0. </p>
<p>If the specified tag doesn’t exist then a new tag is created using the specified data type (VR).</p>
<p>If the new value cannot be converted to the specified VR then sets pError to ImebraDataHandlerConversionError.</p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">tagId</span></code>: the tag’s id </li>
<li><code class="docutils literal notranslate"><span class="pre">newValue</span></code>: the value to write into the tag </li>
<li><code class="docutils literal notranslate"><span class="pre">tagVR</span></code>: the tag’s type to use when a new tag is created. </li>
<li><code class="docutils literal notranslate"><span class="pre">pError</span></code>: a pointer to a NSError pointer which is set when an error occurs </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="interface_imebra_data_set_1a1165377b3a9beca7cbcfd3c7af586ff4"></span><code class="descname">void ImebraDataSet::setSignedLong:newValue:error:(ImebraTagId  * tagId, signed int newValue, (swift_error(nonnull_error)) __attribute__)</code></dt>
<dd><p>Write a new signed 32 bit integer value into the element 0 of the specified tag’s buffer 0. </p>
<p>If the specified tag doesn’t exist then a new tag is created using the data type (VR) retrieved from the <a class="reference internal" href="dicom_dictionary_classes.html#interface_imebra_dicom_dictionary"><span class="std std-ref">ImebraDicomDictionary</span></a>.</p>
<p>If the new value cannot be converted to the VR returned by the <a class="reference internal" href="dicom_dictionary_classes.html#interface_imebra_dicom_dictionary"><span class="std std-ref">ImebraDicomDictionary</span></a> then sets pError to ImebraDataHandlerConversionError.</p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">tagId</span></code>: the tag’s id </li>
<li><code class="docutils literal notranslate"><span class="pre">newValue</span></code>: the value to write into the tag </li>
<li><code class="docutils literal notranslate"><span class="pre">pError</span></code>: a pointer to a NSError pointer which is set when an error occurs </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="interface_imebra_data_set_1aa4518f47f8f44f4258e58028585b5d76"></span><code class="descname">unsigned int ImebraDataSet::getUnsignedLong:elementNumber:error:(ImebraTagId  * tagId, unsigned int elementNumber, (swift_error(nonnull_error)) __attribute__)</code></dt>
<dd><p>Retrieve a tag’s value as unsigned long integer (32 bit). </p>
<p>If the tag’s value cannot be converted to an unsigned long integer then sets pError to ImebraDataHandlerConversionError.</p>
<p>If the specified tag does not exist then set pError to ImebraMissingTagError or ImebraMissingGroupError.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>the tag’s value as an unsigned 32 bit integer </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">tagId</span></code>: the tag’s id </li>
<li><code class="docutils literal notranslate"><span class="pre">elementNumber</span></code>: the element number within the buffer </li>
<li><code class="docutils literal notranslate"><span class="pre">pError</span></code>: a pointer to a NSError pointer which is set when an error occurs </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="interface_imebra_data_set_1a894a704b544fcfee06b40bf304b39357"></span><code class="descname">unsigned int ImebraDataSet::getUnsignedLong:elementNumber:defaultValue:error:(ImebraTagId  * tagId, unsigned int elementNumber, unsigned int defaultValue, (swift_error(nonnull_error)) __attribute__)</code></dt>
<dd><p>Retrieve a tag’s value as unsigned long integer (32 bit). </p>
<p>If the tag’s value cannot be converted to an unsigned long integer then sets pError to ImebraDataHandlerConversionError.</p>
<p>If the specified tag does not exist then returns the default value set in the defaultValue parameter.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>the tag’s value as an unsigned 32 bit integer </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">tagId</span></code>: the tag’s id </li>
<li><code class="docutils literal notranslate"><span class="pre">elementNumber</span></code>: the element number within the buffer </li>
<li><code class="docutils literal notranslate"><span class="pre">defaultValue</span></code>: the value to return if the tag doesn’t exist </li>
<li><code class="docutils literal notranslate"><span class="pre">pError</span></code>: a pointer to a NSError pointer which is set when an error occurs </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="interface_imebra_data_set_1aa95368d20f84f6899aff4361f0aca3c0"></span><code class="descname">void ImebraDataSet::setUnsignedLong:newValue:tagVR:error:(ImebraTagId  * tagId, unsigned int newValue, ImebraTagVR_t tagVR, (swift_error(nonnull_error)) __attribute__)</code></dt>
<dd><p>Write a new unsigned 32 bit integer value into the element 0 of the specified tag’s buffer 0. </p>
<p>If the specified tag doesn’t exist then a new tag is created using the specified data type (VR).</p>
<p>If the new value cannot be converted to the specified VR then sets pError to ImebraDataHandlerConversionError.</p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">tagId</span></code>: the tag’s id </li>
<li><code class="docutils literal notranslate"><span class="pre">newValue</span></code>: the value to write into the tag </li>
<li><code class="docutils literal notranslate"><span class="pre">tagVR</span></code>: the tag’s type to use when a new tag is created. </li>
<li><code class="docutils literal notranslate"><span class="pre">pError</span></code>: a pointer to a NSError pointer which is set when an error occurs </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="interface_imebra_data_set_1af287a1ac98f9fcfc64583c0f1826d079"></span><code class="descname">void ImebraDataSet::setUnsignedLong:newValue:error:(ImebraTagId  * tagId, unsigned int newValue, (swift_error(nonnull_error)) __attribute__)</code></dt>
<dd><p>Write a new unsigned 32 bit integer value into the element 0 of the specified tag’s buffer 0. </p>
<p>If the specified tag doesn’t exist then a new tag is created using the data type (VR) retrieved from the <a class="reference internal" href="dicom_dictionary_classes.html#interface_imebra_dicom_dictionary"><span class="std std-ref">ImebraDicomDictionary</span></a>.</p>
<p>If the new value cannot be converted to the VR returned by the <a class="reference internal" href="dicom_dictionary_classes.html#interface_imebra_dicom_dictionary"><span class="std std-ref">ImebraDicomDictionary</span></a> then sets pError to ImebraDataHandlerConversionError.</p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">tagId</span></code>: the tag’s id </li>
<li><code class="docutils literal notranslate"><span class="pre">newValue</span></code>: the value to write into the tag </li>
<li><code class="docutils literal notranslate"><span class="pre">pError</span></code>: a pointer to a NSError pointer which is set when an error occurs </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="interface_imebra_data_set_1a199e236396331a6102308b396ded6101"></span><code class="descname">double ImebraDataSet::getDouble:elementNumber:error:(ImebraTagId  * tagId, unsigned int elementNumber, (swift_error(nonnull_error)) __attribute__)</code></dt>
<dd><p>Retrieve a tag’s value as a double floating point. </p>
<p>If the tag’s value cannot be converted to double floating point then sets pError to ImebraDataHandlerConversionError.</p>
<p>If the specified tag does not exist then set pError to ImebraMissingTagError or ImebraMissingGroupError.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>the tag’s value as a double floating point </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">tagId</span></code>: the tag’s id </li>
<li><code class="docutils literal notranslate"><span class="pre">elementNumber</span></code>: the element number within the buffer </li>
<li><code class="docutils literal notranslate"><span class="pre">pError</span></code>: a pointer to a NSError pointer which is set when an error occurs </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="interface_imebra_data_set_1a809ee64a66b62b0dc56a18a8225a73dd"></span><code class="descname">double ImebraDataSet::getDouble:elementNumber:defaultValue:error:(ImebraTagId  * tagId, unsigned int elementNumber, double defaultValue, (swift_error(nonnull_error)) __attribute__)</code></dt>
<dd><p>Retrieve a tag’s value as a double floating point. </p>
<p>If the tag’s value cannot be converted to double floating point then sets pError to ImebraDataHandlerConversionError.</p>
<p>If the specified tag does not exist then returns the default value set in the defaultValue parameter.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>the tag’s value as a double floating point </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">tagId</span></code>: the tag’s id </li>
<li><code class="docutils literal notranslate"><span class="pre">elementNumber</span></code>: the element number within the buffer </li>
<li><code class="docutils literal notranslate"><span class="pre">defaultValue</span></code>: the value to return if the tag doesn’t exist </li>
<li><code class="docutils literal notranslate"><span class="pre">pError</span></code>: a pointer to a NSError pointer which is set when an error occurs </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="interface_imebra_data_set_1a90165bb4d828494b4c93351025214cb5"></span><code class="descname">void ImebraDataSet::setDouble:newValue:tagVR:error:(ImebraTagId  * tagId, double newValue, ImebraTagVR_t tagVR, (swift_error(nonnull_error)) __attribute__)</code></dt>
<dd><p>Write a new double floating point value into the element 0 of the specified tag’s buffer 0. </p>
<p>If the specified tag doesn’t exist then a new tag is created using the specified data type (VR).</p>
<p>If the new value cannot be converted to the specified VR then sets pError to ImebraDataHandlerConversionError.</p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">tagId</span></code>: the tag’s id </li>
<li><code class="docutils literal notranslate"><span class="pre">newValue</span></code>: the value to write into the tag </li>
<li><code class="docutils literal notranslate"><span class="pre">tagVR</span></code>: the tag’s type to use when a new tag is created. </li>
<li><code class="docutils literal notranslate"><span class="pre">pError</span></code>: a pointer to a NSError pointer which is set when an error occurs </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="interface_imebra_data_set_1a74999fad91b8f3b16419f50ca6ef3e23"></span><code class="descname">void ImebraDataSet::setDouble:newValue:error:(ImebraTagId  * tagId, double newValue, (swift_error(nonnull_error)) __attribute__)</code></dt>
<dd><p>Write a new double floating point value into the element 0 of the specified tag’s buffer 0. </p>
<p>If the specified tag doesn’t exist then a new tag is created using the data type (VR) retrieved from the <a class="reference internal" href="dicom_dictionary_classes.html#interface_imebra_dicom_dictionary"><span class="std std-ref">ImebraDicomDictionary</span></a>.</p>
<p>If the new value cannot be converted to the VR returned by the <a class="reference internal" href="dicom_dictionary_classes.html#interface_imebra_dicom_dictionary"><span class="std std-ref">ImebraDicomDictionary</span></a> then sets pError to ImebraDataHandlerConversionError.</p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">tagId</span></code>: the tag’s id </li>
<li><code class="docutils literal notranslate"><span class="pre">newValue</span></code>: the value to write into the tag </li>
<li><code class="docutils literal notranslate"><span class="pre">pError</span></code>: a pointer to a NSError pointer which is set when an error occurs </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="interface_imebra_data_set_1a4dcd9dd6173006e413a0869159025ec0"></span><code class="descname">NSString* ImebraDataSet::getString:elementNumber:error:(ImebraTagId  * tagId, unsigned int elementNumber, NSError ** pError)</code></dt>
<dd><p>Retrieve a tag’s value as a string. </p>
<p>If the tag’s value cannot be converted to a string then sets pError to ImebraDataHandlerConversionError.</p>
<p>If the specified tag does not exist then set pError to ImebraMissingTagError or ImebraMissingGroupError.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>the tag’s value as a string </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">tagId</span></code>: the tag’s id </li>
<li><code class="docutils literal notranslate"><span class="pre">elementNumber</span></code>: the element number within the buffer </li>
<li><code class="docutils literal notranslate"><span class="pre">pError</span></code>: a pointer to a NSError pointer which is set when an error occurs </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="interface_imebra_data_set_1abd281a770178c4e6b5c65d5ee3c4f93e"></span><code class="descname">NSString* ImebraDataSet::getString:elementNumber:defaultValue:error:(ImebraTagId  * tagId, unsigned int elementNumber, NSString * defaultValue, NSError ** pError)</code></dt>
<dd><p>Retrieve a tag’s value as a string. </p>
<p>If the tag’s value cannot be converted to a string then sets pError to ImebraDataHandlerConversionError.</p>
<p>If the specified tag does not exist then returns the default value set in the defaultValue parameter.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>the tag’s value as a string </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">tagId</span></code>: the tag’s id </li>
<li><code class="docutils literal notranslate"><span class="pre">elementNumber</span></code>: the element number within the buffer </li>
<li><code class="docutils literal notranslate"><span class="pre">defaultValue</span></code>: the value to return if the tag doesn’t exist </li>
<li><code class="docutils literal notranslate"><span class="pre">pError</span></code>: a pointer to a NSError pointer which is set when an error occurs </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="interface_imebra_data_set_1a2e06bf483b0d611f7d1a565210086873"></span><code class="descname">void ImebraDataSet::setString:newValue:tagVR:error:(ImebraTagId  * tagId, NSString * newValue, ImebraTagVR_t tagVR, (swift_error(nonnull_error)) __attribute__)</code></dt>
<dd><p>Write a new string value into the element 0 of the specified tag’s buffer 0. </p>
<p>If the specified tag doesn’t exist then a new tag is created using the specified data type (VR).</p>
<p>If the new value cannot be converted to the specified VR then sets pError to ImebraDataHandlerConversionError.</p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">tagId</span></code>: the tag’s id </li>
<li><code class="docutils literal notranslate"><span class="pre">newValue</span></code>: the value to write into the tag </li>
<li><code class="docutils literal notranslate"><span class="pre">tagVR</span></code>: the tag’s type to use when a new tag is created. </li>
<li><code class="docutils literal notranslate"><span class="pre">pError</span></code>: a pointer to a NSError pointer which is set when an error occurs </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="interface_imebra_data_set_1abe6f85a6740a16ca04713aa1f5411e81"></span><code class="descname">void ImebraDataSet::setString:newValue:error:(ImebraTagId  * tagId, NSString * newValue, (swift_error(nonnull_error)) __attribute__)</code></dt>
<dd><p>Write a new string value into the element 0 of the specified tag’s buffer 0. </p>
<p>If the specified tag doesn’t exist then a new tag is created using the data type (VR) retrieved from the <a class="reference internal" href="dicom_dictionary_classes.html#interface_imebra_dicom_dictionary"><span class="std std-ref">ImebraDicomDictionary</span></a>.</p>
<p>If the new value cannot be converted to the VR returned by the <a class="reference internal" href="dicom_dictionary_classes.html#interface_imebra_dicom_dictionary"><span class="std std-ref">ImebraDicomDictionary</span></a> then sets pError to ImebraDataHandlerConversionError.</p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">tagId</span></code>: the tag’s id </li>
<li><code class="docutils literal notranslate"><span class="pre">newValue</span></code>: the value to write into the tag </li>
<li><code class="docutils literal notranslate"><span class="pre">pError</span></code>: a pointer to a NSError pointer which is set when an error occurs </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="interface_imebra_data_set_1a2ab154f475d972cecb43b0cf933a57a1"></span><code class="descname">ImebraAge* ImebraDataSet::getAge:elementNumber:error:(ImebraTagId  * tagId, unsigned int elementNumber, NSError ** pError)</code></dt>
<dd><p>Retrieve a tag’s value as an ImebraAge object. </p>
<p>If the tag’s value cannot be converted to an ImebraAge object then sets pError to ImebraDataHandlerConversionError.</p>
<p>If the specified tag does not exist then set pError to ImebraMissingTagError or ImebraMissingGroupError.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>the tag’s value as an ImebraAge object </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">tagId</span></code>: the tag’s id </li>
<li><code class="docutils literal notranslate"><span class="pre">elementNumber</span></code>: the element number within the buffer </li>
<li><code class="docutils literal notranslate"><span class="pre">pError</span></code>: a pointer to a NSError pointer which is set when an error occurs </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="interface_imebra_data_set_1a1aa0d44a0b4b377a4891d2a819fa2249"></span><code class="descname">ImebraAge* ImebraDataSet::getAge:elementNumber:defaultValue:error:(ImebraTagId  * tagId, unsigned int elementNumber, ImebraAge  * defaultValue, NSError ** pError)</code></dt>
<dd><p>Retrieve a tag’s value as an ImebraAge object. </p>
<p>If the tag’s value cannot be converted to an ImebraAge object then sets pError to ImebraDataHandlerConversionError.</p>
<p>If the specified tag does not exist then returns the default value set in the defaultValue parameter.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>the tag’s value as an ImebraAge object </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">tagId</span></code>: the tag’s id </li>
<li><code class="docutils literal notranslate"><span class="pre">elementNumber</span></code>: the element number within the buffer </li>
<li><code class="docutils literal notranslate"><span class="pre">defaultValue</span></code>: the value to return if the tag doesn’t exist </li>
<li><code class="docutils literal notranslate"><span class="pre">pError</span></code>: a pointer to a NSError pointer which is set when an error occurs </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="interface_imebra_data_set_1a2c8b2764cb2ccd76bc8a4096479b77c5"></span><code class="descname">void ImebraDataSet::setAge:newValue:error:(ImebraTagId  * tagId, ImebraAge  * newValue, (swift_error(nonnull_error)) __attribute__)</code></dt>
<dd><p>Write a new ImebraAge value into the element 0 of the specified tag’s buffer 0. </p>
<p>If the specified tag doesn’t exist then a new tag is created using the data type (VR) AS.</p>
<p>If the new value cannot be converted to the VR “AS” then sets pError to ImebraDataHandlerConversionError.</p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">tagId</span></code>: the tag’s id </li>
<li><code class="docutils literal notranslate"><span class="pre">newValue</span></code>: the value to write into the tag </li>
<li><code class="docutils literal notranslate"><span class="pre">pError</span></code>: a pointer to a NSError pointer which is set when an error occurs </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="interface_imebra_data_set_1a9e36e315981aa3e4bdcc4ce842900bf0"></span><code class="descname">ImebraDate* ImebraDataSet::getDate:elementNumber:error:(ImebraTagId  * tagId, unsigned int elementNumber, NSError ** pError)</code></dt>
<dd><p>Retrieve a tag’s value as an ImebraDate object. </p>
<p>If the tag’s value cannot be converted to an ImebraDate object then sets pError to ImebraDataHandlerConversionError.</p>
<p>If the specified tag does not exist then set pError to ImebraMissingTagError or ImebraMissingGroupError.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>the tag’s value as an ImebraDate object </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">tagId</span></code>: the tag’s id </li>
<li><code class="docutils literal notranslate"><span class="pre">elementNumber</span></code>: the element number within the buffer </li>
<li><code class="docutils literal notranslate"><span class="pre">pError</span></code>: a pointer to a NSError pointer which is set when an error occurs </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="interface_imebra_data_set_1a6a3bf0e45be2007b7778f3e3345cabf5"></span><code class="descname">ImebraDate* ImebraDataSet::getDate:elementNumber:defaultValue:error:(ImebraTagId  * tagId, unsigned int elementNumber, ImebraDate * defaultValue, NSError ** pError)</code></dt>
<dd><p>Retrieve a tag’s value as an ImebraDate object. </p>
<p>If the tag’s value cannot be converted to an ImebraDate object then sets pError to ImebraDataHandlerConversionError.</p>
<p>If the specified tag does not exist then returns the default value set in the defaultValue parameter.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>the tag’s value as an ImebraDate object </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">tagId</span></code>: the tag’s id </li>
<li><code class="docutils literal notranslate"><span class="pre">elementNumber</span></code>: the element number within the buffer </li>
<li><code class="docutils literal notranslate"><span class="pre">defaultValue</span></code>: the value to return if the tag doesn’t exist </li>
<li><code class="docutils literal notranslate"><span class="pre">pError</span></code>: a pointer to a NSError pointer which is set when an error occurs </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="interface_imebra_data_set_1a1ec2d44f39b26ec75754884ee7e0b897"></span><code class="descname">void ImebraDataSet::setDate:newValue:tagVR:error:(ImebraTagId  * tagId, ImebraDate * newValue, ImebraTagVR_t tagVR, (swift_error(nonnull_error)) __attribute__)</code></dt>
<dd><p>Write a new ImebraDate value into the element 0 of the specified tag’s buffer 0. </p>
<p>If the specified tag doesn’t exist then a new tag is created using the specified data type (VR).</p>
<p>If the new value cannot be converted to the specified VR then sets pError to ImebraDataHandlerConversionError.</p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">tagId</span></code>: the tag’s id </li>
<li><code class="docutils literal notranslate"><span class="pre">newValue</span></code>: the value to write into the tag </li>
<li><code class="docutils literal notranslate"><span class="pre">tagVR</span></code>: the tag’s type to use when a new tag is created. </li>
<li><code class="docutils literal notranslate"><span class="pre">pError</span></code>: a pointer to a NSError pointer which is set when an error occurs </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="interface_imebra_data_set_1ac641be99c3da29948b9bdf6fcc74e915"></span><code class="descname">void ImebraDataSet::setDate:newValue:error:(ImebraTagId  * tagId, ImebraDate * newValue, (swift_error(nonnull_error)) __attribute__)</code></dt>
<dd><p>Write a new ImebraDate value into the element 0 of the specified tag’s buffer 0. </p>
<p>If the specified tag doesn’t exist then a new tag is created using the data type (VR) retrieved from the <a class="reference internal" href="dicom_dictionary_classes.html#interface_imebra_dicom_dictionary"><span class="std std-ref">ImebraDicomDictionary</span></a>.</p>
<p>If the new value cannot be converted to the VR returned by the <a class="reference internal" href="dicom_dictionary_classes.html#interface_imebra_dicom_dictionary"><span class="std std-ref">ImebraDicomDictionary</span></a> then sets pError to ImebraDataHandlerConversionError.</p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">tagId</span></code>: the tag’s id </li>
<li><code class="docutils literal notranslate"><span class="pre">newValue</span></code>: the value to write into the tag </li>
<li><code class="docutils literal notranslate"><span class="pre">pError</span></code>: a pointer to a NSError pointer which is set when an error occurs </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="interface_imebra_data_set_1adaee85f9c29153c69990b4dec202b5c7"></span><code class="descname">ImebraTagVR_t ImebraDataSet::getDataType:error:(ImebraTagId  * tagId, (swift_error(nonnull_error)) __attribute__)</code></dt>
<dd><p>Return the data type (VR) of the specified tag. </p>
<p>If the specified tag does not exist then set pError to ImebraMissingTagError or ImebraMissingGroupError.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>the tag’s data type (VR) </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">tagId</span></code>: the id of the tag </li>
<li><code class="docutils literal notranslate"><span class="pre">pError</span></code>: a pointer to a NSError pointer which is set when an error occurs </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

</div>
</dd></dl>

</div>
</div>
<div class="section" id="tag">
<span id="id2"></span><h3>Tag<a class="headerlink" href="#tag" title="Permalink to this headline">¶</a></h3>
<div class="section" id="id3">
<h4>C++<a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h4>
<dl class="class">
<dt id="_CPPv3N6imebra3TagE">
<span id="_CPPv2N6imebra3TagE"></span><span id="imebra::Tag"></span><span class="target" id="classimebra_1_1_tag"></span><em class="property">class </em><code class="descname">Tag</code><a class="headerlink" href="#_CPPv3N6imebra3TagE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>This class represents a DICOM tag. </p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Functions</p>
<dl class="function">
<dt id="_CPPv3NK6imebra3Tag15getBuffersCountEv">
<span id="_CPPv2NK6imebra3Tag15getBuffersCountEv"></span><span id="imebra::Tag::getBuffersCountC"></span><span class="target" id="classimebra_1_1_tag_1add16b13b9808887f817e725163331b33"></span>size_t <code class="descname">getBuffersCount</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv3NK6imebra3Tag15getBuffersCountEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Returns the number of buffers in the tag. </p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>the number of buffers in the tag </dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3NK6imebra3Tag12bufferExistsE6size_t">
<span id="_CPPv2NK6imebra3Tag12bufferExistsE6size_t"></span><span id="imebra::Tag::bufferExists__sC"></span><span class="target" id="classimebra_1_1_tag_1a1600316d28d97c4d421b22931548a2b6"></span>bool <code class="descname">bufferExists</code><span class="sig-paren">(</span>size_t <em>bufferId</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv3NK6imebra3Tag12bufferExistsE6size_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Returns true if the specified buffer exists, otherwise it returns false. </p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>true if the buffer exists, false otherwise </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">bufferId</span></code>: the zero-based buffer’s id the function has to check for </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3NK6imebra3Tag13getBufferSizeE6size_t">
<span id="_CPPv2NK6imebra3Tag13getBufferSizeE6size_t"></span><span id="imebra::Tag::getBufferSize__sC"></span><span class="target" id="classimebra_1_1_tag_1abc051a38f616f2a4eadda4edc75dd15c"></span>size_t <code class="descname">getBufferSize</code><span class="sig-paren">(</span>size_t <em>bufferId</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv3NK6imebra3Tag13getBufferSizeE6size_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Returns the size of a buffer, in bytes. </p>
<p>If the buffer doesn’t exist then throws <a class="reference internal" href="exception_classes.html#classimebra_1_1_missing_buffer_error"><span class="std std-ref">MissingBufferError</span></a>.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>the buffer’s size in bytes </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">bufferId</span></code>: the zero-based buffer’s id the function has to check for </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3NK6imebra3Tag21getReadingDataHandlerE6size_t">
<span id="_CPPv2NK6imebra3Tag21getReadingDataHandlerE6size_t"></span><span id="imebra::Tag::getReadingDataHandler__sC"></span><span class="target" id="classimebra_1_1_tag_1aa5f74d9b8b18a5f167abb8b321fb75ea"></span><a class="reference internal" href="#_CPPv3N6imebra18ReadingDataHandlerE" title="imebra::ReadingDataHandler">ReadingDataHandler</a> *<code class="descname">getReadingDataHandler</code><span class="sig-paren">(</span>size_t <em>bufferId</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv3NK6imebra3Tag21getReadingDataHandlerE6size_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Retrieve a <a class="reference internal" href="#classimebra_1_1_reading_data_handler"><span class="std std-ref">ReadingDataHandler</span></a> object connected to a specific buffer. </p>
<p>If the specified buffer does not exist then throws or <a class="reference internal" href="exception_classes.html#classimebra_1_1_missing_buffer_error"><span class="std std-ref">MissingBufferError</span></a>.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>a <a class="reference internal" href="#classimebra_1_1_reading_data_handler"><span class="std std-ref">ReadingDataHandler</span></a> object connected to the requested buffer </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">bufferId</span></code>: the buffer to connect to the <a class="reference internal" href="#classimebra_1_1_reading_data_handler"><span class="std std-ref">ReadingDataHandler</span></a> object. The first buffer has an Id = 0 </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N6imebra3Tag21getWritingDataHandlerE6size_t">
<span id="_CPPv2N6imebra3Tag21getWritingDataHandlerE6size_t"></span><span id="imebra::Tag::getWritingDataHandler__s"></span><span class="target" id="classimebra_1_1_tag_1adff439da273315a0ae9f64af917b12ce"></span><a class="reference internal" href="#_CPPv3N6imebra18WritingDataHandlerE" title="imebra::WritingDataHandler">WritingDataHandler</a> *<code class="descname">getWritingDataHandler</code><span class="sig-paren">(</span>size_t <em>bufferId</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N6imebra3Tag21getWritingDataHandlerE6size_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Retrieve a <a class="reference internal" href="#classimebra_1_1_writing_data_handler"><span class="std std-ref">WritingDataHandler</span></a> object connected to a specific tag’s buffer. </p>
<p>If the specified <a class="reference internal" href="#classimebra_1_1_tag"><span class="std std-ref">Tag</span></a> does not exist then it creates a new tag with the VR specified in the tagVR parameter</p>
<p>The returned <a class="reference internal" href="#classimebra_1_1_writing_data_handler"><span class="std std-ref">WritingDataHandler</span></a> is connected to a new buffer which is updated and stored in the tag when <a class="reference internal" href="#classimebra_1_1_writing_data_handler"><span class="std std-ref">WritingDataHandler</span></a> is destroyed.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>a <a class="reference internal" href="#classimebra_1_1_writing_data_handler"><span class="std std-ref">WritingDataHandler</span></a> object connected to a new <a class="reference internal" href="#classimebra_1_1_tag"><span class="std std-ref">Tag</span></a>’s buffer </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">bufferId</span></code>: the position where the new buffer has to be stored into the tag. The first buffer position is 0 </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3NK6imebra3Tag28getReadingDataHandlerNumericE6size_t">
<span id="_CPPv2NK6imebra3Tag28getReadingDataHandlerNumericE6size_t"></span><span id="imebra::Tag::getReadingDataHandlerNumeric__sC"></span><span class="target" id="classimebra_1_1_tag_1a9dbf39db46c05e3ab3146ff80b0f5b66"></span><a class="reference internal" href="#_CPPv3N6imebra25ReadingDataHandlerNumericE" title="imebra::ReadingDataHandlerNumeric">ReadingDataHandlerNumeric</a> *<code class="descname">getReadingDataHandlerNumeric</code><span class="sig-paren">(</span>size_t <em>bufferId</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv3NK6imebra3Tag28getReadingDataHandlerNumericE6size_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Retrieve a <a class="reference internal" href="#classimebra_1_1_reading_data_handler_numeric"><span class="std std-ref">ReadingDataHandlerNumeric</span></a> object connected to the <a class="reference internal" href="#classimebra_1_1_tag"><span class="std std-ref">Tag</span></a>’s numeric buffer. </p>
<p>If the tag’s VR is not a numeric type then throws std::bad_cast.</p>
<p>If the specified <a class="reference internal" href="#classimebra_1_1_tag"><span class="std std-ref">Tag</span></a> does not contain the specified buffer then throws <a class="reference internal" href="exception_classes.html#classimebra_1_1_missing_buffer_error"><span class="std std-ref">MissingBufferError</span></a>.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>a <a class="reference internal" href="#classimebra_1_1_reading_data_handler_numeric"><span class="std std-ref">ReadingDataHandlerNumeric</span></a> object connected to the <a class="reference internal" href="#classimebra_1_1_tag"><span class="std std-ref">Tag</span></a>’s buffer </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">bufferId</span></code>: the buffer to connect to the <a class="reference internal" href="#classimebra_1_1_reading_data_handler"><span class="std std-ref">ReadingDataHandler</span></a> object. The first buffer has an Id = 0 </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3NK6imebra3Tag24getReadingDataHandlerRawE6size_t">
<span id="_CPPv2NK6imebra3Tag24getReadingDataHandlerRawE6size_t"></span><span id="imebra::Tag::getReadingDataHandlerRaw__sC"></span><span class="target" id="classimebra_1_1_tag_1a6014dc3e19016ce6fdba6ca81bdbc46d"></span><a class="reference internal" href="#_CPPv3N6imebra25ReadingDataHandlerNumericE" title="imebra::ReadingDataHandlerNumeric">ReadingDataHandlerNumeric</a> *<code class="descname">getReadingDataHandlerRaw</code><span class="sig-paren">(</span>size_t <em>bufferId</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv3NK6imebra3Tag24getReadingDataHandlerRawE6size_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Retrieve a <a class="reference internal" href="#classimebra_1_1_reading_data_handler_numeric"><span class="std std-ref">ReadingDataHandlerNumeric</span></a> object connected to the <a class="reference internal" href="#classimebra_1_1_tag"><span class="std std-ref">Tag</span></a>’s raw data buffer (8 bit unsigned integers). </p>
<p>If the tag’s VR is not a numeric type then throws std::bad_cast.</p>
<p>If the specified <a class="reference internal" href="#classimebra_1_1_tag"><span class="std std-ref">Tag</span></a> does not contain the specified buffer then throws <a class="reference internal" href="exception_classes.html#classimebra_1_1_missing_buffer_error"><span class="std std-ref">MissingBufferError</span></a>.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>a <a class="reference internal" href="#classimebra_1_1_reading_data_handler_numeric"><span class="std std-ref">ReadingDataHandlerNumeric</span></a> object connected to the <a class="reference internal" href="#classimebra_1_1_tag"><span class="std std-ref">Tag</span></a>’s buffer (raw content represented by 8 bit unsigned integers) </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">bufferId</span></code>: the buffer to connect to the <a class="reference internal" href="#classimebra_1_1_reading_data_handler"><span class="std std-ref">ReadingDataHandler</span></a> object. The first buffer has an Id = 0 </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N6imebra3Tag28getWritingDataHandlerNumericE6size_t">
<span id="_CPPv2N6imebra3Tag28getWritingDataHandlerNumericE6size_t"></span><span id="imebra::Tag::getWritingDataHandlerNumeric__s"></span><span class="target" id="classimebra_1_1_tag_1a2ca57a048244f55946cab38a61ec785d"></span><a class="reference internal" href="#_CPPv3N6imebra25WritingDataHandlerNumericE" title="imebra::WritingDataHandlerNumeric">WritingDataHandlerNumeric</a> *<code class="descname">getWritingDataHandlerNumeric</code><span class="sig-paren">(</span>size_t <em>bufferId</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N6imebra3Tag28getWritingDataHandlerNumericE6size_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Retrieve a <a class="reference internal" href="#classimebra_1_1_writing_data_handler_numeric"><span class="std std-ref">WritingDataHandlerNumeric</span></a> object connected to the <a class="reference internal" href="#classimebra_1_1_tag"><span class="std std-ref">Tag</span></a>’s buffer. </p>
<p>If the tag’s VR is not a numeric type then throws std::bad_cast.</p>
<p>The returned <a class="reference internal" href="#classimebra_1_1_writing_data_handler_numeric"><span class="std std-ref">WritingDataHandlerNumeric</span></a> is connected to a new buffer which is updated and stored into the tag when <a class="reference internal" href="#classimebra_1_1_writing_data_handler_numeric"><span class="std std-ref">WritingDataHandlerNumeric</span></a> is destroyed.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>a <a class="reference internal" href="#classimebra_1_1_writing_data_handler_numeric"><span class="std std-ref">WritingDataHandlerNumeric</span></a> object connected to a new <a class="reference internal" href="#classimebra_1_1_tag"><span class="std std-ref">Tag</span></a>’s buffer </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">bufferId</span></code>: the position where the new buffer has to be stored in the tag. The first buffer position is 0 </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N6imebra3Tag24getWritingDataHandlerRawE6size_t">
<span id="_CPPv2N6imebra3Tag24getWritingDataHandlerRawE6size_t"></span><span id="imebra::Tag::getWritingDataHandlerRaw__s"></span><span class="target" id="classimebra_1_1_tag_1ada0b04f3aab67abc8d43521ed7a36314"></span><a class="reference internal" href="#_CPPv3N6imebra25WritingDataHandlerNumericE" title="imebra::WritingDataHandlerNumeric">WritingDataHandlerNumeric</a> *<code class="descname">getWritingDataHandlerRaw</code><span class="sig-paren">(</span>size_t <em>bufferId</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N6imebra3Tag24getWritingDataHandlerRawE6size_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Retrieve a <a class="reference internal" href="#classimebra_1_1_writing_data_handler_numeric"><span class="std std-ref">WritingDataHandlerNumeric</span></a> object connected to the <a class="reference internal" href="#classimebra_1_1_tag"><span class="std std-ref">Tag</span></a>’s raw data buffer (8 bit unsigned integers). </p>
<p>If the tag’s VR is not a numeric type then throws std::bad_cast.</p>
<p>The returned <a class="reference internal" href="#classimebra_1_1_writing_data_handler_numeric"><span class="std std-ref">WritingDataHandlerNumeric</span></a> is connected to a new buffer which is updated and stored into the tag when <a class="reference internal" href="#classimebra_1_1_writing_data_handler_numeric"><span class="std std-ref">WritingDataHandlerNumeric</span></a> is destroyed.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>a <a class="reference internal" href="#classimebra_1_1_writing_data_handler_numeric"><span class="std std-ref">WritingDataHandlerNumeric</span></a> object connected to a new <a class="reference internal" href="#classimebra_1_1_tag"><span class="std std-ref">Tag</span></a>’s buffer (the buffer contains raw data of 8 bit integers) </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">bufferId</span></code>: the position where the new buffer has to be stored in the tag. The first buffer position is 0 </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N6imebra3Tag15getStreamReaderE6size_t">
<span id="_CPPv2N6imebra3Tag15getStreamReaderE6size_t"></span><span id="imebra::Tag::getStreamReader__s"></span><span class="target" id="classimebra_1_1_tag_1afa7652b6c740bf2c313941a8dd4a6502"></span><a class="reference internal" href="stream_classes.html#_CPPv3N6imebra12StreamReaderE" title="imebra::StreamReader">StreamReader</a> *<code class="descname">getStreamReader</code><span class="sig-paren">(</span>size_t <em>bufferId</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N6imebra3Tag15getStreamReaderE6size_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Get a <a class="reference internal" href="stream_classes.html#classimebra_1_1_stream_reader"><span class="std std-ref">StreamReader</span></a> connected to a buffer’s data. </p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>the streamReader connected to the buffer’s data. </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">bufferId</span></code>: the id of the buffer for which the <a class="reference internal" href="stream_classes.html#classimebra_1_1_stream_reader"><span class="std std-ref">StreamReader</span></a> is required. This parameter is usually 0 </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N6imebra3Tag15getStreamWriterE6size_t">
<span id="_CPPv2N6imebra3Tag15getStreamWriterE6size_t"></span><span id="imebra::Tag::getStreamWriter__s"></span><span class="target" id="classimebra_1_1_tag_1a4c1015533543ccf73beab22a5f8c2a7f"></span><a class="reference internal" href="stream_classes.html#_CPPv3N6imebra12StreamWriterE" title="imebra::StreamWriter">StreamWriter</a> *<code class="descname">getStreamWriter</code><span class="sig-paren">(</span>size_t <em>bufferId</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N6imebra3Tag15getStreamWriterE6size_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Get a <a class="reference internal" href="stream_classes.html#classimebra_1_1_stream_writer"><span class="std std-ref">StreamWriter</span></a> connected to a buffer’s data. </p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>the <a class="reference internal" href="stream_classes.html#classimebra_1_1_stream_writer"><span class="std std-ref">StreamWriter</span></a> connected to the buffer’s data. </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">bufferId</span></code>: the id of the buffer for which the <a class="reference internal" href="stream_classes.html#classimebra_1_1_stream_writer"><span class="std std-ref">StreamWriter</span></a> is required. This parameter is usually 0 </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3NK6imebra3Tag15getSequenceItemE6size_t">
<span id="_CPPv2NK6imebra3Tag15getSequenceItemE6size_t"></span><span id="imebra::Tag::getSequenceItem__sC"></span><span class="target" id="classimebra_1_1_tag_1a609171e3ff42147c88306d5557af4aaf"></span><a class="reference internal" href="#_CPPv3N6imebra7DataSetE" title="imebra::DataSet">DataSet</a> *<code class="descname">getSequenceItem</code><span class="sig-paren">(</span>size_t <em>dataSetId</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv3NK6imebra3Tag15getSequenceItemE6size_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Retrieve an embedded <a class="reference internal" href="#classimebra_1_1_data_set"><span class="std std-ref">DataSet</span></a>. </p>
<p>Sequence tags (VR=SQ) store embedded dicom structures.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>the sequence <a class="reference internal" href="#classimebra_1_1_data_set"><span class="std std-ref">DataSet</span></a> </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">dataSetId</span></code>: the ID of the sequence item to retrieve. Several sequence items can be embedded in one tag. </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3NK6imebra3Tag18sequenceItemExistsE6size_t">
<span id="_CPPv2NK6imebra3Tag18sequenceItemExistsE6size_t"></span><span id="imebra::Tag::sequenceItemExists__sC"></span><span class="target" id="classimebra_1_1_tag_1a95e0efd4b5c56e0968513a0f6b7b32e1"></span>bool <code class="descname">sequenceItemExists</code><span class="sig-paren">(</span>size_t <em>dataSetId</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv3NK6imebra3Tag18sequenceItemExistsE6size_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Check for the existance of a sequence item. </p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>true if the sequence item exists, false otherwise </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">dataSetId</span></code>: the ID of the sequence item to check for </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N6imebra3Tag15setSequenceItemE6size_tRK7DataSet">
<span id="_CPPv2N6imebra3Tag15setSequenceItemE6size_tRK7DataSet"></span><span id="imebra::Tag::setSequenceItem__s.DataSetCR"></span><span class="target" id="classimebra_1_1_tag_1a6730a09ff0bf44f398a9389530918d52"></span>void <code class="descname">setSequenceItem</code><span class="sig-paren">(</span>size_t <em>dataSetId</em>, <em class="property">const</em> <a class="reference internal" href="#_CPPv3N6imebra7DataSetE" title="imebra::DataSet">DataSet</a> &amp;<em>dataSet</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N6imebra3Tag15setSequenceItemE6size_tRK7DataSet" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Insert a sequence item into the <a class="reference internal" href="#classimebra_1_1_tag"><span class="std std-ref">Tag</span></a>. </p>
<p>Several sequence items can be nested one inside each other. When a sequence item is embedded into a <a class="reference internal" href="#classimebra_1_1_tag"><span class="std std-ref">Tag</span></a>, then the tag will have a sequence VR (VR = SQ).</p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">dataSetId</span></code>: the ID of the sequence item </li>
<li><code class="docutils literal notranslate"><span class="pre">dataSet</span></code>: the <a class="reference internal" href="#classimebra_1_1_data_set"><span class="std std-ref">DataSet</span></a> containing the sequence item data </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N6imebra3Tag18appendSequenceItemERK7DataSet">
<span id="_CPPv2N6imebra3Tag18appendSequenceItemERK7DataSet"></span><span id="imebra::Tag::appendSequenceItem__DataSetCR"></span><span class="target" id="classimebra_1_1_tag_1ad4a8f9f57e04435a7f1766c2131df5a5"></span>void <code class="descname">appendSequenceItem</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv3N6imebra7DataSetE" title="imebra::DataSet">DataSet</a> &amp;<em>dataSet</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N6imebra3Tag18appendSequenceItemERK7DataSet" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Append a sequence item into the <a class="reference internal" href="#classimebra_1_1_tag"><span class="std std-ref">Tag</span></a>. </p>
<p>Several sequence items can be nested one inside each other. When a sequence item is embedded into a <a class="reference internal" href="#classimebra_1_1_tag"><span class="std std-ref">Tag</span></a>, then the tag will have a sequence VR (VR = SQ).</p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">dataSet</span></code>: the <a class="reference internal" href="#classimebra_1_1_data_set"><span class="std std-ref">DataSet</span></a> containing the sequence item data </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3NK6imebra3Tag11getDataTypeEv">
<span id="_CPPv2NK6imebra3Tag11getDataTypeEv"></span><span id="imebra::Tag::getDataTypeC"></span><span class="target" id="classimebra_1_1_tag_1a89f96a04cbb3e44a2fb9f5e09182071e"></span><a class="reference internal" href="definition_classes.html#_CPPv3N6imebra7tagVR_tE" title="imebra::tagVR_t">tagVR_t</a> <code class="descname">getDataType</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv3NK6imebra3Tag11getDataTypeEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Get the tag’s data type. </p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>the tag’s data type </dd>
</dl>
</p>
</dd></dl>

</div>
</dd></dl>

</div>
<div class="section" id="id4">
<h4>Objective-C/Swift<a class="headerlink" href="#id4" title="Permalink to this headline">¶</a></h4>
<dl class="class">
<dt id="_CPPv39ImebraTag">
<span id="_CPPv29ImebraTag"></span><span id="ImebraTag"></span><span class="target" id="interface_imebra_tag"></span><em class="property">class </em><code class="descname">ImebraTag</code> : <em class="property">public</em> NSObject<a class="headerlink" href="#_CPPv39ImebraTag" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>This class represents a DICOM tag. </p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Functions</p>
<dl class="function">
<dt id="_CPPv3N9ImebraTag15getBuffersCountEv">
<span id="_CPPv2N9ImebraTag15getBuffersCountEv"></span><span id="ImebraTag::getBuffersCount"></span><span class="target" id="interface_imebra_tag_1a9ed2852f15422dbfe322a21daf640658"></span>unsigned int <code class="descname">getBuffersCount</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N9ImebraTag15getBuffersCountEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Returns the number of buffers in the tag. </p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>the number of buffers in the tag </dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="interface_imebra_tag_1ac4be15d1e412cc22560a777572168a7e"></span><code class="descname">BOOL ImebraTag::bufferExists:(unsigned int bufferId)</code></dt>
<dd><p>Returns true if the specified buffer exists, otherwise it returns false. </p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>true if the buffer exists, false otherwise </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">bufferId</span></code>: the zero-based buffer’s id the function has to check for </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="interface_imebra_tag_1ad75d1ec12918a3331b049b93d3ec1ade"></span><code class="descname">unsigned int ImebraTag::getBufferSize:error:(unsigned int bufferId, (swift_error(nonnull_error)) __attribute__)</code></dt>
<dd><p>Returns the size of a buffer, in bytes. </p>
<p>If the buffer doesn’t exist then set pError to ImebraMissingBufferError.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>the buffer’s size in bytes </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">bufferId</span></code>: the zero-based buffer’s id the function has to check for </li>
<li><code class="docutils literal notranslate"><span class="pre">pError</span></code>: set to a NSError derived class in case of error </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="interface_imebra_tag_1aa06187f3e81b4fa3c06024554df4ca1f"></span><code class="descname">ImebraReadingDataHandler* ImebraTag::getReadingDataHandler:error:(unsigned int bufferId, NSError ** pError)</code></dt>
<dd><p>Retrieve a <a class="reference internal" href="#interface_imebra_reading_data_handler"><span class="std std-ref">ImebraReadingDataHandler</span></a> object connected to a specific buffer. </p>
<p>If the buffer doesn’t exist then set pError to ImebraMissingBufferError.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>a <a class="reference internal" href="#interface_imebra_reading_data_handler"><span class="std std-ref">ImebraReadingDataHandler</span></a> object connected to the requested buffer </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">bufferId</span></code>: the buffer to connect to the ReadingDataHandler object. The first buffer has an Id = 0 </li>
<li><code class="docutils literal notranslate"><span class="pre">pError</span></code>: set to a NSError derived class in case of error </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="interface_imebra_tag_1a8dac933e4cee78501e5a7502736f6d5b"></span><code class="descname">ImebraWritingDataHandler* ImebraTag::getWritingDataHandler:error:(unsigned int bufferId, NSError ** pError)</code></dt>
<dd><p>Retrieve a <a class="reference internal" href="#interface_imebra_writing_data_handler"><span class="std std-ref">ImebraWritingDataHandler</span></a> object connected to a specific tag’s buffer. </p>
<p>If the specified buffer does not exist then it creates a new buffer.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>a <a class="reference internal" href="#interface_imebra_writing_data_handler"><span class="std std-ref">ImebraWritingDataHandler</span></a> object connected to a new tag’s buffer </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">bufferId</span></code>: the position where the new buffer has to be stored into the tag. The first buffer position is 0 </li>
<li><code class="docutils literal notranslate"><span class="pre">pError</span></code>: set to a NSError derived class in case of error </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="interface_imebra_tag_1af9fdb89f331383e789eb40faf27f6366"></span><code class="descname">ImebraReadingDataHandlerNumeric* ImebraTag::getReadingDataHandlerNumeric:error:(unsigned int bufferId, NSError ** pError)</code></dt>
<dd><p>Retrieve a <a class="reference internal" href="#interface_imebra_reading_data_handler_numeric"><span class="std std-ref">ImebraReadingDataHandlerNumeric</span></a> object connected to the Tag’s numeric buffer. </p>
<p>If the tag’s VR is not a numeric type then throws std::bad_cast.</p>
<p>If the tag does not contain the specified buffer then set pError to ImebraMissingBufferError.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>a <a class="reference internal" href="#interface_imebra_reading_data_handler_numeric"><span class="std std-ref">ImebraReadingDataHandlerNumeric</span></a> object connected to the Tag’s buffer </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">bufferId</span></code>: the buffer to connect to the <a class="reference internal" href="#interface_imebra_reading_data_handler"><span class="std std-ref">ImebraReadingDataHandler</span></a> object. The first buffer has an Id = 0 </li>
<li><code class="docutils literal notranslate"><span class="pre">pError</span></code>: set to a NSError derived class in case of error </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="interface_imebra_tag_1a6b2b2b228deee82362827894311512ef"></span><code class="descname">ImebraReadingDataHandlerNumeric* ImebraTag::getReadingDataHandlerRaw:error:(unsigned int bufferId, NSError ** pError)</code></dt>
<dd><p>Retrieve a ReadingDataHandlerNumeric object connected to the Tag’s raw data buffer (8 bit unsigned integers). </p>
<p>If the tag’s VR is not a numeric type then throws std::bad_cast.</p>
<p>If the specified Tag does not contain the specified buffer then throws MissingBufferError.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>a ReadingDataHandlerNumeric object connected to the Tag’s buffer (raw content represented by 8 bit unsigned integers) </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">bufferId</span></code>: the buffer to connect to the ReadingDataHandler object. The first buffer has an Id = 0 </li>
<li><code class="docutils literal notranslate"><span class="pre">pError</span></code>: set to a NSError derived class in case of error </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="interface_imebra_tag_1a3b9e76c0e301f147cf7e5395ed79fa80"></span><code class="descname">ImebraWritingDataHandlerNumeric* ImebraTag::getWritingDataHandlerNumeric:error:(unsigned int bufferId, NSError ** pError)</code></dt>
<dd><p>Retrieve a WritingDataHandlerNumeric object connected to the Tag’s buffer. </p>
<p>If the tag’s VR is not a numeric type then throws std::bad_cast.</p>
<p>The returned WritingDataHandlerNumeric is connected to a new buffer which is updated and stored into the tag when WritingDataHandlerNumeric is destroyed.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>a WritingDataHandlerNumeric object connected to a new Tag’s buffer </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">bufferId</span></code>: the position where the new buffer has to be stored in the tag. The first buffer position is 0 </li>
<li><code class="docutils literal notranslate"><span class="pre">pError</span></code>: set to a NSError derived class in case of error </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="interface_imebra_tag_1a6898c87242e5a7934b12e3d8443bec5a"></span><code class="descname">ImebraWritingDataHandlerNumeric* ImebraTag::getWritingDataHandlerRaw:error:(unsigned int bufferId, NSError ** pError)</code></dt>
<dd><p>Retrieve a WritingDataHandlerNumeric object connected to the Tag’s raw data buffer (8 bit unsigned integers). </p>
<p>If the tag’s VR is not a numeric type then throws std::bad_cast.</p>
<p>The returned WritingDataHandlerNumeric is connected to a new buffer which is updated and stored into the tag when WritingDataHandlerNumeric is destroyed.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>a WritingDataHandlerNumeric object connected to a new Tag’s buffer (the buffer contains raw data of 8 bit integers) </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">bufferId</span></code>: the position where the new buffer has to be stored in the tag. The first buffer position is 0 </li>
<li><code class="docutils literal notranslate"><span class="pre">pError</span></code>: set to a NSError derived class in case of error </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="interface_imebra_tag_1af958392f3776db58487664f41245af22"></span><code class="descname">ImebraStreamReader* ImebraTag::getStreamReader:error:(unsigned int bufferId, NSError ** pError)</code></dt>
<dd><p>Get a StreamReader connected to a buffer’s data. </p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>the streamReader connected to the buffer’s data. </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">bufferId</span></code>: the id of the buffer for which the StreamReader is required. This parameter is usually 0 </li>
<li><code class="docutils literal notranslate"><span class="pre">pError</span></code>: set to a NSError derived class in case of error </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="interface_imebra_tag_1ace252409098091a599db836ecae95619"></span><code class="descname">ImebraStreamWriter* ImebraTag::getStreamWriter:error:(unsigned int bufferId, NSError ** pError)</code></dt>
<dd><p>Get a StreamWriter connected to a buffer’s data. </p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>the StreamWriter connected to the buffer’s data. </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">bufferId</span></code>: the id of the buffer for which the StreamWriter is required. This parameter is usually 0 </li>
<li><code class="docutils literal notranslate"><span class="pre">pError</span></code>: set to a NSError derived class in case of error </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="interface_imebra_tag_1a3021d2b4ba239056007b584be9cc2e82"></span><code class="descname">ImebraDataSet* ImebraTag::getSequenceItem:error:(unsigned int dataSetId, NSError ** pError)</code></dt>
<dd><p>Retrieve an embedded DataSet. </p>
<p>Sequence tags (VR=SQ) store embedded dicom structures.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>the sequence DataSet </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">dataSetId</span></code>: the ID of the sequence item to retrieve. Several sequence items can be embedded in one tag. </li>
<li><code class="docutils literal notranslate"><span class="pre">pError</span></code>: set to a NSError derived class in case of error </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="interface_imebra_tag_1afcf7787e3f363acb90bed9bba4b5c631"></span><code class="descname">BOOL ImebraTag::sequenceItemExists:(unsigned int dataSetId)</code></dt>
<dd><p>Check for the existance of a sequence item. </p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>true if the sequence item exists, false otherwise </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">dataSetId</span></code>: the ID of the sequence item to check for </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="interface_imebra_tag_1a6c8d46954c5f4f713f5875f2be404d01"></span><code class="descname">void ImebraTag::setSequenceItem:dataSet:error:(unsigned int dataSetId, ImebraDataSet  * pDataSet, (swift_error(nonnull_error)) __attribute__)</code></dt>
<dd><p>Insert a sequence item into the Tag. </p>
<p>Several sequence items can be nested one inside each other. When a sequence item is embedded into a Tag, then the tag will have a sequence VR (VR = SQ).</p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">dataSetId</span></code>: the ID of the sequence item </li>
<li><code class="docutils literal notranslate"><span class="pre">pError</span></code>: set to a NSError derived class in case of error </li>
<li><code class="docutils literal notranslate"><span class="pre">dataSet</span></code>: the DataSet containing the sequence item data </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="interface_imebra_tag_1a30aacf1e8b566cffc5f86d9440550547"></span><code class="descname">void ImebraTag::appendSequenceItem:error:(ImebraDataSet  * pDataSet, (swift_error(nonnull_error)) __attribute__)</code></dt>
<dd><p>Append a sequence item into the Tag. </p>
<p>Several sequence items can be nested one inside each other. When a sequence item is embedded into a Tag, then the tag will have a sequence VR (VR = SQ).</p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">dataSet</span></code>: the DataSet containing the sequence item data </li>
<li><code class="docutils literal notranslate"><span class="pre">pError</span></code>: set to a NSError derived class in case of error </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Property</p>
<dl class="member">
<dt>
<span class="target" id="interface_imebra_tag_1a95b2ddf25b04d9c1cb6c892627f5288a"></span><em class="property">property </em><code class="descname">ImebraTag::dataType</code></dt>
<dd><p>Get the tag’s data type. </p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>the tag’s data type </dd>
</dl>
</p>
</dd></dl>

</div>
</dd></dl>

</div>
</div>
</div>
<div class="section" id="data-access">
<h2>Data access<a class="headerlink" href="#data-access" title="Permalink to this headline">¶</a></h2>
<p>The data handler allow to read and write the data stored in the tags.</p>
<p>In order to write data into a tag you can:</p>
<ul class="simple">
<li>use the helper methods in <a class="reference internal" href="#dataset"><span class="std std-ref">DataSet</span></a></li>
<li>obtain a <a class="reference internal" href="#writingdatahandler"><span class="std std-ref">WritingDataHandler</span></a> for the desidered tag and use it to write the data.</li>
</ul>
<p>The <a class="reference internal" href="#writingdatahandler"><span class="std std-ref">WritingDataHandler</span></a> has the advantage of being able to write multiple elements in the <a class="reference internal" href="#tag"><span class="std std-ref">Tag</span></a>, while
the helper methods in the <a class="reference internal" href="#dataset"><span class="std std-ref">DataSet</span></a> can write only the first element.</p>
<p>The <a class="reference internal" href="#writingdatahandler"><span class="std std-ref">WritingDataHandler</span></a> writes all the data into a new buffer, which replaces the old buffer in the <a class="reference internal" href="#tag"><span class="std std-ref">Tag</span></a>
only when the data handler is deleted.</p>
<div class="figure" id="id21" style="width: 100%">
<a class="reference external image-reference" href="_images/sequence_createDataWithDataHandler.jpg"><img alt="Data related classes" src="_images/sequence_createDataWithDataHandler.jpg" /></a>
<p class="caption"><span class="caption-text">Sequence diagram showing how to use a <a class="reference internal" href="#writingdatahandler"><span class="std std-ref">WritingDataHandler</span></a></span></p>
</div>
<div class="section" id="tagid">
<span id="id5"></span><h3>TagId<a class="headerlink" href="#tagid" title="Permalink to this headline">¶</a></h3>
<div class="section" id="id6">
<h4>C++<a class="headerlink" href="#id6" title="Permalink to this headline">¶</a></h4>
<dl class="class">
<dt id="_CPPv3N6imebra5TagIdE">
<span id="_CPPv2N6imebra5TagIdE"></span><span id="imebra::TagId"></span><span class="target" id="classimebra_1_1_tag_id"></span><em class="property">class </em><code class="descname">TagId</code><a class="headerlink" href="#_CPPv3N6imebra5TagIdE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Represents a Dicom tag’s identification. </p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Functions</p>
<dl class="function">
<dt id="_CPPv3N6imebra5TagId5TagIdEv">
<span id="_CPPv2N6imebra5TagId5TagIdEv"></span><span id="imebra::TagId::TagId"></span><span class="target" id="classimebra_1_1_tag_id_1a0f6f102237de0448186e304dd08901b4"></span><code class="descname">TagId</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N6imebra5TagId5TagIdEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Default constructor. </p>
<p>Initializes the group id and the tag id to 0. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N6imebra5TagId5TagIdENSt8uint16_tENSt8uint16_tE">
<span id="_CPPv2N6imebra5TagId5TagIdENSt8uint16_tENSt8uint16_tE"></span><span id="imebra::TagId::TagId__std::uint16_t.std::uint16_t"></span><span class="target" id="classimebra_1_1_tag_id_1a75bd191ce3e71c55ecc90636a8ce58df"></span><code class="descname">TagId</code><span class="sig-paren">(</span>std::uint16_t <em>groupId</em>, std::uint16_t <em>tagId</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N6imebra5TagId5TagIdENSt8uint16_tENSt8uint16_tE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Constructor. </p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">groupId</span></code>: the group id </li>
<li><code class="docutils literal notranslate"><span class="pre">tagId</span></code>: the tag id </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N6imebra5TagId5TagIdENSt8uint16_tENSt8uint32_tENSt8uint16_tE">
<span id="_CPPv2N6imebra5TagId5TagIdENSt8uint16_tENSt8uint32_tENSt8uint16_tE"></span><span id="imebra::TagId::TagId__std::uint16_t.std::uint32_t.std::uint16_t"></span><span class="target" id="classimebra_1_1_tag_id_1a0a5f5ddfa7726cf777087b17d6204e8b"></span><code class="descname">TagId</code><span class="sig-paren">(</span>std::uint16_t <em>groupId</em>, std::uint32_t <em>groupOrder</em>, std::uint16_t <em>tagId</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N6imebra5TagId5TagIdENSt8uint16_tENSt8uint32_tENSt8uint16_tE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Constructor. </p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">groupId</span></code>: the group id </li>
<li><code class="docutils literal notranslate"><span class="pre">groupOrder</span></code>: old DICOM files may have several groups with the same id. This parameter specifies which of the groups with the same id must be taken into consideration </li>
<li><code class="docutils literal notranslate"><span class="pre">tagId</span></code>: the tag id </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N6imebra5TagId5TagIdE7tagId_t">
<span id="_CPPv2N6imebra5TagId5TagIdE7tagId_t"></span><span id="imebra::TagId::TagId__tagId_t"></span><span class="target" id="classimebra_1_1_tag_id_1ad19878723a6f0c8234c56d108e891fad"></span><code class="descname">TagId</code><span class="sig-paren">(</span><a class="reference internal" href="definition_classes.html#_CPPv3N6imebra7tagId_tE" title="imebra::tagId_t">tagId_t</a> <em>id</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N6imebra5TagId5TagIdE7tagId_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Constructor. </p>
<p><dl class="docutils">
<dt><strong>Warning</strong></dt>
<dd>Very large enumeration classes cause an error in Java, therefore the tagId_t enumeration is not supported in Java. </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">id</span></code>: an enumeration representing a tag group and id</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N6imebra5TagId5TagIdE7tagId_tNSt8uint32_tE">
<span id="_CPPv2N6imebra5TagId5TagIdE7tagId_tNSt8uint32_tE"></span><span id="imebra::TagId::TagId__tagId_t.std::uint32_t"></span><span class="target" id="classimebra_1_1_tag_id_1ad2a33774c78d73e060d535d00739140e"></span><code class="descname">TagId</code><span class="sig-paren">(</span><a class="reference internal" href="definition_classes.html#_CPPv3N6imebra7tagId_tE" title="imebra::tagId_t">tagId_t</a> <em>id</em>, std::uint32_t <em>groupOrder</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N6imebra5TagId5TagIdE7tagId_tNSt8uint32_tE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Constructor. </p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">id</span></code>: an enumeration representing a tag group and id </li>
<li><code class="docutils literal notranslate"><span class="pre">groupOrder</span></code>: old DICOM files may have several groups with the same id. This parameter specifies which of the groups with the same id must be taken into consideration </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3NK6imebra5TagId10getGroupIdEv">
<span id="_CPPv2NK6imebra5TagId10getGroupIdEv"></span><span id="imebra::TagId::getGroupIdC"></span><span class="target" id="classimebra_1_1_tag_id_1aba2275b649f6882a9767931dd1b32df7"></span>std::uint16_t <code class="descname">getGroupId</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv3NK6imebra5TagId10getGroupIdEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Retrieve the group id. </p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>the group id </dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3NK6imebra5TagId13getGroupOrderEv">
<span id="_CPPv2NK6imebra5TagId13getGroupOrderEv"></span><span id="imebra::TagId::getGroupOrderC"></span><span class="target" id="classimebra_1_1_tag_id_1a6bf581615bbe8d2c868166bc4fbb7aa8"></span>std::uint32_t <code class="descname">getGroupOrder</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv3NK6imebra5TagId13getGroupOrderEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Return the group order. Old DICOM files may have several groups with the same id. This value specifies which of the groups with the same id has been taken into consideration. </p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>the group order </dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3NK6imebra5TagId8getTagIdEv">
<span id="_CPPv2NK6imebra5TagId8getTagIdEv"></span><span id="imebra::TagId::getTagIdC"></span><span class="target" id="classimebra_1_1_tag_id_1ade25b4abec432fdc46bb58d29eafa110"></span>std::uint16_t <code class="descname">getTagId</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv3NK6imebra5TagId8getTagIdEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Retrieve the tag id. </p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>the tag id </dd>
</dl>
</p>
</dd></dl>

</div>
</dd></dl>

</div>
<div class="section" id="id7">
<h4>Objective-C/Swift<a class="headerlink" href="#id7" title="Permalink to this headline">¶</a></h4>
<dl class="class">
<dt id="_CPPv311ImebraTagId">
<span id="_CPPv211ImebraTagId"></span><span id="ImebraTagId"></span><span class="target" id="interface_imebra_tag_id"></span><em class="property">class </em><code class="descname">ImebraTagId</code> : <em class="property">public</em> NSObject<a class="headerlink" href="#_CPPv311ImebraTagId" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Represents a Dicom tag’s identification. </p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Functions</p>
<dl class="function">
<dt>
<span class="target" id="interface_imebra_tag_id_1a5fe70bbf47f8db18759dbc4914c6fb03"></span><code class="descname">id ImebraTagId::initWithGroup:tag:(unsigned short groupId, unsigned short tagId)</code></dt>
<dd><p>Initializer. </p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">groupId</span></code>: the group id </li>
<li><code class="docutils literal notranslate"><span class="pre">tagId</span></code>: the tag id </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="interface_imebra_tag_id_1aa3ab48ad36a7e579b59909ebce3b2ad0"></span><code class="descname">id ImebraTagId::initWithId:(ImebraTagId_t tagId)</code></dt>
<dd><p>Initializer. </p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">id</span></code>: an enumeration representing a tag group and id </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="interface_imebra_tag_id_1a560adb387a4fdf4d0f835abbb9b6ad39"></span><code class="descname">id ImebraTagId::initWithGroup:groupOrder:tag:(unsigned short groupId, unsigned int groupOrder, unsigned short tagId)</code></dt>
<dd><p>Initializer. </p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">groupId</span></code>: the group id </li>
<li><code class="docutils literal notranslate"><span class="pre">groupOrder</span></code>: old DICOM files may have several groups with the same id. This parameter specifies which of the groups with the same id must be taken into consideration </li>
<li><code class="docutils literal notranslate"><span class="pre">tagId</span></code>: the tag id </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Property</p>
<dl class="member">
<dt>
<span class="target" id="interface_imebra_tag_id_1acdf1c9bda91541a319ec8dab12fb5f54"></span><em class="property">property </em><code class="descname">ImebraTagId::groupId</code></dt>
<dd><p>Retrieve the group id. </p>
</dd></dl>

<dl class="member">
<dt>
<span class="target" id="interface_imebra_tag_id_1a2130a740d4c86c17102e6e2088b29ecd"></span><em class="property">property </em><code class="descname">ImebraTagId::groupOrder</code></dt>
<dd><p>Return the group order. Old DICOM files may have several groups with the same id. This value specifies which of the groups with the same id has been taken into consideration. </p>
</dd></dl>

<dl class="member">
<dt>
<span class="target" id="interface_imebra_tag_id_1a62cfb64e0ec05aa883a2ab54fc02083e"></span><em class="property">property </em><code class="descname">ImebraTagId::tagId</code></dt>
<dd><p>Retrieve the tag id. </p>
</dd></dl>

</div>
</dd></dl>

</div>
</div>
<div class="section" id="readingdatahandler">
<span id="id8"></span><h3>ReadingDataHandler<a class="headerlink" href="#readingdatahandler" title="Permalink to this headline">¶</a></h3>
<div class="section" id="id9">
<h4>C++<a class="headerlink" href="#id9" title="Permalink to this headline">¶</a></h4>
<dl class="class">
<dt id="_CPPv3N6imebra18ReadingDataHandlerE">
<span id="_CPPv2N6imebra18ReadingDataHandlerE"></span><span id="imebra::ReadingDataHandler"></span><span class="target" id="classimebra_1_1_reading_data_handler"></span><em class="property">class </em><code class="descname">ReadingDataHandler</code><a class="headerlink" href="#_CPPv3N6imebra18ReadingDataHandlerE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>The <a class="reference internal" href="#classimebra_1_1_reading_data_handler"><span class="std std-ref">ReadingDataHandler</span></a> class allows reading the content of a Dicom <a class="reference internal" href="#classimebra_1_1_tag"><span class="std std-ref">Tag</span></a>. </p>
<p><a class="reference internal" href="#classimebra_1_1_reading_data_handler"><span class="std std-ref">ReadingDataHandler</span></a> is able to return the <a class="reference internal" href="#classimebra_1_1_tag"><span class="std std-ref">Tag</span></a>’s content as a string, a number, a date/time or an age.</p>
<p>In order to obtain a <a class="reference internal" href="#classimebra_1_1_reading_data_handler"><span class="std std-ref">ReadingDataHandler</span></a> object for a specific <a class="reference internal" href="#classimebra_1_1_tag"><span class="std std-ref">Tag</span></a> stored in a <a class="reference internal" href="#classimebra_1_1_data_set"><span class="std std-ref">DataSet</span></a>, call <a class="reference internal" href="#classimebra_1_1_data_set_1a8ceaeb498e958fe4666a45418de018a7"><span class="std std-ref">DataSet::getReadingDataHandler()</span></a> or <a class="reference internal" href="#classimebra_1_1_tag_1aa5f74d9b8b18a5f167abb8b321fb75ea"><span class="std std-ref">Tag::getReadingDataHandler()</span></a>.</p>
<p>The <a class="reference internal" href="#classimebra_1_1_reading_data_handler"><span class="std std-ref">ReadingDataHandler</span></a> object keeps a reference to the buffer’s memory: the buffer’s memory is never modified but only replaced by a new memory area, therefore the <a class="reference internal" href="#classimebra_1_1_reading_data_handler"><span class="std std-ref">ReadingDataHandler</span></a> client does not need to worry about other clients modifying the memory being read. </p>
<p>Subclassed by <a class="reference internal" href="#classimebra_1_1_reading_data_handler_numeric"><span class="std std-ref">imebra::ReadingDataHandlerNumeric</span></a></p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Functions</p>
<dl class="function">
<dt id="_CPPv3NK6imebra18ReadingDataHandler7getSizeEv">
<span id="_CPPv2NK6imebra18ReadingDataHandler7getSizeEv"></span><span id="imebra::ReadingDataHandler::getSizeC"></span><span class="target" id="classimebra_1_1_reading_data_handler_1a2d8cfaedeaa9052c9ad9f4cdbe953db7"></span>size_t <code class="descname">getSize</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv3NK6imebra18ReadingDataHandler7getSizeEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Returns the number of elements in the <a class="reference internal" href="#classimebra_1_1_tag"><span class="std std-ref">Tag</span></a>’s buffer handled by the data handler. </p>
<p>If the <a class="reference internal" href="#classimebra_1_1_reading_data_handler"><span class="std std-ref">ReadingDataHandler</span></a> object is related to a buffer that contains strings then it returns the number of strings stored in the buffer. Multiple strings are separated by a separator char.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>the number of elements stored in the handled Dicom buffer </dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3NK6imebra18ReadingDataHandler11getDataTypeEv">
<span id="_CPPv2NK6imebra18ReadingDataHandler11getDataTypeEv"></span><span id="imebra::ReadingDataHandler::getDataTypeC"></span><span class="target" id="classimebra_1_1_reading_data_handler_1a345ae68bc9b71ef7de082143981b27f0"></span><a class="reference internal" href="definition_classes.html#_CPPv3N6imebra7tagVR_tE" title="imebra::tagVR_t">tagVR_t</a> <code class="descname">getDataType</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv3NK6imebra18ReadingDataHandler11getDataTypeEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Returns the data type (VR) of the data handled by the data handler. </p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>the data type of the handled data </dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3NK6imebra18ReadingDataHandler13getSignedLongE6size_t">
<span id="_CPPv2NK6imebra18ReadingDataHandler13getSignedLongE6size_t"></span><span id="imebra::ReadingDataHandler::getSignedLong__sC"></span><span class="target" id="classimebra_1_1_reading_data_handler_1a8b5be6aa4f7ef32f3ed8b0f036ea7ba2"></span>std::int32_t <code class="descname">getSignedLong</code><span class="sig-paren">(</span>size_t <em>index</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv3NK6imebra18ReadingDataHandler13getSignedLongE6size_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Retrieve a buffer’s value as signed long integer (32 bit). </p>
<p>If the buffer’s value cannot be converted to a signed long integer then throws <a class="reference internal" href="exception_classes.html#classimebra_1_1_data_handler_conversion_error"><span class="std std-ref">DataHandlerConversionError</span></a>.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>the tag’s value as a signed 32 bit integer </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">index</span></code>: the element number within the buffer. Must be smaller than <a class="reference internal" href="#classimebra_1_1_reading_data_handler_1a2d8cfaedeaa9052c9ad9f4cdbe953db7"><span class="std std-ref">getSize()</span></a> </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3NK6imebra18ReadingDataHandler15getUnsignedLongE6size_t">
<span id="_CPPv2NK6imebra18ReadingDataHandler15getUnsignedLongE6size_t"></span><span id="imebra::ReadingDataHandler::getUnsignedLong__sC"></span><span class="target" id="classimebra_1_1_reading_data_handler_1ad28111aa707511a2a18a1d5a831e4ec4"></span>std::uint32_t <code class="descname">getUnsignedLong</code><span class="sig-paren">(</span>size_t <em>index</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv3NK6imebra18ReadingDataHandler15getUnsignedLongE6size_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Retrieve a buffer’s value as an unsigned long integer (32 bit). </p>
<p>If the buffer’s value cannot be converted to an unsigned long integer then throws <a class="reference internal" href="exception_classes.html#classimebra_1_1_data_handler_conversion_error"><span class="std std-ref">DataHandlerConversionError</span></a>.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>the tag’s value as an unsigned 32 bit integer </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">index</span></code>: the element number within the buffer. Must be smaller than <a class="reference internal" href="#classimebra_1_1_reading_data_handler_1a2d8cfaedeaa9052c9ad9f4cdbe953db7"><span class="std std-ref">getSize()</span></a> </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3NK6imebra18ReadingDataHandler9getDoubleE6size_t">
<span id="_CPPv2NK6imebra18ReadingDataHandler9getDoubleE6size_t"></span><span id="imebra::ReadingDataHandler::getDouble__sC"></span><span class="target" id="classimebra_1_1_reading_data_handler_1a3115b57cf76aaff679f3a703b3c6e48b"></span>double <code class="descname">getDouble</code><span class="sig-paren">(</span>size_t <em>index</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv3NK6imebra18ReadingDataHandler9getDoubleE6size_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Retrieve a buffer’s value as a double floating point value (64 bit). </p>
<p>If the buffer’s value cannot be converted to a double value then throws <a class="reference internal" href="exception_classes.html#classimebra_1_1_data_handler_conversion_error"><span class="std std-ref">DataHandlerConversionError</span></a>.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>the tag’s value as a double floating point value (64 bit) </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">index</span></code>: the element number within the buffer. Must be smaller than <a class="reference internal" href="#classimebra_1_1_reading_data_handler_1a2d8cfaedeaa9052c9ad9f4cdbe953db7"><span class="std std-ref">getSize()</span></a> </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3NK6imebra18ReadingDataHandler9getStringE6size_t">
<span id="_CPPv2NK6imebra18ReadingDataHandler9getStringE6size_t"></span><span id="imebra::ReadingDataHandler::getString__sC"></span><span class="target" id="classimebra_1_1_reading_data_handler_1a1100ec671004eb51f1cfc930b87535f6"></span>std::string <code class="descname">getString</code><span class="sig-paren">(</span>size_t <em>index</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv3NK6imebra18ReadingDataHandler9getStringE6size_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Retrieve a buffer’s value as an ASCII string. </p>
<p>If the buffer’s value cannot be converted to a string then throws <a class="reference internal" href="exception_classes.html#classimebra_1_1_data_handler_conversion_error"><span class="std std-ref">DataHandlerConversionError</span></a>.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>the tag’s value as an ASCII string </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">index</span></code>: the element number within the buffer. Must be smaller than <a class="reference internal" href="#classimebra_1_1_reading_data_handler_1a2d8cfaedeaa9052c9ad9f4cdbe953db7"><span class="std std-ref">getSize()</span></a> </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3NK6imebra18ReadingDataHandler16getUnicodeStringE6size_t">
<span id="_CPPv2NK6imebra18ReadingDataHandler16getUnicodeStringE6size_t"></span><span id="imebra::ReadingDataHandler::getUnicodeString__sC"></span><span class="target" id="classimebra_1_1_reading_data_handler_1ab03dc6a99a99c5ede9159357d84efa45"></span>std::wstring <code class="descname">getUnicodeString</code><span class="sig-paren">(</span>size_t <em>index</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv3NK6imebra18ReadingDataHandler16getUnicodeStringE6size_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Retrieve a buffer’s value as a Unicode string. </p>
<p>If the buffer’s value cannot be converted to a string then throws <a class="reference internal" href="exception_classes.html#classimebra_1_1_data_handler_conversion_error"><span class="std std-ref">DataHandlerConversionError</span></a>.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>the tag’s value as a Unicode string </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">index</span></code>: the element number within the buffer. Must be smaller than <a class="reference internal" href="#classimebra_1_1_reading_data_handler_1a2d8cfaedeaa9052c9ad9f4cdbe953db7"><span class="std std-ref">getSize()</span></a> </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3NK6imebra18ReadingDataHandler7getDateE6size_t">
<span id="_CPPv2NK6imebra18ReadingDataHandler7getDateE6size_t"></span><span id="imebra::ReadingDataHandler::getDate__sC"></span><span class="target" id="classimebra_1_1_reading_data_handler_1a46caccf62666900d045a318cf5a2df8c"></span><a class="reference internal" href="definition_classes.html#_CPPv3N6imebra4DateE" title="imebra::Date">Date</a> <code class="descname">getDate</code><span class="sig-paren">(</span>size_t <em>index</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv3NK6imebra18ReadingDataHandler7getDateE6size_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Retrieve a buffer’s value a date or time. </p>
<p>If the buffer’s value cannot be converted to a date or time then throws <a class="reference internal" href="exception_classes.html#classimebra_1_1_data_handler_conversion_error"><span class="std std-ref">DataHandlerConversionError</span></a>.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>the tag’s value as a date or time </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">index</span></code>: the element number within the buffer. Must be smaller than <a class="reference internal" href="#classimebra_1_1_reading_data_handler_1a2d8cfaedeaa9052c9ad9f4cdbe953db7"><span class="std std-ref">getSize()</span></a> </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3NK6imebra18ReadingDataHandler6getAgeE6size_t">
<span id="_CPPv2NK6imebra18ReadingDataHandler6getAgeE6size_t"></span><span id="imebra::ReadingDataHandler::getAge__sC"></span><span class="target" id="classimebra_1_1_reading_data_handler_1ab3c90948ec8b4bf0038232893957d29d"></span><a class="reference internal" href="definition_classes.html#_CPPv3N6imebra3AgeE" title="imebra::Age">Age</a> <code class="descname">getAge</code><span class="sig-paren">(</span>size_t <em>index</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv3NK6imebra18ReadingDataHandler6getAgeE6size_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Retrieve a buffer’s value as an <a class="reference internal" href="definition_classes.html#structimebra_1_1_age"><span class="std std-ref">Age</span></a>. </p>
<p>If the buffer’s value cannot be converted to an <a class="reference internal" href="definition_classes.html#structimebra_1_1_age"><span class="std std-ref">Age</span></a> then throws <a class="reference internal" href="exception_classes.html#classimebra_1_1_data_handler_conversion_error"><span class="std std-ref">DataHandlerConversionError</span></a>.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>the tag’s value as an <a class="reference internal" href="definition_classes.html#structimebra_1_1_age"><span class="std std-ref">Age</span></a> </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">index</span></code>: the element number within the buffer. Must be smaller than <a class="reference internal" href="#classimebra_1_1_reading_data_handler_1a2d8cfaedeaa9052c9ad9f4cdbe953db7"><span class="std std-ref">getSize()</span></a> </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

</div>
</dd></dl>

</div>
<div class="section" id="id10">
<h4>Objective-C/Swift<a class="headerlink" href="#id10" title="Permalink to this headline">¶</a></h4>
<dl class="class">
<dt id="_CPPv324ImebraReadingDataHandler">
<span id="_CPPv224ImebraReadingDataHandler"></span><span id="ImebraReadingDataHandler"></span><span class="target" id="interface_imebra_reading_data_handler"></span><em class="property">class </em><code class="descname">ImebraReadingDataHandler</code> : <em class="property">public</em> NSObject<a class="headerlink" href="#_CPPv324ImebraReadingDataHandler" title="Permalink to this definition">¶</a><br /></dt>
<dd><p><a class="reference internal" href="#interface_imebra_reading_data_handler"><span class="std std-ref">ImebraReadingDataHandler</span></a> allows reading the content of a Dicom Tag. </p>
<p><a class="reference internal" href="#interface_imebra_reading_data_handler"><span class="std std-ref">ImebraReadingDataHandler</span></a> is able to return the Tag’s content as a string, a number, a date/time or an age.</p>
<p>In order to obtain a <a class="reference internal" href="#interface_imebra_reading_data_handler"><span class="std std-ref">ImebraReadingDataHandler</span></a> object for a specific <a class="reference internal" href="#interface_imebra_tag"><span class="std std-ref">ImebraTag</span></a> stored in a <a class="reference internal" href="#interface_imebra_data_set"><span class="std std-ref">ImebraDataSet</span></a>, call ImebraDataSet::getReadingDataHandler() or ImebraTag::getReadingDataHandler().</p>
<p><a class="reference internal" href="#interface_imebra_reading_data_handler"><span class="std std-ref">ImebraReadingDataHandler</span></a> keeps a reference to the buffer’s memory: the buffer’s memory is never modified but only replaced by a new memory area, therefore the ReadingDataHandler client does not need to worry about other clients modifying the memory being read. </p>
<p>Subclassed by <a class="reference internal" href="#interface_imebra_reading_data_handler_numeric"><span class="std std-ref">ImebraReadingDataHandlerNumeric</span></a></p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Functions</p>
<dl class="function">
<dt>
<span class="target" id="interface_imebra_reading_data_handler_1ac4d0a1b62c244ed6bdf8d41de44f1ea0"></span><code class="descname">int ImebraReadingDataHandler::getSignedLong:error:(unsigned int index, (swift_error(nonnull_error)) __attribute__)</code></dt>
<dd><p>Retrieve a buffer’s value as signed long integer (32 bit). </p>
<p>If the buffer’s value cannot be converted to a signed long integer then set pError to ImebraDataHandlerConversionError.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>the tag’s value as a signed 32 bit integer </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">index</span></code>: the element number within the buffer. Must be smaller than getSize() </li>
<li><code class="docutils literal notranslate"><span class="pre">pError</span></code>: set to a NSError derived class in case of error </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="interface_imebra_reading_data_handler_1a423e0bd54abdb3b6bdf0040d9d49197a"></span><code class="descname">unsigned int ImebraReadingDataHandler::getUnsignedLong:error:(unsigned int index, (swift_error(nonnull_error)) __attribute__)</code></dt>
<dd><p>Retrieve a buffer’s value as an unsigned long integer (32 bit). </p>
<p>If the buffer’s value cannot be converted to a unsigned long integer then set pError to ImebraDataHandlerConversionError.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>the tag’s value as an unsigned 32 bit integer </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">index</span></code>: the element number within the buffer. Must be smaller than getSize() </li>
<li><code class="docutils literal notranslate"><span class="pre">pError</span></code>: set to a NSError derived class in case of error </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="interface_imebra_reading_data_handler_1ab81dad6446a6e688b53ed070eb871e25"></span><code class="descname">double ImebraReadingDataHandler::getDouble:error:(unsigned int index, (swift_error(nonnull_error)) __attribute__)</code></dt>
<dd><p>Retrieve a buffer’s value as a double floating point value (64 bit). </p>
<p>If the buffer’s value cannot be converted to a double floating point then set pError to ImebraDataHandlerConversionError.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>the tag’s value as a double floating point value (64 bit) </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">index</span></code>: the element number within the buffer. Must be smaller than getSize() </li>
<li><code class="docutils literal notranslate"><span class="pre">pError</span></code>: set to a NSError derived class in case of error </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="interface_imebra_reading_data_handler_1a37db53fe23e7c3d009020c18acfd26ae"></span><code class="descname">NSString* ImebraReadingDataHandler::getString:error:(unsigned int index, NSError ** pError)</code></dt>
<dd><p>Retrieve a buffer’s value as a string. </p>
<p>If the buffer’s value cannot be converted to a string then set pError to ImebraDataHandlerConversionError.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>the tag’s value as a string </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">index</span></code>: the element number within the buffer. Must be smaller than getSize() </li>
<li><code class="docutils literal notranslate"><span class="pre">pError</span></code>: set to a NSError derived class in case of error </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="interface_imebra_reading_data_handler_1acebbd07729a319ce85a6f0205667e3a7"></span><code class="descname">ImebraDate* ImebraReadingDataHandler::getDate:error:(unsigned int index, NSError ** pError)</code></dt>
<dd><p>Retrieve a buffer’s value as date or time. </p>
<p>If the buffer’s value cannot be converted to a date or time then set pError to ImebraDataHandlerConversionError.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>the tag’s value as a date or time </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">index</span></code>: the element number within the buffer. Must be smaller than getSize() </li>
<li><code class="docutils literal notranslate"><span class="pre">pError</span></code>: set to a NSError derived class in case of error </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="interface_imebra_reading_data_handler_1a315e6ac4d8826e5b8c486b141b33ebaa"></span><code class="descname">ImebraAge* ImebraReadingDataHandler::getAge:error:(unsigned int index, NSError ** pError)</code></dt>
<dd><p>Retrieve a buffer’s value as an age. </p>
<p>If the buffer’s value cannot be converted to an age then set pError to ImebraDataHandlerConversionError.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>the tag’s value as an Age </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">index</span></code>: the element number within the buffer. Must be smaller than getSize() </li>
<li><code class="docutils literal notranslate"><span class="pre">pError</span></code>: set to a NSError derived class in case of error </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Property</p>
<dl class="member">
<dt>
<span class="target" id="interface_imebra_reading_data_handler_1a50858147be24221dfb1a12d5a816a2e5"></span><em class="property">property </em><code class="descname">ImebraReadingDataHandler::size</code></dt>
<dd><p>Returns the number of elements in the tag’s buffer handled by the data handler. </p>
<p>If the <a class="reference internal" href="#interface_imebra_reading_data_handler"><span class="std std-ref">ImebraReadingDataHandler</span></a> object is related to a buffer that contains strings then it returns the number of strings stored in the buffer. Multiple strings are separated by a separator char. </p>
</dd></dl>

</div>
</dd></dl>

</div>
</div>
<div class="section" id="readingdatahandlernumeric">
<span id="id11"></span><h3>ReadingDataHandlerNumeric<a class="headerlink" href="#readingdatahandlernumeric" title="Permalink to this headline">¶</a></h3>
<div class="section" id="id12">
<h4>C++<a class="headerlink" href="#id12" title="Permalink to this headline">¶</a></h4>
<dl class="class">
<dt id="_CPPv3N6imebra25ReadingDataHandlerNumericE">
<span id="_CPPv2N6imebra25ReadingDataHandlerNumericE"></span><span id="imebra::ReadingDataHandlerNumeric"></span><span class="target" id="classimebra_1_1_reading_data_handler_numeric"></span><em class="property">class </em><code class="descname">ReadingDataHandlerNumeric</code> : <em class="property">public</em> imebra::<a class="reference internal" href="#_CPPv3N6imebra18ReadingDataHandlerE" title="imebra::ReadingDataHandler">ReadingDataHandler</a><a class="headerlink" href="#_CPPv3N6imebra25ReadingDataHandlerNumericE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Specialized <a class="reference internal" href="#classimebra_1_1_reading_data_handler"><span class="std std-ref">ReadingDataHandler</span></a> for numeric data types. </p>
<p>Includes few methods that allow accessing the raw memory containing the buffer’s data. </p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Functions</p>
<dl class="function">
<dt id="_CPPv3NK6imebra25ReadingDataHandlerNumeric9getMemoryEv">
<span id="_CPPv2NK6imebra25ReadingDataHandlerNumeric9getMemoryEv"></span><span id="imebra::ReadingDataHandlerNumeric::getMemoryC"></span><span class="target" id="classimebra_1_1_reading_data_handler_numeric_1ae31b5e6cfbea77767464d921448e857b"></span><a class="reference internal" href="memory_management_classes.html#_CPPv3N6imebra10ReadMemoryE" title="imebra::ReadMemory">ReadMemory</a> *<code class="descname">getMemory</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv3NK6imebra25ReadingDataHandlerNumeric9getMemoryEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Return a <a class="reference internal" href="memory_management_classes.html#classimebra_1_1_read_memory"><span class="std std-ref">ReadMemory</span></a> object referencing the raw buffer’s data. </p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>a <a class="reference internal" href="memory_management_classes.html#classimebra_1_1_read_memory"><span class="std std-ref">ReadMemory</span></a> object referencing the raw buffer’s data </dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3NK6imebra25ReadingDataHandlerNumeric4dataEPc6size_t">
<span id="_CPPv2NK6imebra25ReadingDataHandlerNumeric4dataEPc6size_t"></span><span id="imebra::ReadingDataHandlerNumeric::data__cP.sC"></span><span class="target" id="classimebra_1_1_reading_data_handler_numeric_1a66b4d058c212fa6b904a0d9f577d5cfb"></span>size_t <code class="descname">data</code><span class="sig-paren">(</span>char *<em>destination</em>, size_t <em>destinationSize</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv3NK6imebra25ReadingDataHandlerNumeric4dataEPc6size_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Copies the buffer’s raw memory content into the specified buffer. </p>
<p>If the allocated buffer is not large enough then the method doesn’t copy any data and just returns the required buffer’ size.</p>
<p><strong>Java</strong></p>
<p>In Java this method accepts a single parameter (a byte array). The size of the byte array must be equal or greater than the number of bytes stored by the data handler.</p>
<p><strong>Python</strong></p>
<p>In Python this method accepts a single parameter (an array). The size of the array (in bytes) must be equal or greater than the number of bytes stored by the data handler.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>the number of bytes copied into the pre-allocated buffer, or the desired size of destination if destinationSize is smaller than the return value </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">destination</span></code>: a pointer to the allocated buffer </li>
<li><code class="docutils literal notranslate"><span class="pre">destinationSize</span></code>: the size of the allocated buffer </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3NK6imebra25ReadingDataHandlerNumeric4dataEP6size_t">
<span id="_CPPv2NK6imebra25ReadingDataHandlerNumeric4dataEP6size_t"></span><span id="imebra::ReadingDataHandlerNumeric::data__sPC"></span><span class="target" id="classimebra_1_1_reading_data_handler_numeric_1a08360cb97abb723d6b39cf866b55d992"></span><em class="property">const</em> char *<code class="descname">data</code><span class="sig-paren">(</span>size_t *<em>pDataSize</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv3NK6imebra25ReadingDataHandlerNumeric4dataEP6size_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Returns a pointer to the buffer’s raw memory content. </p>
<p>The referenced buffer is owned by the <a class="reference internal" href="#classimebra_1_1_reading_data_handler_numeric"><span class="std std-ref">ReadingDataHandlerNumeric</span></a> object and must not be freed by the client.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>a pointer to the buffer’s raw memory. The referenced buffer is owned by the <a class="reference internal" href="#classimebra_1_1_reading_data_handler_numeric"><span class="std std-ref">ReadingDataHandlerNumeric</span></a> object and must not be freed by the client. </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">pDataSize</span></code>: a variable that will contain the raw memory’s size in bytes </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3NK6imebra25ReadingDataHandlerNumeric11getUnitSizeEv">
<span id="_CPPv2NK6imebra25ReadingDataHandlerNumeric11getUnitSizeEv"></span><span id="imebra::ReadingDataHandlerNumeric::getUnitSizeC"></span><span class="target" id="classimebra_1_1_reading_data_handler_numeric_1ad6c9cc528fcb75d660ad24315f7ee627"></span>size_t <code class="descname">getUnitSize</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv3NK6imebra25ReadingDataHandlerNumeric11getUnitSizeEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Returns the number of bytes occupied by the numbers handled by the data handler. </p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>the number of bytes occupied by the numbers handled by the data handler </dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3NK6imebra25ReadingDataHandlerNumeric8isSignedEv">
<span id="_CPPv2NK6imebra25ReadingDataHandlerNumeric8isSignedEv"></span><span id="imebra::ReadingDataHandlerNumeric::isSignedC"></span><span class="target" id="classimebra_1_1_reading_data_handler_numeric_1a8a8a3248bc154c3c16624e2f94b4ade4"></span>bool <code class="descname">isSigned</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv3NK6imebra25ReadingDataHandlerNumeric8isSignedEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Returns true if the numbers stored in the buffer are signed, false otherwise. </p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>true if the numbers stored in the buffer are signed, false otherwise </dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3NK6imebra25ReadingDataHandlerNumeric7isFloatEv">
<span id="_CPPv2NK6imebra25ReadingDataHandlerNumeric7isFloatEv"></span><span id="imebra::ReadingDataHandlerNumeric::isFloatC"></span><span class="target" id="classimebra_1_1_reading_data_handler_numeric_1ac88a53a350db036a57e66c26c2e610b7"></span>bool <code class="descname">isFloat</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv3NK6imebra25ReadingDataHandlerNumeric7isFloatEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Returns true if the numbers stored in the buffer are floating point numbers, false otherwise. </p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>true if the numbers stored in the buffer are floating point numbers, false otherwise </dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N6imebra25ReadingDataHandlerNumeric6copyToERK25WritingDataHandlerNumeric">
<span id="_CPPv2N6imebra25ReadingDataHandlerNumeric6copyToERK25WritingDataHandlerNumeric"></span><span id="imebra::ReadingDataHandlerNumeric::copyTo__WritingDataHandlerNumericCR"></span><span class="target" id="classimebra_1_1_reading_data_handler_numeric_1a4d61eb868ecce30246f449ed091a7105"></span>void <code class="descname">copyTo</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv3N6imebra25WritingDataHandlerNumericE" title="imebra::WritingDataHandlerNumeric">WritingDataHandlerNumeric</a> &amp;<em>destination</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N6imebra25ReadingDataHandlerNumeric6copyToERK25WritingDataHandlerNumeric" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Copies the content of the data handler into another data handler, converting the data to the destination handler data type. </p>
<p><dl class="docutils">
<dt><strong>Warning</strong></dt>
<dd>the size of the destination data handler stays unchanged: if the destination too small to contain all the data to be copied then only a part of the data will be copied.</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">destination</span></code>: the destination data handler </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

</div>
</dd></dl>

</div>
<div class="section" id="id13">
<h4>Objective-C/Swift<a class="headerlink" href="#id13" title="Permalink to this headline">¶</a></h4>
<dl class="class">
<dt id="_CPPv331ImebraReadingDataHandlerNumeric">
<span id="_CPPv231ImebraReadingDataHandlerNumeric"></span><span id="ImebraReadingDataHandlerNumeric"></span><span class="target" id="interface_imebra_reading_data_handler_numeric"></span><em class="property">class </em><code class="descname">ImebraReadingDataHandlerNumeric</code> : <em class="property">public</em> <a class="reference internal" href="#_CPPv324ImebraReadingDataHandler" title="ImebraReadingDataHandler">ImebraReadingDataHandler</a><a class="headerlink" href="#_CPPv331ImebraReadingDataHandlerNumeric" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Specialized <a class="reference internal" href="#interface_imebra_reading_data_handler"><span class="std std-ref">ImebraReadingDataHandler</span></a> for numeric data types. </p>
<p>Includes few methods that allow accessing the raw memory containing the buffer’s data. </p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Functions</p>
<dl class="function">
<dt>
<span class="target" id="interface_imebra_reading_data_handler_numeric_1a9545798f9a8eebbe7868d37ddc5990f8"></span><code class="descname">ImebraReadMemory* ImebraReadingDataHandlerNumeric::getMemory:((swift_error(nonnull_error)) __attribute__)</code></dt>
<dd><p>Return a ReadMemory object referencing the raw buffer’s data. </p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>a ReadMemory object referencing the raw buffer’s data </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">pError</span></code>: set to a NSError derived class in case of error </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="interface_imebra_reading_data_handler_numeric_1aac0be2bf4f2f250762185a91416be2cf"></span><code class="descname">void ImebraReadingDataHandlerNumeric::copyTo:error:(ImebraWritingDataHandlerNumeric  * destination, (swift_error(nonnull_error)) __attribute__)</code></dt>
<dd><p>Copies the content of the data handler into another data handler, converting the data to the destination handler data type. </p>
<p><dl class="docutils">
<dt><strong>Warning</strong></dt>
<dd>the size of the destination data handler stays unchanged: if the destination too small to contain all the data to be copied then only a part of the data will be copied.</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">pError</span></code>: set to a NSError derived class in case of error </li>
<li><code class="docutils literal notranslate"><span class="pre">destination</span></code>: the destination data handler </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Property</p>
<dl class="member">
<dt>
<span class="target" id="interface_imebra_reading_data_handler_numeric_1afa336cf845b739b955dbc5234ca2e1e7"></span><em class="property">property </em><code class="descname">ImebraReadingDataHandlerNumeric::unitSize</code></dt>
<dd><p>Returns the number of bytes occupied by the numbers handled by the data handler. </p>
</dd></dl>

<dl class="member">
<dt>
<span class="target" id="interface_imebra_reading_data_handler_numeric_1a0af122cbc10592986142db10b6986a2e"></span><em class="property">property </em><code class="descname">ImebraReadingDataHandlerNumeric::isSigned</code></dt>
<dd><p>Returns true if the numbers stored in the buffer are signed, false otherwise. </p>
</dd></dl>

<dl class="member">
<dt>
<span class="target" id="interface_imebra_reading_data_handler_numeric_1a1a14903be240bda960ae9b4e4990b7ec"></span><em class="property">property </em><code class="descname">ImebraReadingDataHandlerNumeric::isFloat</code></dt>
<dd><p>Returns true if the numbers stored in the buffer are floating point numbers, false otherwise. </p>
</dd></dl>

</div>
</dd></dl>

</div>
</div>
<div class="section" id="writingdatahandler">
<span id="id14"></span><h3>WritingDataHandler<a class="headerlink" href="#writingdatahandler" title="Permalink to this headline">¶</a></h3>
<div class="section" id="id15">
<h4>C++<a class="headerlink" href="#id15" title="Permalink to this headline">¶</a></h4>
<dl class="class">
<dt id="_CPPv3N6imebra18WritingDataHandlerE">
<span id="_CPPv2N6imebra18WritingDataHandlerE"></span><span id="imebra::WritingDataHandler"></span><span class="target" id="classimebra_1_1_writing_data_handler"></span><em class="property">class </em><code class="descname">WritingDataHandler</code><a class="headerlink" href="#_CPPv3N6imebra18WritingDataHandlerE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>The <a class="reference internal" href="#classimebra_1_1_writing_data_handler"><span class="std std-ref">WritingDataHandler</span></a> class allows to write the content of a Dicom tag’s buffer. </p>
<p><a class="reference internal" href="#classimebra_1_1_writing_data_handler"><span class="std std-ref">WritingDataHandler</span></a> is able to write into the buffer’s content strings, numbers, date/time or ages.</p>
<p>In order to obtain a <a class="reference internal" href="#classimebra_1_1_writing_data_handler"><span class="std std-ref">WritingDataHandler</span></a> object for a specific tag stored in a <a class="reference internal" href="#classimebra_1_1_data_set"><span class="std std-ref">DataSet</span></a>, call <a class="reference internal" href="#classimebra_1_1_data_set_1adb58aee90c373a1703f82d56ad5b1fa7"><span class="std std-ref">DataSet::getWritingDataHandler()</span></a> or <a class="reference internal" href="#classimebra_1_1_tag_1adff439da273315a0ae9f64af917b12ce"><span class="std std-ref">Tag::getWritingDataHandler()</span></a>.</p>
<p>The <a class="reference internal" href="#classimebra_1_1_writing_data_handler"><span class="std std-ref">WritingDataHandler</span></a> object always works on a new and clean memory area. The buffer’s memory is replaced by the <a class="reference internal" href="#classimebra_1_1_writing_data_handler"><span class="std std-ref">WritingDataHandler</span></a> memory when the data handler is destroyed. </p>
<p>Subclassed by <a class="reference internal" href="#classimebra_1_1_writing_data_handler_numeric"><span class="std std-ref">imebra::WritingDataHandlerNumeric</span></a></p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Functions</p>
<dl class="function">
<dt id="_CPPv3N6imebra18WritingDataHandlerD0Ev">
<span id="_CPPv2N6imebra18WritingDataHandlerD0Ev"></span><span id="imebra::WritingDataHandler::~WritingDataHandler"></span><span class="target" id="classimebra_1_1_writing_data_handler_1a5ace3e9ba974b35edaae140a7f72a8dd"></span><em class="property">virtual</em> <code class="descname">~WritingDataHandler</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N6imebra18WritingDataHandlerD0Ev" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Destructor: replaces the tag buffer’s memory with the memory created by this <a class="reference internal" href="#classimebra_1_1_writing_data_handler"><span class="std std-ref">WritingDataHandler</span></a>. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N6imebra18WritingDataHandler7setSizeE6size_t">
<span id="_CPPv2N6imebra18WritingDataHandler7setSizeE6size_t"></span><span id="imebra::WritingDataHandler::setSize__s"></span><span class="target" id="classimebra_1_1_writing_data_handler_1a413692734d2094cbb76902e042282c4f"></span>void <code class="descname">setSize</code><span class="sig-paren">(</span>size_t <em>elementsNumber</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N6imebra18WritingDataHandler7setSizeE6size_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Resize the memory to contain the specified number of elements. </p>
<p>By default, the <a class="reference internal" href="#classimebra_1_1_writing_data_handler"><span class="std std-ref">WritingDataHandler</span></a> buffer allocates an empty memory block that must be resized in order to be filled with data.</p>
<p>The type of the contained elements depends on the tag’s VR. The VR can be retrieved with <a class="reference internal" href="#classimebra_1_1_writing_data_handler_1afeb2bcc3d7a1af6a5ea5eb67f91de72b"><span class="std std-ref">getDataType()</span></a>.</p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">elementsNumber</span></code>: the number of elements to store in the buffer. </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3NK6imebra18WritingDataHandler7getSizeEv">
<span id="_CPPv2NK6imebra18WritingDataHandler7getSizeEv"></span><span id="imebra::WritingDataHandler::getSizeC"></span><span class="target" id="classimebra_1_1_writing_data_handler_1a4deb5d45a123e9571f88ec48bf1ac1d4"></span>size_t <code class="descname">getSize</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv3NK6imebra18WritingDataHandler7getSizeEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Retrieve the number of elements that can be stored in the buffer controlled by <a class="reference internal" href="#classimebra_1_1_writing_data_handler"><span class="std std-ref">WritingDataHandler</span></a>. </p>
<p>The memory size can be changed with <a class="reference internal" href="#classimebra_1_1_writing_data_handler_1a413692734d2094cbb76902e042282c4f"><span class="std std-ref">setSize()</span></a>.</p>
<p>The type of the contained elements depends on the tag’s VR. The VR can be retrieved with <a class="reference internal" href="#classimebra_1_1_writing_data_handler_1afeb2bcc3d7a1af6a5ea5eb67f91de72b"><span class="std std-ref">getDataType()</span></a>.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>the number of elements that can be stored in the buffer </dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3NK6imebra18WritingDataHandler11getDataTypeEv">
<span id="_CPPv2NK6imebra18WritingDataHandler11getDataTypeEv"></span><span id="imebra::WritingDataHandler::getDataTypeC"></span><span class="target" id="classimebra_1_1_writing_data_handler_1afeb2bcc3d7a1af6a5ea5eb67f91de72b"></span><a class="reference internal" href="definition_classes.html#_CPPv3N6imebra7tagVR_tE" title="imebra::tagVR_t">tagVR_t</a> <code class="descname">getDataType</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv3NK6imebra18WritingDataHandler11getDataTypeEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Returns the data type (VR) of the data handled by the data handler. </p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>the data type of the handled data </dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N6imebra18WritingDataHandler13setSignedLongE6size_tNSt7int32_tE">
<span id="_CPPv2N6imebra18WritingDataHandler13setSignedLongE6size_tNSt7int32_tE"></span><span id="imebra::WritingDataHandler::setSignedLong__s.std::int32_t"></span><span class="target" id="classimebra_1_1_writing_data_handler_1aebbdfef8ad1edfb312c7cc5a35e18a2a"></span>void <code class="descname">setSignedLong</code><span class="sig-paren">(</span>size_t <em>index</em>, std::int32_t <em>value</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N6imebra18WritingDataHandler13setSignedLongE6size_tNSt7int32_tE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Write a signed long integer (32 bit). </p>
<p>If the value cannot be converted from a signed long integer then throws <a class="reference internal" href="exception_classes.html#classimebra_1_1_data_handler_conversion_error"><span class="std std-ref">DataHandlerConversionError</span></a>.</p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">index</span></code>: the element number within the buffer. Must be smaller than <a class="reference internal" href="#classimebra_1_1_writing_data_handler_1a4deb5d45a123e9571f88ec48bf1ac1d4"><span class="std std-ref">getSize()</span></a> </li>
<li><code class="docutils literal notranslate"><span class="pre">value</span></code>: the value to write </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N6imebra18WritingDataHandler15setUnsignedLongE6size_tNSt8uint32_tE">
<span id="_CPPv2N6imebra18WritingDataHandler15setUnsignedLongE6size_tNSt8uint32_tE"></span><span id="imebra::WritingDataHandler::setUnsignedLong__s.std::uint32_t"></span><span class="target" id="classimebra_1_1_writing_data_handler_1a6e33479a17119d1aa34e230fa86cd43b"></span>void <code class="descname">setUnsignedLong</code><span class="sig-paren">(</span>size_t <em>index</em>, std::uint32_t <em>value</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N6imebra18WritingDataHandler15setUnsignedLongE6size_tNSt8uint32_tE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Write an unsigned long integer (32 bit). </p>
<p>If the value cannot be converted from an unsigned long integer then throws <a class="reference internal" href="exception_classes.html#classimebra_1_1_data_handler_conversion_error"><span class="std std-ref">DataHandlerConversionError</span></a>.</p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">index</span></code>: the element number within the buffer. Must be smaller than <a class="reference internal" href="#classimebra_1_1_writing_data_handler_1a4deb5d45a123e9571f88ec48bf1ac1d4"><span class="std std-ref">getSize()</span></a> </li>
<li><code class="docutils literal notranslate"><span class="pre">value</span></code>: the value to write </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N6imebra18WritingDataHandler9setDoubleE6size_td">
<span id="_CPPv2N6imebra18WritingDataHandler9setDoubleE6size_td"></span><span id="imebra::WritingDataHandler::setDouble__s.double"></span><span class="target" id="classimebra_1_1_writing_data_handler_1a9694a54a6cb41fbe599b68afad06fda9"></span>void <code class="descname">setDouble</code><span class="sig-paren">(</span>size_t <em>index</em>, double <em>value</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N6imebra18WritingDataHandler9setDoubleE6size_td" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Write a double floating point value (64 bit). </p>
<p>If the value cannot be converted from a double floating point then throws <a class="reference internal" href="exception_classes.html#classimebra_1_1_data_handler_conversion_error"><span class="std std-ref">DataHandlerConversionError</span></a>.</p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">index</span></code>: the element number within the buffer. Must be smaller than <a class="reference internal" href="#classimebra_1_1_writing_data_handler_1a4deb5d45a123e9571f88ec48bf1ac1d4"><span class="std std-ref">getSize()</span></a> </li>
<li><code class="docutils literal notranslate"><span class="pre">value</span></code>: the value to write </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N6imebra18WritingDataHandler9setStringE6size_tRKNSt6stringE">
<span id="_CPPv2N6imebra18WritingDataHandler9setStringE6size_tRKNSt6stringE"></span><span id="imebra::WritingDataHandler::setString__s.ssCR"></span><span class="target" id="classimebra_1_1_writing_data_handler_1aa33cc25f450fabfccf661651b23fa9a0"></span>void <code class="descname">setString</code><span class="sig-paren">(</span>size_t <em>index</em>, <em class="property">const</em> std::string &amp;<em>value</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N6imebra18WritingDataHandler9setStringE6size_tRKNSt6stringE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Write a string. </p>
<p>If the value cannot be converted from a string then throws <a class="reference internal" href="exception_classes.html#classimebra_1_1_data_handler_conversion_error"><span class="std std-ref">DataHandlerConversionError</span></a>.</p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">index</span></code>: the element number within the buffer. Must be smaller than <a class="reference internal" href="#classimebra_1_1_writing_data_handler_1a4deb5d45a123e9571f88ec48bf1ac1d4"><span class="std std-ref">getSize()</span></a> </li>
<li><code class="docutils literal notranslate"><span class="pre">value</span></code>: the value to write </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N6imebra18WritingDataHandler16setUnicodeStringE6size_tRKNSt7wstringE">
<span id="_CPPv2N6imebra18WritingDataHandler16setUnicodeStringE6size_tRKNSt7wstringE"></span><span id="imebra::WritingDataHandler::setUnicodeString__s.std::wstringCR"></span><span class="target" id="classimebra_1_1_writing_data_handler_1af31ab17196c1cd5aadfb0ef04dc155ac"></span>void <code class="descname">setUnicodeString</code><span class="sig-paren">(</span>size_t <em>index</em>, <em class="property">const</em> std::wstring &amp;<em>value</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N6imebra18WritingDataHandler16setUnicodeStringE6size_tRKNSt7wstringE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Write an Unicode string. </p>
<p>If the value cannot be converted from a Unicode string then throws <a class="reference internal" href="exception_classes.html#classimebra_1_1_data_handler_conversion_error"><span class="std std-ref">DataHandlerConversionError</span></a>.</p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">index</span></code>: the element number within the buffer. Must be smaller than <a class="reference internal" href="#classimebra_1_1_writing_data_handler_1a4deb5d45a123e9571f88ec48bf1ac1d4"><span class="std std-ref">getSize()</span></a> </li>
<li><code class="docutils literal notranslate"><span class="pre">value</span></code>: the value to write </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N6imebra18WritingDataHandler7setDateE6size_tRK4Date">
<span id="_CPPv2N6imebra18WritingDataHandler7setDateE6size_tRK4Date"></span><span id="imebra::WritingDataHandler::setDate__s.DateCR"></span><span class="target" id="classimebra_1_1_writing_data_handler_1abb744a7256dbbb8e4468c561f20dc579"></span>void <code class="descname">setDate</code><span class="sig-paren">(</span>size_t <em>index</em>, <em class="property">const</em> <a class="reference internal" href="definition_classes.html#_CPPv3N6imebra4DateE" title="imebra::Date">Date</a> &amp;<em>date</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N6imebra18WritingDataHandler7setDateE6size_tRK4Date" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Write a date and/or a time. </p>
<p>If the value cannot be converted from a <a class="reference internal" href="definition_classes.html#structimebra_1_1_date"><span class="std std-ref">Date</span></a> then throws <a class="reference internal" href="exception_classes.html#classimebra_1_1_data_handler_conversion_error"><span class="std std-ref">DataHandlerConversionError</span></a>.</p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">index</span></code>: the element number within the buffer. Must be smaller than <a class="reference internal" href="#classimebra_1_1_writing_data_handler_1a4deb5d45a123e9571f88ec48bf1ac1d4"><span class="std std-ref">getSize()</span></a> </li>
<li><code class="docutils literal notranslate"><span class="pre">date</span></code>: the value to write </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N6imebra18WritingDataHandler6setAgeE6size_tRK3Age">
<span id="_CPPv2N6imebra18WritingDataHandler6setAgeE6size_tRK3Age"></span><span id="imebra::WritingDataHandler::setAge__s.AgeCR"></span><span class="target" id="classimebra_1_1_writing_data_handler_1aa0c1f4ff7ff62f052f1c6f1537abcbc1"></span>void <code class="descname">setAge</code><span class="sig-paren">(</span>size_t <em>index</em>, <em class="property">const</em> <a class="reference internal" href="definition_classes.html#_CPPv3N6imebra3AgeE" title="imebra::Age">Age</a> &amp;<em>age</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N6imebra18WritingDataHandler6setAgeE6size_tRK3Age" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Write an <a class="reference internal" href="definition_classes.html#structimebra_1_1_age"><span class="std std-ref">Age</span></a> value. </p>
<p>If the value cannot be converted from an <a class="reference internal" href="definition_classes.html#structimebra_1_1_age"><span class="std std-ref">Age</span></a> then throws <a class="reference internal" href="exception_classes.html#classimebra_1_1_data_handler_conversion_error"><span class="std std-ref">DataHandlerConversionError</span></a>.</p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">index</span></code>: the element number within the buffer. Must be smaller than <a class="reference internal" href="#classimebra_1_1_writing_data_handler_1a4deb5d45a123e9571f88ec48bf1ac1d4"><span class="std std-ref">getSize()</span></a> </li>
<li><code class="docutils literal notranslate"><span class="pre">age</span></code>: the value to write </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

</div>
</dd></dl>

</div>
<div class="section" id="id16">
<h4>Objective-C/Swift<a class="headerlink" href="#id16" title="Permalink to this headline">¶</a></h4>
<dl class="class">
<dt id="_CPPv324ImebraWritingDataHandler">
<span id="_CPPv224ImebraWritingDataHandler"></span><span id="ImebraWritingDataHandler"></span><span class="target" id="interface_imebra_writing_data_handler"></span><em class="property">class </em><code class="descname">ImebraWritingDataHandler</code> : <em class="property">public</em> NSObject<a class="headerlink" href="#_CPPv324ImebraWritingDataHandler" title="Permalink to this definition">¶</a><br /></dt>
<dd><p><a class="reference internal" href="#interface_imebra_writing_data_handler"><span class="std std-ref">ImebraWritingDataHandler</span></a> allows to write the content of a Dicom tag’s buffer. </p>
<p><a class="reference internal" href="#interface_imebra_writing_data_handler"><span class="std std-ref">ImebraWritingDataHandler</span></a> is able to write strings, numbers, date/time or ages.</p>
<p>In order to obtain a <a class="reference internal" href="#interface_imebra_writing_data_handler"><span class="std std-ref">ImebraWritingDataHandler</span></a> object for a specific tag call ImebraDataSet::getWritingDataHandler() or ImebraTag::getWritingDataHandler().</p>
<p>The <a class="reference internal" href="#interface_imebra_writing_data_handler"><span class="std std-ref">ImebraWritingDataHandler</span></a> object always works on a new and clean memory area. Once the data has been written into the data handler then call <a class="reference internal" href="#interface_imebra_writing_data_handler_1a734758aa34feabf927a24def4a784103"><span class="std std-ref">commit (ImebraWritingDataHandler)</span></a> in order to commit the data. The data is committed also when the data handler is deallocated.</p>
<p>Once the data has been committed then the data handler does not respond to further data modifications. </p>
<p>Subclassed by <a class="reference internal" href="#interface_imebra_writing_data_handler_numeric"><span class="std std-ref">ImebraWritingDataHandlerNumeric</span></a></p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Functions</p>
<dl class="function">
<dt>
<span class="target" id="interface_imebra_writing_data_handler_1ac1b2e706e7d81303c70bcd051bde76ed"></span><code class="descname">void ImebraWritingDataHandler::setSignedLong:newValue:error:(unsigned int index, int value, (swift_error(nonnull_error)) __attribute__)</code></dt>
<dd><p>Write a signed long integer (32 bit). </p>
<p>If the value cannot be converted from a signed long integer then set pError to ImebraDataHandlerConversionError.</p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">index</span></code>: the element number within the buffer. Must be smaller than <a class="reference internal" href="#interface_imebra_writing_data_handler_1a833230c586a55841265a455eba5fd53e"><span class="std std-ref">size()</span></a> </li>
<li><code class="docutils literal notranslate"><span class="pre">value</span></code>: the value to write </li>
<li><code class="docutils literal notranslate"><span class="pre">pError</span></code>: set to a NSError derived class in case of error </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="interface_imebra_writing_data_handler_1a1359d435579c43951d00f76e5a2aca5a"></span><code class="descname">void ImebraWritingDataHandler::setUnsignedLong:newValue:error:(unsigned int index, unsigned int value, (swift_error(nonnull_error)) __attribute__)</code></dt>
<dd><p>Write an unsigned long integer (32 bit). </p>
<p>If the value cannot be converted from an unsigned long integer then set pError to ImebraDataHandlerConversionError.</p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">index</span></code>: the element number within the buffer. Must be smaller than <a class="reference internal" href="#interface_imebra_writing_data_handler_1a833230c586a55841265a455eba5fd53e"><span class="std std-ref">size()</span></a> </li>
<li><code class="docutils literal notranslate"><span class="pre">value</span></code>: the value to write </li>
<li><code class="docutils literal notranslate"><span class="pre">pError</span></code>: set to a NSError derived class in case of error </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="interface_imebra_writing_data_handler_1ac148ac3a49de1418ec538b07fd92d816"></span><code class="descname">void ImebraWritingDataHandler::setDouble:newValue:error:(unsigned int index, double value, (swift_error(nonnull_error)) __attribute__)</code></dt>
<dd><p>Write a double floating point value (64 bit). </p>
<p>If the value cannot be converted from a double floating point then set pError to ImebraDataHandlerConversionError.</p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">index</span></code>: the element number within the buffer. Must be smaller than <a class="reference internal" href="#interface_imebra_writing_data_handler_1a833230c586a55841265a455eba5fd53e"><span class="std std-ref">size()</span></a> </li>
<li><code class="docutils literal notranslate"><span class="pre">value</span></code>: the value to write </li>
<li><code class="docutils literal notranslate"><span class="pre">pError</span></code>: set to a NSError derived class in case of error </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="interface_imebra_writing_data_handler_1ac04f5d2b07751534a583528dfa6198c8"></span><code class="descname">void ImebraWritingDataHandler::setString:newValue:error:(unsigned int index, NSString * value, (swift_error(nonnull_error)) __attribute__)</code></dt>
<dd><p>Write a string. </p>
<p>If the value cannot be converted from a string then set pError to ImebraDataHandlerConversionError.</p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">index</span></code>: the element number within the buffer. Must be smaller than <a class="reference internal" href="#interface_imebra_writing_data_handler_1a833230c586a55841265a455eba5fd53e"><span class="std std-ref">size()</span></a> </li>
<li><code class="docutils literal notranslate"><span class="pre">value</span></code>: the value to write </li>
<li><code class="docutils literal notranslate"><span class="pre">pError</span></code>: set to a NSError derived class in case of error </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="interface_imebra_writing_data_handler_1aaadbb13aa9568c0fe0da83c2e316c36a"></span><code class="descname">void ImebraWritingDataHandler::setDate:newValue:error:(unsigned int index, ImebraDate * value, (swift_error(nonnull_error)) __attribute__)</code></dt>
<dd><p>Write a date and/or a time. </p>
<p>If the value cannot be converted from a Date then set pError to ImebraDataHandlerConversionError.</p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">index</span></code>: the element number within the buffer. Must be smaller than <a class="reference internal" href="#interface_imebra_writing_data_handler_1a833230c586a55841265a455eba5fd53e"><span class="std std-ref">size()</span></a> </li>
<li><code class="docutils literal notranslate"><span class="pre">value</span></code>: the value to write </li>
<li><code class="docutils literal notranslate"><span class="pre">pError</span></code>: set to a NSError derived class in case of error </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="interface_imebra_writing_data_handler_1a391f4229227460077c4fdf576ef1a62f"></span><code class="descname">void ImebraWritingDataHandler::setAge:newValue:error:(unsigned int index, ImebraAge  * value, (swift_error(nonnull_error)) __attribute__)</code></dt>
<dd><p>Write an Age value. </p>
<p>If the value cannot be converted from an Age then set pError to ImebraDataHandlerConversionError.</p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">index</span></code>: the element number within the buffer. Must be smaller than <a class="reference internal" href="#interface_imebra_writing_data_handler_1a833230c586a55841265a455eba5fd53e"><span class="std std-ref">size()</span></a> </li>
<li><code class="docutils literal notranslate"><span class="pre">value</span></code>: the value to write </li>
<li><code class="docutils literal notranslate"><span class="pre">pError</span></code>: set to a NSError derived class in case of error </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N24ImebraWritingDataHandler6commitEv">
<span id="_CPPv2N24ImebraWritingDataHandler6commitEv"></span><span id="ImebraWritingDataHandler::commit"></span><span class="target" id="interface_imebra_writing_data_handler_1a734758aa34feabf927a24def4a784103"></span>void <code class="descname">commit</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N24ImebraWritingDataHandler6commitEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Commit the changes to the handler’s memory. </p>
</dd></dl>

</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Property</p>
<dl class="member">
<dt>
<span class="target" id="interface_imebra_writing_data_handler_1a833230c586a55841265a455eba5fd53e"></span><em class="property">property </em><code class="descname">ImebraWritingDataHandler::size</code></dt>
<dd><p>Resize the memory to contain the specified number of elements or return the current number of elements when read. </p>
<p>By default, <a class="reference internal" href="#interface_imebra_writing_data_handler"><span class="std std-ref">ImebraWritingDataHandler</span></a> allocates an empty memory block that must be resized in order to be filled with data. </p>
</dd></dl>

</div>
</dd></dl>

</div>
</div>
<div class="section" id="writingdatahandlernumeric">
<span id="id17"></span><h3>WritingDataHandlerNumeric<a class="headerlink" href="#writingdatahandlernumeric" title="Permalink to this headline">¶</a></h3>
<div class="section" id="id18">
<h4>C++<a class="headerlink" href="#id18" title="Permalink to this headline">¶</a></h4>
<dl class="class">
<dt id="_CPPv3N6imebra25WritingDataHandlerNumericE">
<span id="_CPPv2N6imebra25WritingDataHandlerNumericE"></span><span id="imebra::WritingDataHandlerNumeric"></span><span class="target" id="classimebra_1_1_writing_data_handler_numeric"></span><em class="property">class </em><code class="descname">WritingDataHandlerNumeric</code> : <em class="property">public</em> imebra::<a class="reference internal" href="#_CPPv3N6imebra18WritingDataHandlerE" title="imebra::WritingDataHandler">WritingDataHandler</a><a class="headerlink" href="#_CPPv3N6imebra25WritingDataHandlerNumericE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Specialized <a class="reference internal" href="#classimebra_1_1_writing_data_handler"><span class="std std-ref">WritingDataHandler</span></a> for numeric data types. </p>
<p>Includes few methods that allow accessing the raw memory containing the buffer’s data. </p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Functions</p>
<dl class="function">
<dt id="_CPPv3NK6imebra25WritingDataHandlerNumeric9getMemoryEv">
<span id="_CPPv2NK6imebra25WritingDataHandlerNumeric9getMemoryEv"></span><span id="imebra::WritingDataHandlerNumeric::getMemoryC"></span><span class="target" id="classimebra_1_1_writing_data_handler_numeric_1a5fd74cf77d68633d2c5f0db85aeb411d"></span><a class="reference internal" href="memory_management_classes.html#_CPPv3N6imebra15ReadWriteMemoryE" title="imebra::ReadWriteMemory">ReadWriteMemory</a> *<code class="descname">getMemory</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv3NK6imebra25WritingDataHandlerNumeric9getMemoryEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Return a <a class="reference internal" href="memory_management_classes.html#classimebra_1_1_read_write_memory"><span class="std std-ref">ReadWriteMemory</span></a> object referencing the raw buffer’s data. </p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>a <a class="reference internal" href="memory_management_classes.html#classimebra_1_1_read_write_memory"><span class="std std-ref">ReadWriteMemory</span></a> object referencing the raw buffer’s data </dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N6imebra25WritingDataHandlerNumeric6assignEPKc6size_t">
<span id="_CPPv2N6imebra25WritingDataHandlerNumeric6assignEPKc6size_t"></span><span id="imebra::WritingDataHandlerNumeric::assign__cCP.s"></span><span class="target" id="classimebra_1_1_writing_data_handler_numeric_1a41a31fa7c7f9103c32e70129dc48c7fb"></span>void <code class="descname">assign</code><span class="sig-paren">(</span><em class="property">const</em> char *<em>source</em>, size_t <em>sourceSize</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N6imebra25WritingDataHandlerNumeric6assignEPKc6size_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Copy the content of the specified buffer into the content managed by data handler. </p>
<p><strong>Java</strong></p>
<p>In Java this method accepts a single parameter (a byte array).</p>
<p><strong>Python</strong></p>
<p>In Python this method accepts a single parameter (an array).</p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">source</span></code>: a pointer to the source memory buffer </li>
<li><code class="docutils literal notranslate"><span class="pre">sourceSize</span></code>: the number of bytes to copy and the new memory size </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3NK6imebra25WritingDataHandlerNumeric4dataEP6size_t">
<span id="_CPPv2NK6imebra25WritingDataHandlerNumeric4dataEP6size_t"></span><span id="imebra::WritingDataHandlerNumeric::data__sPC"></span><span class="target" id="classimebra_1_1_writing_data_handler_numeric_1ac50c9d2638d1a3aebc7af04d215f7756"></span>char *<code class="descname">data</code><span class="sig-paren">(</span>size_t *<em>pDataSize</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv3NK6imebra25WritingDataHandlerNumeric4dataEP6size_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Returns a pointer to the buffer’s raw memory content. </p>
<p>The referenced buffer is owned by the <a class="reference internal" href="#classimebra_1_1_writing_data_handler_numeric"><span class="std std-ref">WritingDataHandlerNumeric</span></a> object and must not be freed by the client.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>a pointer to the buffer’s raw memory. The referenced buffer is owned by the <a class="reference internal" href="#classimebra_1_1_writing_data_handler_numeric"><span class="std std-ref">WritingDataHandlerNumeric</span></a> object and must not be freed by the client </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">pDataSize</span></code>: a variable that will contain the raw memory’s size in bytes </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3NK6imebra25WritingDataHandlerNumeric4dataEPc6size_t">
<span id="_CPPv2NK6imebra25WritingDataHandlerNumeric4dataEPc6size_t"></span><span id="imebra::WritingDataHandlerNumeric::data__cP.sC"></span><span class="target" id="classimebra_1_1_writing_data_handler_numeric_1a71da89e6b67864a512c70eafa2616a61"></span>size_t <code class="descname">data</code><span class="sig-paren">(</span>char *<em>destination</em>, size_t <em>destinationSize</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv3NK6imebra25WritingDataHandlerNumeric4dataEPc6size_t" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Copies the raw memory content into the specified buffer. </p>
<p>If the allocated buffer is not large enough then the method doesn’t copy any data and just returns the required buffer’ size.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>the number of bytes to be copied into the pre-allocated buffer </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">destination</span></code>: a pointer to the allocated buffer </li>
<li><code class="docutils literal notranslate"><span class="pre">destinationSize</span></code>: the size of the allocated buffer, in bytes </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3NK6imebra25WritingDataHandlerNumeric11getUnitSizeEv">
<span id="_CPPv2NK6imebra25WritingDataHandlerNumeric11getUnitSizeEv"></span><span id="imebra::WritingDataHandlerNumeric::getUnitSizeC"></span><span class="target" id="classimebra_1_1_writing_data_handler_numeric_1ad1fa0a2b87bb8fa1aea36b9a2011ad6f"></span>size_t <code class="descname">getUnitSize</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv3NK6imebra25WritingDataHandlerNumeric11getUnitSizeEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Returns the number of bytes occupied by the numbers handled by the data handler. </p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>the number of bytes occupied by the numbers handled by the data handler </dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3NK6imebra25WritingDataHandlerNumeric8isSignedEv">
<span id="_CPPv2NK6imebra25WritingDataHandlerNumeric8isSignedEv"></span><span id="imebra::WritingDataHandlerNumeric::isSignedC"></span><span class="target" id="classimebra_1_1_writing_data_handler_numeric_1a2d9c90cbcb41cdbd4f96554937ae3d1c"></span>bool <code class="descname">isSigned</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv3NK6imebra25WritingDataHandlerNumeric8isSignedEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Returns true if the numbers handled by the data handler are signed, false otherwise. </p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>true if the numbers handled by the data handler are signed, false otherwise </dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3NK6imebra25WritingDataHandlerNumeric7isFloatEv">
<span id="_CPPv2NK6imebra25WritingDataHandlerNumeric7isFloatEv"></span><span id="imebra::WritingDataHandlerNumeric::isFloatC"></span><span class="target" id="classimebra_1_1_writing_data_handler_numeric_1a6fd6138bb01f83e092837117f6919292"></span>bool <code class="descname">isFloat</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv3NK6imebra25WritingDataHandlerNumeric7isFloatEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Returns true if the numbers stored in the buffer are floating point numbers, false otherwise. </p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>true if the numbers stored in the buffer are floating point numbers, false otherwise </dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N6imebra25WritingDataHandlerNumeric8copyFromERK25ReadingDataHandlerNumeric">
<span id="_CPPv2N6imebra25WritingDataHandlerNumeric8copyFromERK25ReadingDataHandlerNumeric"></span><span id="imebra::WritingDataHandlerNumeric::copyFrom__ReadingDataHandlerNumericCR"></span><span class="target" id="classimebra_1_1_writing_data_handler_numeric_1a05b81477969c5da01eb8dfaac52bc894"></span>void <code class="descname">copyFrom</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="#_CPPv3N6imebra25ReadingDataHandlerNumericE" title="imebra::ReadingDataHandlerNumeric">ReadingDataHandlerNumeric</a> &amp;<em>source</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N6imebra25WritingDataHandlerNumeric8copyFromERK25ReadingDataHandlerNumeric" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Copies data from another data handler, converting the data type if necessary. </p>
<p>The data handler is resized to the same size of the source data handler.</p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">source</span></code>: the data handler from which the data must be copied </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

</div>
</dd></dl>

</div>
<div class="section" id="id19">
<h4>Objective-C/Swift<a class="headerlink" href="#id19" title="Permalink to this headline">¶</a></h4>
<dl class="class">
<dt id="_CPPv331ImebraWritingDataHandlerNumeric">
<span id="_CPPv231ImebraWritingDataHandlerNumeric"></span><span id="ImebraWritingDataHandlerNumeric"></span><span class="target" id="interface_imebra_writing_data_handler_numeric"></span><em class="property">class </em><code class="descname">ImebraWritingDataHandlerNumeric</code> : <em class="property">public</em> <a class="reference internal" href="#_CPPv324ImebraWritingDataHandler" title="ImebraWritingDataHandler">ImebraWritingDataHandler</a><a class="headerlink" href="#_CPPv331ImebraWritingDataHandlerNumeric" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Specialized <a class="reference internal" href="#interface_imebra_writing_data_handler"><span class="std std-ref">ImebraWritingDataHandler</span></a> for numeric data types. </p>
<p>Includes few methods that allow accessing the raw memory containing the buffer’s data. </p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Functions</p>
<dl class="function">
<dt>
<span class="target" id="interface_imebra_writing_data_handler_numeric_1a2100e0cc304ba2b09195adc69572b988"></span><code class="descname">ImebraReadWriteMemory* ImebraWritingDataHandlerNumeric::getMemory:(NSError ** pError)</code></dt>
<dd><p>Return a <a class="reference internal" href="memory_management_classes.html#interface_imebra_read_write_memory"><span class="std std-ref">ImebraReadWriteMemory</span></a> object referencing the raw buffer’s data. </p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>a <a class="reference internal" href="memory_management_classes.html#interface_imebra_read_write_memory"><span class="std std-ref">ImebraReadWriteMemory</span></a> object referencing the raw buffer’s data </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">pError</span></code>: set to a NSError derived class in case of error </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="interface_imebra_writing_data_handler_numeric_1adfa67160900f3c05bd37c45b2e97d68a"></span><code class="descname">void ImebraWritingDataHandlerNumeric::assign:error:(NSData * pSource, (swift_error(nonnull_error)) __attribute__)</code></dt>
<dd><p>Copy the content of the specified buffer into the content managed by data handler. </p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">pSource</span></code>: a pointer to the source memory buffer </li>
<li><code class="docutils literal notranslate"><span class="pre">pError</span></code>: set to a NSError derived class in case of error </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="interface_imebra_writing_data_handler_numeric_1a608bed6025a5d44519fa103421843422"></span><code class="descname">void ImebraWritingDataHandlerNumeric::copyFrom:error:(ImebraReadingDataHandlerNumeric  * pSource, (swift_error(nonnull_error)) __attribute__)</code></dt>
<dd><p>Copies data from another data handler, converting the data type if necessary. </p>
<p>The data handler is resized to the same size of the source data handler.</p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">pSource</span></code>: the data handler from which the data must be copied </li>
<li><code class="docutils literal notranslate"><span class="pre">pError</span></code>: set to a NSError derived class in case of error </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Property</p>
<dl class="member">
<dt>
<span class="target" id="interface_imebra_writing_data_handler_numeric_1aad95d95838dccd4c015597a689731f4f"></span><em class="property">property </em><code class="descname">ImebraWritingDataHandlerNumeric::unitSize</code></dt>
<dd><p>Returns the number of bytes occupied by each number handled by the data handler. </p>
</dd></dl>

<dl class="member">
<dt>
<span class="target" id="interface_imebra_writing_data_handler_numeric_1ae3be940c7be0709b30de4f740c26e80f"></span><em class="property">property </em><code class="descname">ImebraWritingDataHandlerNumeric::isSigned</code></dt>
<dd><p>Returns true if the numbers handled by the data handler are signed, false otherwise. </p>
</dd></dl>

<dl class="member">
<dt>
<span class="target" id="interface_imebra_writing_data_handler_numeric_1a6f962049cf53dfb49233bf30beef4791"></span><em class="property">property </em><code class="descname">ImebraWritingDataHandlerNumeric::isFloat</code></dt>
<dd><p>Returns true if the numbers stored in the buffer are floating point numbers, false otherwise. </p>
</dd></dl>

</div>
</dd></dl>

</div>
</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="stream_classes.html" class="btn btn-neutral float-right" title="Stream classes" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="objects_lifecycle.html" class="btn btn-neutral" title="Objects lifecycle and Object ownership" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; <a href="copyright.html">Copyright</a> 2016, Paolo Brandoli.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'./',
            VERSION:'4.5.2.1',
            LANGUAGE:'None',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true,
            SOURCELINK_SUFFIX: '.txt'
        };
    </script>
      <script type="text/javascript" src="_static/jquery.js"></script>
      <script type="text/javascript" src="_static/underscore.js"></script>
      <script type="text/javascript" src="_static/doctools.js"></script>

  

  <script type="text/javascript" src="_static/js/theme.js"></script>

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>