<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - extracted.info - library/include/imebra/definitions.h</title>
  <link rel="stylesheet" type="text/css" href="../../../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../../../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../../../index.html">top level</a> - <a href="index.html">library/include/imebra</a> - definitions.h<span style="font-size: 80%;"> (source / <a href="definitions.h.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">extracted.info</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">1</td>
            <td class="headerCovTableEntry">1</td>
            <td class="headerCovTableEntryHi">100.0 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2019-03-13 14:48:54</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">4</td>
            <td class="headerCovTableEntry">4</td>
            <td class="headerCovTableEntryHi">100.0 %</td>
          </tr>
          <tr><td><img src="../../../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../../../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : /*</a>
<span class="lineNum">       2 </span>            : Copyright 2005 - 2017 by Paolo Brandoli/Binarno s.p.
<span class="lineNum">       3 </span>            : 
<span class="lineNum">       4 </span>            : Imebra is available for free under the GNU General Public License.
<span class="lineNum">       5 </span>            : 
<span class="lineNum">       6 </span>            : The full text of the license is available in the file license.rst
<span class="lineNum">       7 </span>            :  in the project root folder.
<span class="lineNum">       8 </span>            : 
<span class="lineNum">       9 </span>            : If you do not want to be bound by the GPL terms (such as the requirement 
<span class="lineNum">      10 </span>            :  that your application must also be GPL), you may purchase a commercial 
<span class="lineNum">      11 </span>            :  license for Imebra from the Imebraâ€™s website (http://imebra.com).
<span class="lineNum">      12 </span>            : */
<span class="lineNum">      13 </span>            : 
<span class="lineNum">      14 </span>            : /*! \file definitions.h
<span class="lineNum">      15 </span>            :     \brief Declaration of the enumeration classes and custom types.
<span class="lineNum">      16 </span>            : */
<span class="lineNum">      17 </span>            : 
<span class="lineNum">      18 </span>            : #if !defined(imebraDefinitions__INCLUDED_)
<span class="lineNum">      19 </span>            : #define imebraDefinitions__INCLUDED_
<span class="lineNum">      20 </span>            : 
<span class="lineNum">      21 </span>            : #include &lt;cstdint&gt;
<span class="lineNum">      22 </span>            : #include &lt;vector&gt;
<span class="lineNum">      23 </span>            : #include &lt;string&gt;
<span class="lineNum">      24 </span>            : #include &quot;tagsEnumeration.h&quot;
<span class="lineNum">      25 </span>            : 
<span class="lineNum">      26 </span>            : #ifndef SWIG
<span class="lineNum">      27 </span>            : 
<span class="lineNum">      28 </span>            : // Generic helper definitions for shared library support
<span class="lineNum">      29 </span>            : #if defined _WIN32 || defined __CYGWIN__
<span class="lineNum">      30 </span>            :   #define IMEBRA_HELPER_DLL_IMPORT __declspec(dllimport)
<span class="lineNum">      31 </span>            :   #define IMEBRA_HELPER_DLL_EXPORT __declspec(dllexport)
<span class="lineNum">      32 </span>            :   #pragma warning(disable: 4275)
<span class="lineNum">      33 </span>            :   #pragma warning(disable: 4251)
<span class="lineNum">      34 </span>            : #else
<span class="lineNum">      35 </span>            :   #if __GNUC__ &gt;= 4
<span class="lineNum">      36 </span>            :     #define IMEBRA_HELPER_DLL_IMPORT __attribute__ ((visibility (&quot;default&quot;)))
<span class="lineNum">      37 </span>            :     #define IMEBRA_HELPER_DLL_EXPORT __attribute__ ((visibility (&quot;default&quot;)))
<span class="lineNum">      38 </span>            :   #else
<span class="lineNum">      39 </span>            :     #define IMEBRA_HELPER_DLL_IMPORT
<span class="lineNum">      40 </span>            :     #define IMEBRA_HELPER_DLL_EXPORT
<span class="lineNum">      41 </span>            :   #endif
<span class="lineNum">      42 </span>            : #endif
<span class="lineNum">      43 </span>            : 
<span class="lineNum">      44 </span>            : // IMEBRA_API is used for the public API symbols
<span class="lineNum">      45 </span>            : 
<span class="lineNum">      46 </span>            : #ifdef IMEBRA_DLL // defined if Imebra is compiled as a DLL
<span class="lineNum">      47 </span>            :   #ifdef IMEBRA_DLL_EXPORTS // defined if we are building the Imebra DLL (instead of using it)
<span class="lineNum">      48 </span>            :     #define IMEBRA_API IMEBRA_HELPER_DLL_EXPORT
<span class="lineNum">      49 </span>            :   #else
<span class="lineNum">      50 </span>            :     #define IMEBRA_API IMEBRA_HELPER_DLL_IMPORT
<span class="lineNum">      51 </span>            :   #endif // IMEBRA_DLL_EXPORTS
<span class="lineNum">      52 </span>            : #else // IMEBRA_DLL is not defined: this means Imebra is a static lib.
<span class="lineNum">      53 </span>            :   #define IMEBRA_API
<span class="lineNum">      54 </span>            : #endif // IMEBRA_DLL
<span class="lineNum">      55 </span>            : 
<span class="lineNum">      56 </span>            : #endif // SWIG
<span class="lineNum">      57 </span>            : 
<span class="lineNum">      58 </span>            : namespace imebra
<span class="lineNum">      59 </span>            : {
<span class="lineNum">      60 </span>            : 
<span class="lineNum">      61 </span>            : ///
<span class="lineNum">      62 </span>            : /// \brief Used by setAge() and getAge() to specify the unit of the age value.
<span class="lineNum">      63 </span>            : ///
<span class="lineNum">      64 </span>            : ///////////////////////////////////////////////////////////////////////////////
<span class="lineNum">      65 </span>            : enum class ageUnit_t: char
<span class="lineNum">      66 </span>            : {
<span class="lineNum">      67 </span>            :     days = 'D',   ///&lt; the age value is in days
<span class="lineNum">      68 </span>            :     weeks = 'W',  ///&lt; the age value is in weeks
<span class="lineNum">      69 </span>            :     months = 'M', ///&lt; the age value is in months
<span class="lineNum">      70 </span>            :     years = 'Y'   ///&lt; the age value is in years
<span class="lineNum">      71 </span>            : };
<span class="lineNum">      72 </span>            : 
<span class="lineNum">      73 </span>            : 
<span class="lineNum">      74 </span>            : ///
<span class="lineNum">      75 </span>            : ///
<span class="lineNum">      76 </span>            : /// \brief This enumeration specifies the quality of the compressed image
<span class="lineNum">      77 </span>            : ///        when a lossy compression format is used.
<span class="lineNum">      78 </span>            : ///
<span class="lineNum">      79 </span>            : ///////////////////////////////////////////////////////////////////////////////
<span class="lineNum">      80 </span>            : enum class imageQuality_t: std::uint32_t
<span class="lineNum">      81 </span>            : {
<span class="lineNum">      82 </span>            :     veryHigh = 0,      ///&lt; the image is saved with very high quality. No subsampling is performed and no quantization
<span class="lineNum">      83 </span>            :     high = 100,        ///&lt; the image is saved with high quality. No subsampling is performed. Quantization ratios are low
<span class="lineNum">      84 </span>            :     aboveMedium = 200, ///&lt; the image is saved in medium quality. Horizontal subsampling is applied. Quantization ratios are low
<span class="lineNum">      85 </span>            :     medium = 300,      ///&lt; the image is saved in medium quality. Horizontal subsampling is applied. Quantization ratios are medium
<span class="lineNum">      86 </span>            :     belowMedium = 400, ///&lt; the image is saved in medium quality. Horizontal and vertical subsampling are applied. Quantization ratios are medium
<span class="lineNum">      87 </span>            :     low = 500,         ///&lt; the image is saved in low quality. Horizontal and vertical subsampling are applied. Quantization ratios are higher than the ratios used in the belowMedium quality
<span class="lineNum">      88 </span>            :     veryLow = 600          ///&lt; the image is saved in low quality. Horizontal and vertical subsampling are applied. Quantization ratios are high
<span class="lineNum">      89 </span>            : };
<span class="lineNum">      90 </span>            : 
<span class="lineNum">      91 </span>            : 
<span class="lineNum">      92 </span>            : ///
<span class="lineNum">      93 </span>            : /// \brief Defines the size (in bytes) of the memory allocated for each
<span class="lineNum">      94 </span>            : ///        pixel's color component and its representation (signed/unsigned).
<span class="lineNum">      95 </span>            : ///
<span class="lineNum">      96 </span>            : /// This enumeration does not specify the highest bit used:
<span class="lineNum">      97 </span>            : /// in order to retrieve the highest used bit call Image::getHighBit().
<span class="lineNum">      98 </span>            : ///
<span class="lineNum">      99 </span>            : /// The lower bit of the enumerations is 1 if it represents a signed depth,
<span class="lineNum">     100 </span>            : /// 0 if it represents an unsigned depth,
<span class="lineNum">     101 </span>            : ///
<span class="lineNum">     102 </span>            : ///////////////////////////////////////////////////////////////////////////////
<span class="lineNum">     103 </span>            : enum class bitDepth_t: std::uint32_t
<span class="lineNum">     104 </span>            : {
<span class="lineNum">     105 </span>            :     depthU8 = 0,    ///&lt; Unsigned byte
<span class="lineNum">     106 </span>            :     depthS8 = 1,    ///&lt; Signed byte
<span class="lineNum">     107 </span>            :     depthU16 = 2,   ///&lt; Unsigned word (2 bytes)
<span class="lineNum">     108 </span>            :     depthS16 = 3,   ///&lt; Signed word (2 bytes)
<span class="lineNum">     109 </span>            :     depthU32 = 4,   ///&lt; Unsigned double word (4 bytes)
<span class="lineNum">     110 </span>            :     depthS32 = 5    ///&lt; Signed double word (4 bytes)
<span class="lineNum">     111 </span>            : };
<span class="lineNum">     112 </span>            : 
<span class="lineNum">     113 </span>            : 
<span class="lineNum">     114 </span>            : ///
<span class="lineNum">     115 </span>            : /// \brief Specifies the directory item's type.
<span class="lineNum">     116 </span>            : ///
<span class="lineNum">     117 </span>            : ///////////////////////////////////////////////////////////////////////////////
<span class="lineNum">     118 </span>            : enum class directoryRecordType_t: std::uint32_t
<span class="lineNum">     119 </span>            : {
<span class="lineNum">     120 </span>            :     patient,
<span class="lineNum">     121 </span>            :     study,
<span class="lineNum">     122 </span>            :     series,
<span class="lineNum">     123 </span>            :     image,
<span class="lineNum">     124 </span>            :     overlay,
<span class="lineNum">     125 </span>            :     modality_lut,
<span class="lineNum">     126 </span>            :     voi_lut,
<span class="lineNum">     127 </span>            :     curve,
<span class="lineNum">     128 </span>            :     topic,
<span class="lineNum">     129 </span>            :     visit,
<span class="lineNum">     130 </span>            :     results,
<span class="lineNum">     131 </span>            :     interpretation,
<span class="lineNum">     132 </span>            :     study_component,
<span class="lineNum">     133 </span>            :     stored_print,
<span class="lineNum">     134 </span>            :     rt_dose,
<span class="lineNum">     135 </span>            :     rt_structure_set,
<span class="lineNum">     136 </span>            :     rt_plan,
<span class="lineNum">     137 </span>            :     rt_treat_record,
<span class="lineNum">     138 </span>            :     presentation,
<span class="lineNum">     139 </span>            :     waveform,
<span class="lineNum">     140 </span>            :     sr_document,
<span class="lineNum">     141 </span>            :     key_object_doc,
<span class="lineNum">     142 </span>            :     spectroscopy,
<span class="lineNum">     143 </span>            :     raw_data,
<span class="lineNum">     144 </span>            :     registration,
<span class="lineNum">     145 </span>            :     fiducial,
<span class="lineNum">     146 </span>            :     mrdr,
<span class="lineNum">     147 </span>            :     endOfDirectoryRecordTypes
<span class="lineNum">     148 </span>            : };
<span class="lineNum">     149 </span>            : 
<span class="lineNum">     150 </span>            : 
<span class="lineNum">     151 </span>            : ///
<span class="lineNum">     152 </span>            : /// \brief Defines the data stream &amp; images codec.
<span class="lineNum">     153 </span>            : ///
<span class="lineNum">     154 </span>            : ///////////////////////////////////////////////////////////////////////////////
<span class="lineNum">     155 </span>            : enum class codecType_t: std::uint32_t
<span class="lineNum">     156 </span>            : {
<span class="lineNum">     157 </span>            :     dicom, ///&lt; DICOM codec
<span class="lineNum">     158 </span>            :     jpeg   ///&lt; JPEG codec
<span class="lineNum">     159 </span>            : };
<span class="lineNum">     160 </span>            : 
<span class="lineNum">     161 </span>            : #define MAKE_VR_ENUM(string) ((std::uint16_t)((((std::uint16_t)string[0]) &lt;&lt; 8) | (std::uint16_t)string[1]))
<span class="lineNum">     162 </span>            : 
<span class="lineNum">     163 </span>            : /// \brief Enumerates the DICOM VRs (data types).
<span class="lineNum">     164 </span>            : ///
<span class="lineNum">     165 </span>            : ///////////////////////////////////////////////////////////////////////////////
<span class="lineNum">     166 </span>            : enum class tagVR_t: std::uint32_t
<span class="lineNum">     167 </span>            : {
<span class="lineNum">     168 </span>            :     AE = 0x4145, ///&lt; Application Entity
<span class="lineNum">     169 </span>            :     AS = 0x4153, ///&lt; Age String
<span class="lineNum">     170 </span>            :     AT = 0x4154, ///&lt; Attribute Tag
<span class="lineNum">     171 </span>            :     CS = 0x4353, ///&lt; Code String
<span class="lineNum">     172 </span>            :     DA = 0x4441, ///&lt; Date
<span class="lineNum">     173 </span>            :     DS = 0x4453, ///&lt; Decimal String
<span class="lineNum">     174 </span>            :     DT = 0x4454, ///&lt; Date Time
<span class="lineNum">     175 </span>            :     FL = 0x464c, ///&lt; Floating Point Single
<span class="lineNum">     176 </span>            :     FD = 0x4644, ///&lt; Floating Point Double
<span class="lineNum">     177 </span>            :     IS = 0x4953, ///&lt; Integer String
<span class="lineNum">     178 </span>            :     LO = 0x4c4f, ///&lt; Long String
<span class="lineNum">     179 </span>            :     LT = 0x4c54, ///&lt; Long Text
<span class="lineNum">     180 </span>            :     OB = 0x4f42, ///&lt; Other Byte String
<span class="lineNum">     181 </span>            :     SB = 0x5342, ///&lt; Non standard. Used internally for signed bytes
<span class="lineNum">     182 </span>            :     OD = 0x4f44, ///&lt; Other Double String
<span class="lineNum">     183 </span>            :     OF = 0x4f46, ///&lt; Other Float String
<span class="lineNum">     184 </span>            :     OL = 0x4f4c, ///&lt; Other Long String
<span class="lineNum">     185 </span>            :     OW = 0x4f57, ///&lt; Other Word String
<span class="lineNum">     186 </span>            :     PN = 0x504e, ///&lt; Person Name
<span class="lineNum">     187 </span>            :     SH = 0x5348, ///&lt; Short String
<span class="lineNum">     188 </span>            :     SL = 0x534c, ///&lt; Signed Long
<span class="lineNum">     189 </span>            :     SQ = 0x5351, ///&lt; Sequence of Items
<span class="lineNum">     190 </span>            :     SS = 0x5353, ///&lt; Signed Short
<span class="lineNum">     191 </span>            :     ST = 0x5354, ///&lt; Short Text
<span class="lineNum">     192 </span>            :     TM = 0x544d, ///&lt; Time
<span class="lineNum">     193 </span>            :     UC = 0x5543, ///&lt; Unlimited characters
<span class="lineNum">     194 </span>            :     UI = 0x5549, ///&lt; Unique Identifier
<span class="lineNum">     195 </span>            :     UL = 0x554c, ///&lt; Unsigned Long
<span class="lineNum">     196 </span>            :     UN = 0x554e, ///&lt; Unknown
<span class="lineNum">     197 </span>            :     UR = 0x5552, ///&lt; Unified Resource Identifier
<span class="lineNum">     198 </span>            :     US = 0x5553, ///&lt; Unsigned Short
<span class="lineNum">     199 </span>            :     UT = 0x5554  ///&lt; Unlimited Text
<span class="lineNum">     200 </span>            : };
<span class="lineNum">     201 </span>            : 
<span class="lineNum">     202 </span>            : #ifndef SWIG
<span class="lineNum">     203 </span>            : static_assert((std::uint16_t)tagVR_t::AE == MAKE_VR_ENUM(&quot;AE&quot;), &quot;Wrong VR enumeration value&quot;);
<span class="lineNum">     204 </span>            : static_assert((std::uint16_t)tagVR_t::AS == MAKE_VR_ENUM(&quot;AS&quot;), &quot;Wrong VR enumeration value&quot;);
<span class="lineNum">     205 </span>            : static_assert((std::uint16_t)tagVR_t::AT == MAKE_VR_ENUM(&quot;AT&quot;), &quot;Wrong VR enumeration value&quot;);
<span class="lineNum">     206 </span>            : static_assert((std::uint16_t)tagVR_t::CS == MAKE_VR_ENUM(&quot;CS&quot;), &quot;Wrong VR enumeration value&quot;);
<span class="lineNum">     207 </span>            : static_assert((std::uint16_t)tagVR_t::DA == MAKE_VR_ENUM(&quot;DA&quot;), &quot;Wrong VR enumeration value&quot;);
<span class="lineNum">     208 </span>            : static_assert((std::uint16_t)tagVR_t::DS == MAKE_VR_ENUM(&quot;DS&quot;), &quot;Wrong VR enumeration value&quot;);
<span class="lineNum">     209 </span>            : static_assert((std::uint16_t)tagVR_t::DT == MAKE_VR_ENUM(&quot;DT&quot;), &quot;Wrong VR enumeration value&quot;);
<span class="lineNum">     210 </span>            : static_assert((std::uint16_t)tagVR_t::FL == MAKE_VR_ENUM(&quot;FL&quot;), &quot;Wrong VR enumeration value&quot;);
<span class="lineNum">     211 </span>            : static_assert((std::uint16_t)tagVR_t::FD == MAKE_VR_ENUM(&quot;FD&quot;), &quot;Wrong VR enumeration value&quot;);
<span class="lineNum">     212 </span>            : static_assert((std::uint16_t)tagVR_t::IS == MAKE_VR_ENUM(&quot;IS&quot;), &quot;Wrong VR enumeration value&quot;);
<span class="lineNum">     213 </span>            : static_assert((std::uint16_t)tagVR_t::LO == MAKE_VR_ENUM(&quot;LO&quot;), &quot;Wrong VR enumeration value&quot;);
<span class="lineNum">     214 </span>            : static_assert((std::uint16_t)tagVR_t::LT == MAKE_VR_ENUM(&quot;LT&quot;), &quot;Wrong VR enumeration value&quot;);
<span class="lineNum">     215 </span>            : static_assert((std::uint16_t)tagVR_t::OB == MAKE_VR_ENUM(&quot;OB&quot;), &quot;Wrong VR enumeration value&quot;);
<span class="lineNum">     216 </span>            : static_assert((std::uint16_t)tagVR_t::SB == MAKE_VR_ENUM(&quot;SB&quot;), &quot;Wrong VR enumeration value&quot;);
<span class="lineNum">     217 </span>            : static_assert((std::uint16_t)tagVR_t::OD == MAKE_VR_ENUM(&quot;OD&quot;), &quot;Wrong VR enumeration value&quot;);
<span class="lineNum">     218 </span>            : static_assert((std::uint16_t)tagVR_t::OF == MAKE_VR_ENUM(&quot;OF&quot;), &quot;Wrong VR enumeration value&quot;);
<span class="lineNum">     219 </span>            : static_assert((std::uint16_t)tagVR_t::OL == MAKE_VR_ENUM(&quot;OL&quot;), &quot;Wrong VR enumeration value&quot;);
<span class="lineNum">     220 </span>            : static_assert((std::uint16_t)tagVR_t::OW == MAKE_VR_ENUM(&quot;OW&quot;), &quot;Wrong VR enumeration value&quot;);
<span class="lineNum">     221 </span>            : static_assert((std::uint16_t)tagVR_t::PN == MAKE_VR_ENUM(&quot;PN&quot;), &quot;Wrong VR enumeration value&quot;);
<span class="lineNum">     222 </span>            : static_assert((std::uint16_t)tagVR_t::SH == MAKE_VR_ENUM(&quot;SH&quot;), &quot;Wrong VR enumeration value&quot;);
<span class="lineNum">     223 </span>            : static_assert((std::uint16_t)tagVR_t::SL == MAKE_VR_ENUM(&quot;SL&quot;), &quot;Wrong VR enumeration value&quot;);
<span class="lineNum">     224 </span>            : static_assert((std::uint16_t)tagVR_t::SQ == MAKE_VR_ENUM(&quot;SQ&quot;), &quot;Wrong VR enumeration value&quot;);
<span class="lineNum">     225 </span>            : static_assert((std::uint16_t)tagVR_t::SS == MAKE_VR_ENUM(&quot;SS&quot;), &quot;Wrong VR enumeration value&quot;);
<span class="lineNum">     226 </span>            : static_assert((std::uint16_t)tagVR_t::ST == MAKE_VR_ENUM(&quot;ST&quot;), &quot;Wrong VR enumeration value&quot;);
<span class="lineNum">     227 </span>            : static_assert((std::uint16_t)tagVR_t::TM == MAKE_VR_ENUM(&quot;TM&quot;), &quot;Wrong VR enumeration value&quot;);
<span class="lineNum">     228 </span>            : static_assert((std::uint16_t)tagVR_t::UC == MAKE_VR_ENUM(&quot;UC&quot;), &quot;Wrong VR enumeration value&quot;);
<span class="lineNum">     229 </span>            : static_assert((std::uint16_t)tagVR_t::UI == MAKE_VR_ENUM(&quot;UI&quot;), &quot;Wrong VR enumeration value&quot;);
<span class="lineNum">     230 </span>            : static_assert((std::uint16_t)tagVR_t::UL == MAKE_VR_ENUM(&quot;UL&quot;), &quot;Wrong VR enumeration value&quot;);
<span class="lineNum">     231 </span>            : static_assert((std::uint16_t)tagVR_t::UN == MAKE_VR_ENUM(&quot;UN&quot;), &quot;Wrong VR enumeration value&quot;);
<span class="lineNum">     232 </span>            : static_assert((std::uint16_t)tagVR_t::UR == MAKE_VR_ENUM(&quot;UR&quot;), &quot;Wrong VR enumeration value&quot;);
<span class="lineNum">     233 </span>            : static_assert((std::uint16_t)tagVR_t::US == MAKE_VR_ENUM(&quot;US&quot;), &quot;Wrong VR enumeration value&quot;);
<span class="lineNum">     234 </span>            : static_assert((std::uint16_t)tagVR_t::UT == MAKE_VR_ENUM(&quot;UT&quot;), &quot;Wrong VR enumeration value&quot;);
<span class="lineNum">     235 </span>            : #endif
<span class="lineNum">     236 </span>            : 
<span class="lineNum">     237 </span>            : 
<span class="lineNum">     238 </span>            : typedef std::vector&lt;std::string&gt; fileParts_t;
<span class="lineNum">     239 </span>            : 
<span class="lineNum">     240 </span>            : typedef std::vector&lt;std::string&gt; charsetsList_t;
<span class="lineNum">     241 </span>            : 
<span class="lineNum">     242 </span>            : 
<span class="lineNum">     243 </span>            : ///
<span class="lineNum">     244 </span>            : /// \brief Defines the type of the bitmap generated by DrawBitmap.
<span class="lineNum">     245 </span>            : ///
<span class="lineNum">     246 </span>            : ///////////////////////////////////////////////////////////////////////////////
<span class="lineNum">     247 </span>            : enum class drawBitmapType_t: std::uint32_t
<span class="lineNum">     248 </span>            : {
<span class="lineNum">     249 </span>            :     drawBitmapRGB  = 0, ///&lt; Generates a BMP image where each pixel contains 3 bytes (R, G and B)
<span class="lineNum">     250 </span>            :     drawBitmapBGR  = 1, ///&lt; Generates a BMP image where each pixel contains 3 bytes (B, G and R)
<span class="lineNum">     251 </span>            :     drawBitmapRGBA = 2, ///&lt; Generates a BMP image where each pixel contains 4 bytes (R, G, B and A)
<span class="lineNum">     252 </span>            :     drawBitmapBGRA = 3  ///&lt; Generates a BMP image where each pixel contains 4 bytes (B, G, R and A)
<span class="lineNum">     253 </span>            : };
<span class="lineNum">     254 </span>            : 
<span class="lineNum">     255 </span>            : 
<span class="lineNum">     256 </span>            : ///
<span class="lineNum">     257 </span>            : /// \brief Specifies an age, in days, weeks, months or years.
<span class="lineNum">     258 </span>            : ///
<span class="lineNum">     259 </span>            : ///////////////////////////////////////////////////////////////////////////////
<span class="lineNum">     260 </span>            : struct IMEBRA_API Age
<span class="lineNum">     261 </span>            : {
<span class="lineNum">     262 </span>            :     /// \brief Constructor.
<span class="lineNum">     263 </span>            :     ///
<span class="lineNum">     264 </span>            :     /// \param initialAge the initial age to assign to the object, in days, weeks,
<span class="lineNum">     265 </span>            :     ///                   months or years, depending on the parameter initialUnits
<span class="lineNum">     266 </span>            :     /// \param initialUnits the units of the value in initialAge
<span class="lineNum">     267 </span>            :     ///
<span class="lineNum">     268 </span>            :     ///////////////////////////////////////////////////////////////////////////////
<span class="lineNum">     269 </span>            :     Age(std::uint32_t initialAge, ageUnit_t initialUnits);
<span class="lineNum">     270 </span>            : 
<span class="lineNum">     271 </span>            :     /// \brief Return the age in years.
<span class="lineNum">     272 </span>            :     ///
<span class="lineNum">     273 </span>            :     /// \return the stored age converted to years.
<span class="lineNum">     274 </span>            :     ///
<span class="lineNum">     275 </span>            :     ///////////////////////////////////////////////////////////////////////////////
<span class="lineNum">     276 </span>            :     double years() const;
<span class="lineNum">     277 </span>            : 
<span class="lineNum">     278 </span>            :     std::uint32_t age;   ///&lt; The age, in days, weeks, months or years according to units
<span class="lineNum">     279 </span>            :     ageUnit_t     units; ///&lt; The units of the value in age
<span class="lineNum">     280 </span>            : 
<span class="lineNum">     281 </span>            : };
<span class="lineNum">     282 </span>            : 
<span class="lineNum">     283 </span>            : 
<span class="lineNum">     284 </span>            : ///
<span class="lineNum">     285 </span>            : /// \brief Stores a Date, Time or Date/Time value.
<span class="lineNum">     286 </span>            : ///
<span class="lineNum">     287 </span>            : ///////////////////////////////////////////////////////////////////////////////
<span class="lineNum">     288 </span>            : struct IMEBRA_API Date
<span class="lineNum">     289 </span>            : {
<span class="lineNum">     290 </span>            :     /// \brief Constructor.
<span class="lineNum">     291 </span>            :     ///
<span class="lineNum">     292 </span>            :     /// Initialize the Date structure with the specified values.
<span class="lineNum">     293 </span>            :     ///
<span class="lineNum">     294 </span>            :     /// \param initialYear    year (0 = unused)
<span class="lineNum">     295 </span>            :     /// \param initialMonth   month (1...12, 0 = unused)
<span class="lineNum">     296 </span>            :     /// \param initialDay     day of the month (1...31, 0 = unused)
<span class="lineNum">     297 </span>            :     /// \param initialHour    hour (0...23)
<span class="lineNum">     298 </span>            :     /// \param initialMinutes minutes (0...59)
<span class="lineNum">     299 </span>            :     /// \param initialSeconds seconds (0...59)
<span class="lineNum">     300 </span>            :     /// \param initialNanoseconds nanoseconds
<span class="lineNum">     301 </span>            :     /// \param initialOffsetHours   hours offset from UTC
<span class="lineNum">     302 </span>            :     /// \param initialOffsetMinutes minutes offset from UTC
<span class="lineNum">     303 </span>            :     ///////////////////////////////////////////////////////////////////////////////
<span class="lineNum">     304 </span>            :     Date(const std::uint32_t initialYear,
<span class="lineNum">     305 </span>            :          const std::uint32_t initialMonth,
<span class="lineNum">     306 </span>            :          const std::uint32_t initialDay,
<span class="lineNum">     307 </span>            :          const std::uint32_t initialHour,
<span class="lineNum">     308 </span>            :          const std::uint32_t initialMinutes,
<span class="lineNum">     309 </span>            :          const std::uint32_t initialSeconds,
<span class="lineNum">     310 </span>            :          const std::uint32_t initialNanoseconds,
<span class="lineNum">     311 </span>            :          const std::int32_t initialOffsetHours,
<span class="lineNum">     312 </span>            :          const std::int32_t initialOffsetMinutes);
<span class="lineNum">     313 </span>            : 
<span class="lineNum">     314 </span>            :     std::uint32_t year;         ///&lt; Year (0 = unused)
<span class="lineNum">     315 </span>            :     std::uint32_t month;        ///&lt; Month (1...12, 0 = unused)
<span class="lineNum">     316 </span>            :     std::uint32_t day;          ///&lt; Day (1...12, 0 = unused)
<span class="lineNum">     317 </span>            :     std::uint32_t hour;         ///&lt; Hours
<span class="lineNum">     318 </span>            :     std::uint32_t minutes;      ///&lt; Minutes
<span class="lineNum">     319 </span>            :     std::uint32_t seconds;      ///&lt; Seconds
<span class="lineNum">     320 </span>            :     std::uint32_t nanoseconds;  ///&lt; Nanoseconds
<span class="lineNum">     321 </span>            :     std::int32_t offsetHours;   ///&lt; Offset hours from UTC
<span class="lineNum">     322 </span>            :     std::int32_t offsetMinutes; ///&lt; Offset minutes from UTC
<span class="lineNum">     323 </span>            : 
<span class="lineNum">     324 </span>            : };
<span class="lineNum">     325 </span>            : 
<span class="lineNum">     326 </span>            : ///
<span class="lineNum">     327 </span>            : /// \brief Stores a VOI Description and Settings
<span class="lineNum">     328 </span>            : ///
<span class="lineNum">     329 </span>            : /// The VOI settings can be retrieved from a DataSet with DataSet::getVOIs(),
<span class="lineNum">     330 </span>            : /// which returns all the VOI settings registered in the DataSet.
<span class="lineNum">     331 </span>            : ///
<span class="lineNum">     332 </span>            : /// Once retrieved, the VOI center and width can be passed to the VOILUT
<span class="lineNum">     333 </span>            : /// transform that apply the VOI settings to an Image.
<a name="334"><span class="lineNum">     334 </span>            : ///</a>
<span class="lineNum">     335 </span>            : ///////////////////////////////////////////////////////////////////////////////
<span class="lineNum">     336 </span><span class="lineCov">         14 : struct IMEBRA_API VOIDescription</span>
<span class="lineNum">     337 </span>            : {
<span class="lineNum">     338 </span>            :     double center;            ///&lt; The VOI center
<span class="lineNum">     339 </span>            :     double width;             ///&lt; The VOI width
<span class="lineNum">     340 </span>            :     std::wstring description; ///&lt; The VOI's description
<span class="lineNum">     341 </span>            : };
<span class="lineNum">     342 </span>            : 
<span class="lineNum">     343 </span>            : /// \brief A collection of VOI settings.
<span class="lineNum">     344 </span>            : ///
<span class="lineNum">     345 </span>            : /// The VOI settings registered in the dataset can be retrieved with
<span class="lineNum">     346 </span>            : /// DataSet::getVOIs().
<span class="lineNum">     347 </span>            : ///
<span class="lineNum">     348 </span>            : ///////////////////////////////////////////////////////////////////////////////
<span class="lineNum">     349 </span>            : typedef std::vector&lt;VOIDescription&gt; vois_t;
<span class="lineNum">     350 </span>            : 
<span class="lineNum">     351 </span>            : 
<span class="lineNum">     352 </span>            : ///
<span class="lineNum">     353 </span>            : /// \brief DIMSE command types.
<span class="lineNum">     354 </span>            : ///
<span class="lineNum">     355 </span>            : ///////////////////////////////////////////////////////////////////////////////
<span class="lineNum">     356 </span>            : enum class dimseCommandType_t: std::uint16_t
<span class="lineNum">     357 </span>            : {
<span class="lineNum">     358 </span>            :     cStore = 0x1,         ///&lt; C-STORE
<span class="lineNum">     359 </span>            :     cGet = 0x10,          ///&lt; C-GET
<span class="lineNum">     360 </span>            :     cFind = 0x20,         ///&lt; C-FIND
<span class="lineNum">     361 </span>            :     cMove = 0x21,         ///&lt; C-MOVE
<span class="lineNum">     362 </span>            :     cCancel = 0xfff,      ///&lt; C-CANCEL
<span class="lineNum">     363 </span>            :     cEcho = 0x30,         ///&lt; C-ECHO
<span class="lineNum">     364 </span>            :     nEventReport = 0x100, ///&lt; N-EVENT_REPORT
<span class="lineNum">     365 </span>            :     nGet = 0x110,         ///&lt; N-GET
<span class="lineNum">     366 </span>            :     nSet = 0x120,         ///&lt; N-SET
<span class="lineNum">     367 </span>            :     nAction = 0x130,      ///&lt; N-ACTION
<span class="lineNum">     368 </span>            :     nCreate = 0x140,      ///&lt; N-CREATE
<span class="lineNum">     369 </span>            :     nDelete = 0x150,      ///&lt; N-DELETE
<span class="lineNum">     370 </span>            :     response = 0x8000     ///&lt; Bit set for response messages
<span class="lineNum">     371 </span>            : };
<span class="lineNum">     372 </span>            : 
<span class="lineNum">     373 </span>            : 
<span class="lineNum">     374 </span>            : ///
<span class="lineNum">     375 </span>            : /// \brief DIMSE command priorities.
<span class="lineNum">     376 </span>            : ///
<span class="lineNum">     377 </span>            : ///////////////////////////////////////////////////////////////////////////////
<span class="lineNum">     378 </span>            : enum class dimseCommandPriority_t: std::uint16_t
<span class="lineNum">     379 </span>            : {
<span class="lineNum">     380 </span>            :     low = 0x2,  ///&lt; Low priority
<span class="lineNum">     381 </span>            :     medium = 0, ///&lt; Medium priority
<span class="lineNum">     382 </span>            :     high = 0x1  ///&lt; High priority
<span class="lineNum">     383 </span>            : };
<span class="lineNum">     384 </span>            : 
<span class="lineNum">     385 </span>            : 
<span class="lineNum">     386 </span>            : ///
<span class="lineNum">     387 </span>            : /// \brief The DICOM response status code.
<span class="lineNum">     388 </span>            : ///
<span class="lineNum">     389 </span>            : //////////////////////////////////////////////////////////////////
<span class="lineNum">     390 </span>            : enum class dimseStatusCode_t: std::uint16_t
<span class="lineNum">     391 </span>            : {
<span class="lineNum">     392 </span>            :     success = 0,                                           ///&lt; Success
<span class="lineNum">     393 </span>            :     unsupportedOptionalAttributes = 0x0001,                ///&lt; Requested optional Attributes are not supported
<span class="lineNum">     394 </span>            :     cannotUpdateperformedProcedureStepObject = 0x0110,     ///&lt; Performed Procedure Step Object may no longer be updated
<span class="lineNum">     395 </span>            :     unsupportedSOPClass = 0x0122,                          ///&lt; SOP Class not Supported
<span class="lineNum">     396 </span>            :     outOfResources = 0xa700,                               ///&lt; Refused: Out of resources
<span class="lineNum">     397 </span>            :     outOfResourcesCannotCalculateNumberOfMatches = 0xa701, ///&lt; Refused: Out of Resources - Unable to calculate number of matches
<span class="lineNum">     398 </span>            :     outOfResourcesCannotPerformSubOperations = 0xa702,     ///&lt; Refused: Out of Resources - Unable to perform sub-operations
<span class="lineNum">     399 </span>            :     moveDestinationUnknown = 0xa801,                       ///&lt; Refused: Move Destination unknown
<span class="lineNum">     400 </span>            :     identifierDoesNotMatchSOPClass = 0xa900,               ///&lt; Identifier does not match SOP Class
<span class="lineNum">     401 </span>            :     subOperationCompletedWithErrors = 0xb000,              ///&lt; Sub-operations Complete - One or more Failures
<span class="lineNum">     402 </span>            :     elementDiscarded = 0xb006,                             ///&lt; Element discarded
<span class="lineNum">     403 </span>            :     datasetDoesNotMatchSOPClass = 0xb007,                  ///&lt; Data Set does not match SOP Class
<span class="lineNum">     404 </span>            :     UPSAlreadyCanceled = 0xb304,                           ///&lt; The UPS is already in the requested state of CANCELED
<span class="lineNum">     405 </span>            :     coercedInvalidValuesToValidValues = 0xb305,            ///&lt; Coerced invalid values to valid values
<span class="lineNum">     406 </span>            :     UPSStateAlreadyCompleted = 0xb306,                     ///&lt; The UPS is already in the requested state of COMPLETED
<span class="lineNum">     407 </span>            :     unableToProcess = 0xc000,                              ///&lt; Unable to process
<span class="lineNum">     408 </span>            :     moreThanOneMatchFound = 0xc100,                        ///&lt; More than one match found,
<span class="lineNum">     409 </span>            :     CannotSupportRequestedTemplate = 0xc200,               ///&lt; Unable to support requested template
<span class="lineNum">     410 </span>            :     UPSNotUpdated = 0xc300,                                ///&lt; Refused: The UPS may no longer be updated
<span class="lineNum">     411 </span>            :     transactionUIDNotProvided = 0xc301,                    ///&lt; Refused: The correct Transaction UID was not provided
<span class="lineNum">     412 </span>            :     UPSAlreadyInProgress = 0xc302,                         ///&lt; Refused: The UPS is already IN PROGRESS
<span class="lineNum">     413 </span>            :     canScheduleOnlyWithNCreate = 0xc303,                   ///&lt; Refused: The UPS may only become SCHEDULED via N-CREATE, not N-SET or N-ACTION
<span class="lineNum">     414 </span>            :     UPSCannotChangeState = 0xc304,                         ///&lt; Refused: The UPS has not met final state requirements for the requested state change
<span class="lineNum">     415 </span>            :     instanceUIDDoesNotExist = 0xc307,                      ///&lt; Specified SOP Instance UID does not exist or is not a UPS Instance managed by this SCP
<span class="lineNum">     416 </span>            :     unknownAETitle = 0xc308,                               ///&lt; Receiving AE-TITLE is Unknown to this SCP
<span class="lineNum">     417 </span>            :     UPSNotSchedule = 0xc309,                               ///&lt; Refused: The provided value of UPS State was not SCHEDULED
<span class="lineNum">     418 </span>            :     UPSNotInProgress = 0xc310,                             ///&lt; Refused: The UPS is not yet in the &quot;IN PROGRESS&quot; state
<span class="lineNum">     419 </span>            :     UPSAlreadyCompleted = 0xc311,                          ///&lt; Refused: The UPS is already COMPLETED
<span class="lineNum">     420 </span>            :     performerCannotBeContacted = 0xc312,                   ///&lt; Refused: The performer cannot be contacted
<span class="lineNum">     421 </span>            :     performerDoesNotCancel = 0xc313,                       ///&lt; Refused: Performer chooses not to cancel
<span class="lineNum">     422 </span>            :     unappropriateActionForInstance = 0xc314,               ///&lt; Refused: Specified action not appropriate for specified instance
<span class="lineNum">     423 </span>            :     SCPDoesNotSupportEventReports = 0xc315,                ///&lt; Refused: SCP does not support Event Reports
<span class="lineNum">     424 </span>            :     canceled = 0xfe00,                                     ///&lt; Terminated due to Cancel request
<span class="lineNum">     425 </span>            :     pending = 0xff00,                                      ///&lt; Pending
<span class="lineNum">     426 </span>            :     pendingWithWarnings = 0xff01                           ///&lt; Pending with warnings
<span class="lineNum">     427 </span>            : };
<span class="lineNum">     428 </span>            : 
<span class="lineNum">     429 </span>            : 
<span class="lineNum">     430 </span>            : ///
<span class="lineNum">     431 </span>            : /// \brief Simplified DIMSE response status code, derived from
<span class="lineNum">     432 </span>            : ///        dimseStatusCode_t.
<span class="lineNum">     433 </span>            : ///
<span class="lineNum">     434 </span>            : //////////////////////////////////////////////////////////////////
<span class="lineNum">     435 </span>            : enum class dimseStatus_t
<span class="lineNum">     436 </span>            : {
<span class="lineNum">     437 </span>            :     success, ///&lt; The operation was completed succesfully
<span class="lineNum">     438 </span>            :     warning, ///&lt; The operation was completed with warnings
<span class="lineNum">     439 </span>            :     failure, ///&lt; The operation failed
<span class="lineNum">     440 </span>            :     cancel,  ///&lt; The operation was canceled
<span class="lineNum">     441 </span>            :     pending  ///&lt; The operation is still running
<span class="lineNum">     442 </span>            : 
<span class="lineNum">     443 </span>            : };
<span class="lineNum">     444 </span>            : 
<span class="lineNum">     445 </span>            : 
<span class="lineNum">     446 </span>            : ///
<span class="lineNum">     447 </span>            : /// \brief List of tag ids.
<span class="lineNum">     448 </span>            : ///
<span class="lineNum">     449 </span>            : //////////////////////////////////////////////////////////////////
<span class="lineNum">     450 </span>            : typedef std::vector&lt;tagId_t&gt; attributeIdentifierList_t;
<span class="lineNum">     451 </span>            : 
<span class="lineNum">     452 </span>            : 
<span class="lineNum">     453 </span>            : 
<span class="lineNum">     454 </span>            : } // namespace imebra
<span class="lineNum">     455 </span>            : 
<span class="lineNum">     456 </span>            : #endif // imebraDefinitions__INCLUDED_
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../../../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.13</a></td></tr>
  </table>
  <br>

</body>
</html>
